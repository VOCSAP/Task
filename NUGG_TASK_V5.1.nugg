<?xml version="1.0" encoding="utf-8"?>
<nugget name="TASK_V6">
 <TABL TABNAME="ZTEC_S_TASK_PROCESS_BY_FORM" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Tâche - Traitement par Routine" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_TASK_PROCESS_BY_FORM" FIELDNAME="REPID" DDLANGUAGE="F" POSITION="0001" ROLLNAME="REPID" ADMINFIELD="0" INTTYPE="C" INTLEN="000080" DOMNAME="PROGNAME" ROUTPUTLEN="000000" HEADLEN="10" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom du programme ABAP" REPTEXT="Programme" SCRTEXT_S="Programme" SCRTEXT_M="Nom programme" SCRTEXT_L="Nom du programme" DOMNAME3L="PROGNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_PROCESS_BY_FORM" FIELDNAME="FORM" DDLANGUAGE="F" POSITION="0002" ROLLNAME="FORMID" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="CHAR30" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="20" SCRLEN3="30" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom d&apos;une routine FORM" REPTEXT="Nom de la routine FORM" SCRTEXT_S="Nom FORM" SCRTEXT_M="Nom routine FORM" SCRTEXT_L="Nom de la routine FORM" DOMNAME3L="CHAR30" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTEC_S_TASK_PROCESS_BY_METHOD" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Tâche - Traitement par Méthode" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_TASK_PROCESS_BY_METHOD" FIELDNAME="INSTANCE" POSITION="0001" ROLLNAME="OBJECT" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="REF" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  REF RO" MASKLEN="0000" DEPTH="00" COMPTYPE="R" REFTYPE="O" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_PROCESS_BY_METHOD" FIELDNAME="METHOD" DDLANGUAGE="F" POSITION="0002" ADMINFIELD="0" INTTYPE="g" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRG" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRG" MASKLEN="0000" DDTEXT="Méthode à appeler" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTEC_S_TASK_CALL_FUNCTION" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Données pour appel Module Fonction" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_TASK_CALL_FUNCTION" FIELDNAME="FUNCTION_NAME" DDLANGUAGE="F" POSITION="0001" ROLLNAME="FUNCNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="FUNCNAME" ROUTPUTLEN="000000" MEMORYID="LIB" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TFDIR" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom de fonction" DOMNAME3L="FUNCNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_CALL_FUNCTION" FIELDNAME="T_FUNCTION_PARAMETERS" DDLANGUAGE="F" POSITION="0002" ROLLNAME="ZTEC_T_FUNCTION_PARAMETERS" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Type de table paramètre d&apos;appel Statique" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTEC_S_TASK_CALL_METHOD" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Données pour appel Méthode" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_TASK_CALL_METHOD" FIELDNAME="CLASS_NAME" DDLANGUAGE="F" POSITION="0001" ROLLNAME="SEOCLSNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="SEOCLSNAME" ROUTPUTLEN="000000" MEMORYID="CLASS" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom de type d&apos;objet" REPTEXT="Nom de type d&apos;objet" SCRTEXT_S="Type objet" SCRTEXT_M="Nom type objet" SCRTEXT_L="Classe/Interface" DOMNAME3L="SEOCLSNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_CALL_METHOD" FIELDNAME="METHOD_NAME" DDLANGUAGE="F" POSITION="0002" ROLLNAME="SEOCPDNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000122" DOMNAME="CHAR61" ROUTPUTLEN="000000" HEADLEN="61" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000061" OUTPUTLEN="000061" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom de composante complet" REPTEXT="Composante d&apos;interface" SCRTEXT_S="Comp. int." SCRTEXT_M="Comp. interface" SCRTEXT_L="Composante interface" DOMNAME3L="CHAR61" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_CALL_METHOD" FIELDNAME="T_METHOD_PARAMETERS" DDLANGUAGE="F" POSITION="0003" ROLLNAME="ZTEC_T_METHOD_PARAMETERS" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Méthode : Type de table paramétres d&apos;appel Statique" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTEC_S_CONTENT_DATA" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Structure contenu des données - statiques" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_CONTENT_DATA" FIELDNAME="SUB_DATA_GUID" DDLANGUAGE="F" POSITION="0001" ROLLNAME="SYSUUID_C32" ADMINFIELD="0" INTTYPE="C" INTLEN="000064" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="04" SCRLEN2="04" SCRLEN3="04" DTELMASTER="D" DATATYPE="CHAR" LENG="000032" OUTPUTLEN="000032" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="16 Byte UUID in 32 Characters (Hexadecimal Encoded)" REPTEXT="UUID" SCRTEXT_S="UUID" SCRTEXT_M="UUID" SCRTEXT_L="UUID" DOMNAME3L="SYSUUID_C32" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_CONTENT_DATA" FIELDNAME="LINE" DDLANGUAGE="F" POSITION="0002" ROLLNAME="SYST_TABIX" ADMINFIELD="0" INTTYPE="X" INTLEN="000004" DOMNAME="SYST_LONG" ROUTPUTLEN="000000" HEADLEN="10" SCRLEN1="10" SCRLEN2="20" SCRLEN3="20" DTELMASTER="D" DATATYPE="INT4" LENG="000010" OUTPUTLEN="000011" DECIMALS="000000" SIGNFLAG="X" MASK="  INT4E" MASKLEN="0000" DDTEXT="Zone système ABAP : index de ligne de tables internes" REPTEXT="Ligne" SCRTEXT_S="Ligne" SCRTEXT_M="Entrée de table" SCRTEXT_L="Entrée de table" DOMNAME3L="SYST_LONG" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_CONTENT_DATA" FIELDNAME="FIELDNAME" DDLANGUAGE="F" POSITION="0003" ROLLNAME="FIELDNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="FDNAME" ROUTPUTLEN="000000" MEMORYID="DFD" HEADLEN="10" SCRLEN1="10" SCRLEN2="15" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD03L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom de zone" REPTEXT="Nom zone" SCRTEXT_S="Zone" SCRTEXT_M="Nom de zone" SCRTEXT_L="Nom de zone" DOMNAME3L="FDNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_CONTENT_DATA" FIELDNAME="FIELDTYPE" DDLANGUAGE="F" POSITION="0004" ADMINFIELD="0" INTTYPE="g" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRG" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRG" MASKLEN="0000" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_CONTENT_DATA" FIELDNAME="FIELDKIND" DDLANGUAGE="F" POSITION="0005" ROLLNAME="TYPEKIND" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="TYPEKIND" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="03" SCRLEN2="16" SCRLEN3="16" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Catégorie du type de dictionnaire" REPTEXT="Cat" SCRTEXT_S="Cat" SCRTEXT_M="Cat. type (codé)" SCRTEXT_L="Cat. type (codé)" DOMNAME3L="TYPEKIND" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_CONTENT_DATA" FIELDNAME="VALUE" DDLANGUAGE="F" POSITION="0006" ADMINFIELD="0" INTTYPE="g" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRG" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRG" MASKLEN="0000" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTEC_S_FUNCTION_PARAMETERS" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Structure paramétres d&apos;appel statique" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_FUNCTION_PARAMETERS" FIELDNAME="PARAMETER_NAME" DDLANGUAGE="F" POSITION="0001" ROLLNAME="PARAMETER" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="LPARAMETER" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom du paramètre" REPTEXT="Nom de paramètre" SCRTEXT_S="Nom param." SCRTEXT_M="Nom paramètre" SCRTEXT_L="Nom de paramètre" DOMNAME3L="LPARAMETER" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_FUNCTION_PARAMETERS" FIELDNAME="PARAMETER_KIND" DDLANGUAGE="F" POSITION="0002" ROLLNAME="SRAL_PARAM_KIND_RFC" ADMINFIELD="0" INTTYPE="X" INTLEN="000001" DOMNAME="SRAL_PARAM_KIND_RFC" ROUTPUTLEN="000000" HEADLEN="09" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="E" DATATYPE="INT1" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" VALEXI="X" MASK="  INT1E" MASKLEN="0000" DDTEXT="RAL : type de paramètre RFC" REPTEXT="Paramètre" SCRTEXT_S="Paramètre" SCRTEXT_M="Paramètre" SCRTEXT_L="Paramètre" DOMNAME3L="SRAL_PARAM_KIND_RFC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_FUNCTION_PARAMETERS" FIELDNAME="VALUE_TYPE" DDLANGUAGE="F" POSITION="0003" ROLLNAME="RS38L_TYP" ADMINFIELD="0" INTTYPE="C" INTLEN="000264" DOMNAME="RS38L_TYP" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000132" OUTPUTLEN="000132" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Type de référence d&apos;un paramètre d&apos;interface" REPTEXT="Type réf." SCRTEXT_S="Type réf." SCRTEXT_M="Type réf." SCRTEXT_L="Type réf." DOMNAME3L="RS38L_TYP" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_FUNCTION_PARAMETERS" FIELDNAME="VALUE_KIND" DDLANGUAGE="F" POSITION="0004" ROLLNAME="TYPEKIND" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="TYPEKIND" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="03" SCRLEN2="16" SCRLEN3="16" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Catégorie du type de dictionnaire" REPTEXT="Cat" SCRTEXT_S="Cat" SCRTEXT_M="Cat. type (codé)" SCRTEXT_L="Cat. type (codé)" DOMNAME3L="TYPEKIND" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_FUNCTION_PARAMETERS" FIELDNAME="VALUE_DATA" DDLANGUAGE="F" POSITION="0005" ADMINFIELD="0" INTTYPE="g" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRG" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRG" MASKLEN="0000" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_FUNCTION_PARAMETERS" FIELDNAME="VALUE_DATA_XML" DDLANGUAGE="F" POSITION="0006" ADMINFIELD="0" INTTYPE="y" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="RSTR" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  RSTR" MASKLEN="0000" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTEC_S_METHOD_PARAMETERS" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Méthode : Structure paramétre d&apos;appel Statique" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_METHOD_PARAMETERS" FIELDNAME="PARAMETER_NAME" DDLANGUAGE="F" POSITION="0001" ROLLNAME="SEOSCONAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="CHAR30" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom de sous-composante" REPTEXT="Sous-composante" SCRTEXT_S="Sous-comp." SCRTEXT_M="Sous-composante" SCRTEXT_L="Sous-composante" DOMNAME3L="CHAR30" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_METHOD_PARAMETERS" FIELDNAME="PARAMETER_KIND" DDLANGUAGE="F" POSITION="0002" ROLLNAME="SEOPARDECL" ADMINFIELD="0" INTTYPE="N" INTLEN="000002" DOMNAME="SEOPARDECL" ROUTPUTLEN="000000" HEADLEN="01" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="NUMC" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Type de déclaration paramètre (depuis vue utilisateur)" REPTEXT="D" SCRTEXT_S="Type décl." SCRTEXT_M="T. déclaration" SCRTEXT_L="Ty. décl. paramètr." DOMMASTER="D" DOMNAME3L="SEOPARDECL" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_METHOD_PARAMETERS" FIELDNAME="VALUE_TYPE" DDLANGUAGE="F" POSITION="0003" ROLLNAME="RS38L_TYP" ADMINFIELD="0" INTTYPE="C" INTLEN="000264" DOMNAME="RS38L_TYP" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000132" OUTPUTLEN="000132" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Type de référence d&apos;un paramètre d&apos;interface" REPTEXT="Type réf." SCRTEXT_S="Type réf." SCRTEXT_M="Type réf." SCRTEXT_L="Type réf." DOMNAME3L="RS38L_TYP" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_METHOD_PARAMETERS" FIELDNAME="VALUE_KIND" DDLANGUAGE="F" POSITION="0004" ROLLNAME="TYPEKIND" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="TYPEKIND" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="03" SCRLEN2="16" SCRLEN3="16" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Catégorie du type de dictionnaire" REPTEXT="Cat" SCRTEXT_S="Cat" SCRTEXT_M="Cat. type (codé)" SCRTEXT_L="Cat. type (codé)" DOMNAME3L="TYPEKIND" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_METHOD_PARAMETERS" FIELDNAME="VALUE_DATA" DDLANGUAGE="F" POSITION="0005" ADMINFIELD="0" INTTYPE="g" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRG" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRG" MASKLEN="0000" DDTEXT="Valeur" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_METHOD_PARAMETERS" FIELDNAME="VALUE_DATA_XML" DDLANGUAGE="F" POSITION="0006" ADMINFIELD="0" INTTYPE="y" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="RSTR" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  RSTR" MASKLEN="0000" DDTEXT="XML (pour type complexe)" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TTYP TYPENAME="ZTEC_T_CONTENT_DATA" DDLANGUAGE="F" ROWTYPE="ZTEC_S_CONTENT_DATA" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="S" KEYDEF="K" KEYKIND="U" KEYFDCOUNT="0003" DDTEXT="Table contenu de données - statiques" TYPELEN="000148" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000">
  <dd42v TYPENAME="ZTEC_T_CONTENT_DATA" KEYFDPOS="0001" ROWTYPEPOS="0001" KEYFIELD="SUB_DATA_GUID"/>
  <dd42v TYPENAME="ZTEC_T_CONTENT_DATA" KEYFDPOS="0002" ROWTYPEPOS="0002" KEYFIELD="LINE"/>
  <dd42v TYPENAME="ZTEC_T_CONTENT_DATA" KEYFDPOS="0003" ROWTYPEPOS="0003" KEYFIELD="FIELDNAME"/>
 </TTYP>
 <TTYP TYPENAME="ZTEC_T_FUNCTION_PARAMETERS" DDLANGUAGE="F" ROWTYPE="ZTEC_S_FUNCTION_PARAMETERS" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Type de table paramètre d&apos;appel Statique" TYPELEN="000344" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZTEC_T_METHOD_PARAMETERS" DDLANGUAGE="F" ROWTYPE="ZTEC_S_METHOD_PARAMETERS" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Méthode : Type de table paramétres d&apos;appel Statique" TYPELEN="000344" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <DTEL ROLLNAME="ZTRACE_XFELD" DDLANGUAGE="F" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="12" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DDTEXT="Trace - Activation de trace" REPTEXT="Trace active" SCRTEXT_S="Trace" SCRTEXT_M="Trace active" SCRTEXT_L="Trace active" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" DECIMALS="000000" OUTPUTLEN="000001" VALEXI="X" REFKIND="D">
  <tpara/>
 </DTEL>
 <DTEL ROLLNAME="ZTRACE_MEM_XFELD" DDLANGUAGE="F" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="20" SCRLEN3="20" DDTEXT="Trace - Activation Trace mémoire" REPTEXT="Trace mémoire active" SCRTEXT_S="Trace mém" SCRTEXT_M="Trace mémoire active" SCRTEXT_L="Trace mémoire active" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" DECIMALS="000000" OUTPUTLEN="000001" VALEXI="X" REFKIND="D">
  <tpara/>
 </DTEL>
 <DTEL ROLLNAME="ZTASK_TRACE_ID" DDLANGUAGE="F" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="08" SCRLEN1="08" SCRLEN2="08" SCRLEN3="08" DDTEXT="Tâche - ID Trace" REPTEXT="ID Trace" SCRTEXT_S="ID Trace" SCRTEXT_M="ID Trace" SCRTEXT_L="ID Trace" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" DECIMALS="000000" OUTPUTLEN="000032" REFKIND="D">
  <tpara/>
 </DTEL>
 <DTEL ROLLNAME="ZTASK_MANAGER_ID" DDLANGUAGE="F" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="32" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DDTEXT="Tâche - ID Manager Tâche" REPTEXT="ID Manager Tâche" SCRTEXT_S="ID Manager" SCRTEXT_M="ID Manager" SCRTEXT_L="ID Manager Tâche" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" DECIMALS="000000" OUTPUTLEN="000032" REFKIND="D">
  <tpara/>
 </DTEL>
 <DTEL ROLLNAME="ZTASK_ID" DDLANGUAGE="F" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="32" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DDTEXT="Tâche - ID Tâche" REPTEXT="ID Tâche" SCRTEXT_S="ID Tâche" SCRTEXT_M="ID Tâche" SCRTEXT_L="ID Tâche" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" DECIMALS="000000" OUTPUTLEN="000032" REFKIND="D">
  <tpara/>
 </DTEL>
 <DTEL ROLLNAME="ZSHM_MANAGEMENT" DDLANGUAGE="F" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="17" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DDTEXT="SHM - Gestion de la SHM" REPTEXT="Gestion de la SHM" SCRTEXT_S="Gest. SHM" SCRTEXT_M="Gest. SHM" SCRTEXT_L="Gestion de la SHM" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" DECIMALS="000000" OUTPUTLEN="000001" VALEXI="X" REFKIND="D">
  <tpara/>
 </DTEL>
 <TABL TABNAME="ZTASK_FUNC_PARAM" DDLANGUAGE="F" TABCLASS="TRANSP" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" CLIDEP="X" DDTEXT="Tâche - Paramétrage sur MF" AUTHCLASS="00" MAINFLAG="X" CONTFLAG="A" PROZPUFF="000" EXCLASS="1">
  <dd09l TABNAME="ZTASK_FUNC_PARAM" AS4LOCAL="A" AS4VERS="0000" TABKAT="0" TABART="APPL1" PUFFERUNG="X" SCHFELDANZ="000" BUFALLOW="X"/>
  <dd03p TABNAME="ZTASK_FUNC_PARAM" FIELDNAME="MANDT" DDLANGUAGE="F" POSITION="0001" KEYFLAG="X" ROLLNAME="MANDT" ADMINFIELD="0" INTTYPE="C" INTLEN="000006" NOTNULL="X" DOMNAME="MANDT" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CLNT" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" ENTITYTAB="T000" MASK="  CLNTE" MASKLEN="0000" DDTEXT="Mandant" REPTEXT="Mdt" SCRTEXT_S="Mandant" SCRTEXT_M="Mandant" SCRTEXT_L="Mandant" DOMNAME3L="MANDT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_FUNC_PARAM" FIELDNAME="FUNCNAME" DDLANGUAGE="F" POSITION="0002" KEYFLAG="X" ROLLNAME="RS38L_FNAM" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" NOTNULL="X" DOMNAME="FUNCNAME" ROUTPUTLEN="000000" MEMORYID="LIB" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TFDIR" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom du module fonction" REPTEXT="Nom du module fonction" SCRTEXT_S="Mod. fct." SCRTEXT_M="Module fonction" SCRTEXT_L="Module fonction" DOMNAME3L="FUNCNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_FUNC_PARAM" FIELDNAME="TRACE_ACTIVE" DDLANGUAGE="F" POSITION="0003" ROLLNAME="ZTRACE_XFELD" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="12" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Trace - Activation de trace" REPTEXT="Trace active" SCRTEXT_S="Trace" SCRTEXT_M="Trace active" SCRTEXT_L="Trace active" DOMNAME3L="XFELD" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_FUNC_PARAM" FIELDNAME="SHM_MANAGEMENT" DDLANGUAGE="F" POSITION="0004" ROLLNAME="ZSHM_MANAGEMENT" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="17" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="SHM - Gestion de la SHM" REPTEXT="Gestion de la SHM" SCRTEXT_S="Gest. SHM" SCRTEXT_M="Gest. SHM" SCRTEXT_L="Gestion de la SHM" DOMNAME3L="XFELD" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_FUNC_PARAM" FIELDNAME="TRACE_MEMORY" DDLANGUAGE="F" POSITION="0005" ROLLNAME="ZTRACE_MEM_XFELD" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="20" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Trace - Activation Trace mémoire" REPTEXT="Trace mémoire active" SCRTEXT_S="Trace mém" SCRTEXT_M="Trace mémoire active" SCRTEXT_L="Trace mémoire active" DOMNAME3L="XFELD" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTASK_TRACE_H" DDLANGUAGE="F" TABCLASS="TRANSP" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" CLIDEP="X" LANGDEP="X" DDTEXT="Tâche - Historique" AUTHCLASS="00" CONTFLAG="A" PROZPUFF="000" EXCLASS="4">
  <dd09l TABNAME="ZTASK_TRACE_H" AS4LOCAL="A" AS4VERS="0000" TABKAT="0" TABART="APPL1" SCHFELDANZ="000" BUFALLOW="N" ROWORCOLST="C"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="MANDT" DDLANGUAGE="F" POSITION="0001" KEYFLAG="X" ROLLNAME="MANDT" ADMINFIELD="0" INTTYPE="C" INTLEN="000006" NOTNULL="X" DOMNAME="MANDT" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CLNT" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" ENTITYTAB="T000" MASK="  CLNTE" MASKLEN="0000" DDTEXT="Mandant" REPTEXT="Mdt" SCRTEXT_S="Mandant" SCRTEXT_M="Mandant" SCRTEXT_L="Mandant" DOMNAME3L="MANDT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="TASK_TRACE_ID" DDLANGUAGE="F" POSITION="0002" KEYFLAG="X" ROLLNAME="ZTASK_TRACE_ID" ADMINFIELD="0" INTTYPE="C" INTLEN="000064" NOTNULL="X" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="08" SCRLEN1="08" SCRLEN2="08" SCRLEN3="08" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" OUTPUTLEN="000032" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Tâche - ID Trace" REPTEXT="ID Trace" SCRTEXT_S="ID Trace" SCRTEXT_M="ID Trace" SCRTEXT_L="ID Trace" DOMNAME3L="SYSUUID_C32" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="TASK_MANAGER_ID" DDLANGUAGE="F" POSITION="0003" ROLLNAME="ZTASK_MANAGER_ID" ADMINFIELD="0" INTTYPE="C" INTLEN="000064" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="32" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" OUTPUTLEN="000032" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Tâche - ID Manager Tâche" REPTEXT="ID Manager Tâche" SCRTEXT_S="ID Manager" SCRTEXT_M="ID Manager" SCRTEXT_L="ID Manager Tâche" DOMNAME3L="SYSUUID_C32" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="TASK_ID" DDLANGUAGE="F" POSITION="0004" ROLLNAME="ZTASK_ID" ADMINFIELD="0" INTTYPE="C" INTLEN="000064" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="32" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" OUTPUTLEN="000032" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Tâche - ID Tâche" REPTEXT="ID Tâche" SCRTEXT_S="ID Tâche" SCRTEXT_M="ID Tâche" SCRTEXT_L="ID Tâche" DOMNAME3L="SYSUUID_C32" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="FUNCNAME" DDLANGUAGE="F" POSITION="0005" ROLLNAME="RS38L_FNAM" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="FUNCNAME" ROUTPUTLEN="000000" MEMORYID="LIB" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TFDIR" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom du module fonction" REPTEXT="Nom du module fonction" SCRTEXT_S="Mod. fct." SCRTEXT_M="Module fonction" SCRTEXT_L="Module fonction" DOMNAME3L="FUNCNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="TIMESTAMP_BEG" DDLANGUAGE="F" POSITION="0006" ROLLNAME="TIMESTAMP" ADMINFIELD="0" INTTYPE="P" INTLEN="000008" DOMNAME="TZNTSTMPS" ROUTPUTLEN="000000" HEADLEN="19" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="DEC" LENG="000015" OUTPUTLEN="000019" DECIMALS="000000" MASK="  DEC E" MASKLEN="0000" DDTEXT="Horodatage UTC en abrégé (AAAAMMJJhhmmss)" REPTEXT="Horodatage" SCRTEXT_S="Horodatage" SCRTEXT_M="Horodatage" SCRTEXT_L="Horodatage" DOMMASTER="D" DOMNAME3L="TZNTSTMPS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="TIMESTAMP_END" DDLANGUAGE="F" POSITION="0007" ROLLNAME="TIMESTAMP" ADMINFIELD="0" INTTYPE="P" INTLEN="000008" DOMNAME="TZNTSTMPS" ROUTPUTLEN="000000" HEADLEN="19" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="DEC" LENG="000015" OUTPUTLEN="000019" DECIMALS="000000" MASK="  DEC E" MASKLEN="0000" DDTEXT="Horodatage UTC en abrégé (AAAAMMJJhhmmss)" REPTEXT="Horodatage" SCRTEXT_S="Horodatage" SCRTEXT_M="Horodatage" SCRTEXT_L="Horodatage" DOMMASTER="D" DOMNAME3L="TZNTSTMPS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="RUNTIME_BEG" DDLANGUAGE="F" POSITION="0008" ADMINFIELD="0" INTTYPE="X" INTLEN="000004" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="INT4" LENG="000010" OUTPUTLEN="000000" DECIMALS="000000" MASK="  INT4" MASKLEN="0000" DDTEXT="Début d&apos;exécution" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="RUNTIME_END" DDLANGUAGE="F" POSITION="0009" ADMINFIELD="0" INTTYPE="X" INTLEN="000004" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="INT4" LENG="000010" OUTPUTLEN="000000" DECIMALS="000000" MASK="  INT4" MASKLEN="0000" DDTEXT="Fin d&apos;exécution" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="RUNTIME_EXEC" DDLANGUAGE="F" POSITION="0010" ADMINFIELD="0" INTTYPE="X" INTLEN="000004" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="INT4" LENG="000010" OUTPUTLEN="000000" DECIMALS="000000" MASK="  INT4" MASKLEN="0000" DDTEXT="Durée d&apos;exécution" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="MEM_BEFORE" DDLANGUAGE="F" POSITION="0011" ADMINFIELD="0" INTTYPE="P" INTLEN="000011" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="DEC" LENG="000020" OUTPUTLEN="000000" DECIMALS="000000" MASK="  DEC" MASKLEN="0000" DDTEXT="Type DEC correct pour nombre entier 64 octets" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="MEM_AFTER" DDLANGUAGE="F" POSITION="0012" ADMINFIELD="0" INTTYPE="P" INTLEN="000011" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="DEC" LENG="000020" OUTPUTLEN="000000" DECIMALS="000000" MASK="  DEC" MASKLEN="0000" DDTEXT="Type DEC correct pour nombre entier 64 octets" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="MEM_ALLOCATED" DDLANGUAGE="F" POSITION="0013" ADMINFIELD="0" INTTYPE="P" INTLEN="000011" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="DEC" LENG="000020" OUTPUTLEN="000000" DECIMALS="000000" MASK="  DEC" MASKLEN="0000" DDTEXT="Type DEC correct pour nombre entier 64 octets" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="UNAME" DDLANGUAGE="F" POSITION="0014" ROLLNAME="UNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000024" DOMNAME="UNAME" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000012" OUTPUTLEN="000012" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom d&apos;utilisateur" REPTEXT="Nom d&apos;utilisateur" SCRTEXT_S="Utilisat." SCRTEXT_M="Nom utilisateur" SCRTEXT_L="Nom d&apos;utilisateur" DOMNAME3L="UNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME=".INCLUDE" DDLANGUAGE="F" POSITION="0015" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ABAP_CALLSTACK_LINE" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Ligne d&apos;une pile d&apos;appel ABAP (avec positions programme)" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="MAINPROGRAM" DDLANGUAGE="F" POSITION="0016" ROLLNAME="SYREPID" ADMINFIELD="1" INTTYPE="C" INTLEN="000080" DOMNAME="PROGRAMM" ROUTPUTLEN="000000" HEADLEN="08" SCRLEN1="10" SCRLEN2="20" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" ENTITYTAB="TRDIR" MASK="  CHARE" MASKLEN="0000" DDTEXT="Programme ABAP, programme cadre actuel" REPTEXT="Progr." SCRTEXT_S="Programme" SCRTEXT_M="Nom du programme" SCRTEXT_L="Nom du programme" DOMNAME3L="PROGRAMM" DEPTH="00" COMPTYPE="E" DEFFDNAME="PROGRAM_NAME" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="INCLUDE" DDLANGUAGE="F" POSITION="0017" ROLLNAME="INCLUDE" ADMINFIELD="1" INTTYPE="C" INTLEN="000080" DOMNAME="PROGNAME" ROUTPUTLEN="000000" HEADLEN="08" SCRLEN1="10" SCRLEN2="00" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Include utilisé" REPTEXT="Include" SCRTEXT_S="Include" SCRTEXT_L="Include utilisé" DOMNAME3L="PROGNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="LINE" DDLANGUAGE="F" POSITION="0018" ADMINFIELD="1" INTTYPE="X" INTLEN="000004" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="INT4" LENG="000010" OUTPUTLEN="000000" DECIMALS="000000" MASK="  INT4" MASKLEN="0000" DDTEXT="Numéro de ligne (dans l&apos;include)" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="BLOCKTYPE" DDLANGUAGE="F" POSITION="0019" ADMINFIELD="1" INTTYPE="C" INTLEN="000024" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="CHAR" LENG="000012" OUTPUTLEN="000000" DECIMALS="000000" MASK="  CHAR" MASKLEN="0000" DDTEXT="Type du bloc de traitement (procédure, module, bloc événemt)" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="BLOCKNAME" DDLANGUAGE="F" POSITION="0020" ADMINFIELD="1" INTTYPE="g" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRG" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRG" MASKLEN="0000" DDTEXT="Nom du bloc de traitement" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="FLAG_SYSTEM" DDLANGUAGE="F" POSITION="0021" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000000" DECIMALS="000000" MASK="  CHAR" MASKLEN="0000" DDTEXT="Code : bloc de traitement système ou dans programme système" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TTYP TYPENAME="ZTASK_TRACE_H_T" DDLANGUAGE="F" ROWTYPE="ZTASK_TRACE_H" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Trace Tâche - Type de table" TYPELEN="000548" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <FUGR SPRAS="F" AREA="ZTEC_TASK_PARALLEL" AREAT="GF Traitement Tâche Paralléle">
  <mainprogram NAME="SAPLZTEC_TASK_PARALLEL" VARCL="X" DBAPL="S" DBNA="D$" SUBC="F" APPL="S" RMAND="100" RLOAD="F" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
   <textPool/>
   <source>*******************************************************************
*   System-defined Include-files.                                 *
*******************************************************************
  INCLUDE LZTEC_TASK_PARALLELTOP.            &quot; Global Data
  INCLUDE LZTEC_TASK_PARALLELUXX.            &quot; Function Modules

*******************************************************************
*   User-defined Include-files (if necessary).                    *
*******************************************************************
* INCLUDE LZTEC_TASK_PARALLELF...            &quot; Subroutines
* INCLUDE LZTEC_TASK_PARALLELO...            &quot; PBO-Modules
* INCLUDE LZTEC_TASK_PARALLELI...            &quot; PAI-Modules
* INCLUDE LZTEC_TASK_PARALLELE...            &quot; Events
* INCLUDE LZTEC_TASK_PARALLELP...            &quot; Local class implement.
* INCLUDE LZTEC_TASK_PARALLELT99.            &quot; ABAP Unit tests

INCLUDE lztec_task_parallelf01.</source>
  </mainprogram>
  <includeprograms>
   <include NAME="LZTEC_TASK_PARALLELF01" VARCL="X" SUBC="I" APPL="S" RMAND="100" RLOAD="F" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LZTEC_TASK_PARALLELF01.
*----------------------------------------------------------------------*

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DYNAMIC_PARAMETERS_SET
*&amp;---------------------------------------------------------------------*
*       Initialisation des paramètres dynamique d&apos;appel
*----------------------------------------------------------------------*
*      --&gt; IV_FUNCTION_NAME             Nom du MF à appeler
*      --&gt; IT_FUNCTION_PARAMETERS       Table paramètre statique
*      &lt;-- ET_TABLE_DATA                Table stockage paramètre
*      &lt;-- ET_PARAMETERS                Table paramètre dynamique
*      &lt;-- ET_EXCEPTIONS                Table exception dynamique
*----------------------------------------------------------------------*
FORM dynamic_parameters_set USING iv_function_name       TYPE rs38l_fnam  &quot;#EC NEEDED
                                  it_function_parameters TYPE ztec_t_function_parameters
                         CHANGING et_table_data          TYPE ty_t_table_data
                                  et_parameters          TYPE abap_func_parmbind_tab
                                  et_exceptions          TYPE abap_func_excpbind_tab.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_exceptions TYPE abap_func_excpbind,
    ls_parameters TYPE abap_func_parmbind,
    ls_table_data TYPE ty_table_data.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_type_descr      TYPE REF TO cl_abap_typedescr,
    lo_cx_exception    TYPE REF TO cx_root,
    lo_type_definition TYPE REF TO zcl_type_definition.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_value_data&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : et_parameters, et_exceptions, et_table_data.

  &quot; -----------------------------------------------------------
  &quot; Conversion des paramètres &quot;statiques&quot; en &quot;dynamique&quot;
  &quot; -----------------------------------------------------------

  &quot; Parcours l&apos;ensemble des paramètres &quot;statique&quot;
  LOOP AT it_function_parameters ASSIGNING FIELD-SYMBOL(&lt;lfs_s_function_parameters&gt;).

    CLEAR    : ls_parameters, ls_exceptions, ls_table_data.
    UNASSIGN : &lt;lfs_value_data&gt;.

    &quot; Contrôle cohérence du Type
    cl_abap_typedescr=&gt;describe_by_name(
      EXPORTING
        p_name         = &lt;lfs_s_function_parameters&gt;-value_type
      EXCEPTIONS
        type_not_found = 1
        OTHERS         = 2
    ).
    IF sy-subrc NE 0.
      &quot; Type non défini dans le RTTS du système
      &quot;&quot;  --&gt; On va le charger depuis la mémoire partagée
      IF NOT lo_type_definition IS BOUND.
        &quot; Récupération instance courante
        lo_type_definition = zcl_type_definition=&gt;get_instance( ).

      ENDIF.

      TRY.
          &quot; Récupération de la définition du Type
          lo_type_descr = lo_type_definition-&gt;definition_type_get( &lt;lfs_s_function_parameters&gt;-value_type ).

        CATCH cx_root INTO lo_cx_exception. &quot;#EC CATCH_ALL
          &quot; Erreur lors de la récupération de la définition du Type
          &quot;&quot;  --&gt; Lève une Exception
          WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
          RAISE EXCEPTION TYPE zcx_task_call
            EXPORTING
              previous = lo_cx_exception.

      ENDTRY.

      &quot;&quot;  --&gt; Création de la zone Typée
      CREATE DATA ls_table_data-value TYPE (lo_type_descr-&gt;absolute_name).

    ELSE.
      &quot;&quot;  --&gt; Création de la zone typée
      IF &lt;lfs_s_function_parameters&gt;-parameter_kind EQ zif_task_constant=&gt;mc_parameter_kind_tables.
        &quot; Paramètre Table
        CREATE DATA ls_table_data-value TYPE STANDARD TABLE OF (&lt;lfs_s_function_parameters&gt;-value_type).

      ELSE.
        &quot; Paramètre &lt;&gt; Table
        CREATE DATA ls_table_data-value TYPE (&lt;lfs_s_function_parameters&gt;-value_type).

      ENDIF.

    ENDIF.

    &quot; Initialisation pointeur sur la donnée
    ASSIGN ls_table_data-value-&gt;* TO &lt;lfs_value_data&gt;.

    IF &lt;lfs_s_function_parameters&gt;-parameter_kind EQ zif_task_constant=&gt;mc_parameter_kind_importing.
      &quot; Cas d&apos;un paramètre d&apos;Export
      &quot;&quot;  --&gt; Les paramètres d&apos;Export non pas à être rempli !

    ELSEIF &lt;lfs_s_function_parameters&gt;-parameter_kind EQ zif_task_constant=&gt;mc_parameter_kind_exception.
      &quot; Cas d&apos;une Exception
      &quot;&quot;  --&gt; Ajout de l&apos;Exception
      ls_exceptions-name = &lt;lfs_s_function_parameters&gt;-parameter_name.
      INSERT ls_exceptions INTO TABLE et_exceptions.

      &quot;&quot;  --&gt; Passe à l&apos;itération suivante
      CONTINUE.

    ELSE.
      &quot; Autre type de paramètre
      IF NOT &lt;lfs_s_function_parameters&gt;-value_data_xml IS INITIAL.
        &quot; Données &quot;complexe&quot; stockées sous forme XML
        CALL TRANSFORMATION id
                 SOURCE XML &lt;lfs_s_function_parameters&gt;-value_data_xml
                     RESULT data = &lt;lfs_value_data&gt;.

      ELSEIF NOT &lt;lfs_s_function_parameters&gt;-value_data IS INITIAL.
        &quot; Type Ã‰lémentaire
        &quot;&quot;  --&gt; Initialisation des données
        &lt;lfs_value_data&gt; = &lt;lfs_s_function_parameters&gt;-value_data.

      ELSE. &quot;#EC NEEDED
        &quot; Autre cas
        &quot;&quot;  --&gt; ToDo : Ajouter ici les autres cas

      ENDIF.

    ENDIF.

    &quot;&quot;  --&gt; Création d&apos;une entrée permettant de stocker les paramètres d&apos;appel Dynamique
    ls_table_data-name = &lt;lfs_s_function_parameters&gt;-parameter_name.                &quot;Nom du paramètre
    INSERT ls_table_data INTO TABLE et_table_data.                                  &quot;Ajout dans table de paramètre

    &quot;&quot;  --&gt; Initialisation table paramètre d&apos;appel dynamique
    ls_parameters-name  = &lt;lfs_s_function_parameters&gt;-parameter_name.     &quot;Nom du paramètre
    ls_parameters-kind  = &lt;lfs_s_function_parameters&gt;-parameter_kind.     &quot;Type (ABAP) du paramètre
    ls_parameters-value = REF #( &lt;lfs_value_data&gt; ).                      &quot;Référence sur le contenu
    INSERT ls_parameters INTO TABLE et_parameters.                        &quot;Ajout du paramètre dynamique

  ENDLOOP.

  &quot; -----------------------------------------------------------
  &quot; Fin de traitement
  &quot; -----------------------------------------------------------

  IF lo_type_definition IS BOUND.
    &quot; Libération Token Mémoire Partagée
    lo_type_definition-&gt;definition_type_finish( ).

  ENDIF.

ENDFORM.                    &quot; DYNAMIC_PARAMETERS_SET

*&amp;---------------------------------------------------------------------*
*&amp;      Form  RESULT_SET
*&amp;---------------------------------------------------------------------*
*       Initialisation paramètre de retour
*----------------------------------------------------------------------*
*      --&gt; IT_TABLE_DATA              Table données
*      --&gt; IT_FUNCTION_PARAMETERS     Table paramètre statique
*      &lt;-- ET_RESULT                  Table de retour (statique)
*----------------------------------------------------------------------*
FORM result_set USING it_parameters          TYPE abap_func_parmbind_tab
                      it_function_parameters TYPE ztec_t_function_parameters
             CHANGING et_result              TYPE ztec_t_function_parameters.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_result TYPE ztec_s_function_parameters.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_value&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : et_result.

  &quot; -----------------------------------------------------------
  &quot; Alimentation table de retour
  &quot; -----------------------------------------------------------

  &quot; Constitution table de sortie
  LOOP AT it_parameters ASSIGNING FIELD-SYMBOL(&lt;lfs_s_parameters&gt;).

    CLEAR : ls_result.

    &quot; Récupération données associé au paramètre
    READ TABLE it_function_parameters WITH KEY parameter_name = &lt;lfs_s_parameters&gt;-name
                                     ASSIGNING FIELD-SYMBOL(&lt;lfs_s_function_parameters&gt;).
    IF sy-subrc NE 0.
      &quot; Pas de correspondance // Cas ne devant pas se produire
      &quot;&quot;  --&gt; Passe à l&apos;itération suivante
      CONTINUE.

    ENDIF.

    &quot; Initialisation données du paramètre
    ls_result-parameter_name = &lt;lfs_s_function_parameters&gt;-parameter_name.
    ls_result-parameter_kind = &lt;lfs_s_function_parameters&gt;-parameter_kind.

    &quot; Initialisation données du contenu du paramètre
    ls_result-value_kind = &lt;lfs_s_function_parameters&gt;-value_kind.
    ls_result-value_type = &lt;lfs_s_function_parameters&gt;-value_type.

    &quot; Initialisation pointeur sur les données
    ASSIGN &lt;lfs_s_parameters&gt;-value-&gt;* TO &lt;lfs_value&gt;.

    &quot; Suivant le type de données
    CASE &lt;lfs_s_function_parameters&gt;-value_kind.

      WHEN cl_abap_typedescr=&gt;kind_elem.
        &quot; Ã‰lementaire
        &quot;&quot;  --&gt; Initialisation de la données
        ls_result-value_data = &lt;lfs_value&gt;.

      WHEN OTHERS.
        &quot; Cas structure complexe
        &quot;&quot;  --&gt; Transformation en XML
        CALL TRANSFORMATION id
                     SOURCE data = &lt;lfs_value&gt;
                 RESULT XML ls_result-value_data_xml.

    ENDCASE.

    &quot; Ajout dans la table de sortie
    APPEND ls_result TO et_result.

  ENDLOOP.

ENDFORM.                    &quot; RESULT_SET


*&amp;---------------------------------------------------------------------*
*&amp;      Form  EXCEPTION_TABLE_SET
*&amp;---------------------------------------------------------------------*
*       Initialisation table d&apos;Exception
*----------------------------------------------------------------------*
*      --&gt; IV_FUNCTION_NAME     Nom du MF
*      &lt;-&gt; CT_EXCEPTIONS        Table des Exceptions
*----------------------------------------------------------------------*
FORM exception_table_set USING VALUE(iv_function_name) TYPE clike
                      CHANGING ct_exceptions           TYPE abap_func_excpbind_tab.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_fupararef_exception TYPE ty_t_fupararef_exception.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_exception           TYPE abap_func_excpbind,
    ls_fupararef_exception TYPE ty_fupararef_exception.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération des Exceptions du MF
  &quot; -----------------------------------------------------------

  &quot; Récupération position première occurence associée au MF
  READ TABLE gt_fupararef_exception WITH KEY funcname = iv_function_name
                                TRANSPORTING NO FIELDS
                                      BINARY SEARCH.
  IF sy-subrc NE 0.
    &quot; Aucune Exception
    SELECT funcname parameter pposition FROM fupararef
                                  INTO TABLE lt_fupararef_exception ##TOO_MANY_ITAB_FIELDS
                                       WHERE funcname  EQ iv_function_name
                                         AND paramtype EQ &apos;X&apos;.
    IF sy-subrc NE 0.
      &quot; Création d&apos;une entrée afin de ne pas rechercher à nouveau les données
      ls_fupararef_exception-funcname  = iv_function_name.
      ls_fupararef_exception-not_found = abap_true.
      INSERT ls_fupararef_exception INTO TABLE gt_fupararef_exception.

    ELSE.
      &quot; Ajout des entrées
      INSERT LINES OF lt_fupararef_exception INTO TABLE gt_fupararef_exception.
      FREE : lt_fupararef_exception.

    ENDIF.

    &quot; Récupération position première occurence
    READ TABLE gt_fupararef_exception WITH KEY funcname = iv_function_name
                                 TRANSPORTING NO FIELDS
                                       BINARY SEARCH.

  ENDIF.

  IF sy-subrc NE 0.
    &quot; Aucune Exception trouvée
    &quot;&quot;  --&gt; Supprime toutes les exceptions présentes
    FREE : ct_exceptions.

    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Récupération des Exceptions du MF
  &quot; -----------------------------------------------------------

  &quot; Parcours l&apos;ensemble des Exceptions
  LOOP AT gt_fupararef_exception ASSIGNING FIELD-SYMBOL(&lt;lfs_s_fupararef_exception&gt;)
                                      FROM sy-tabix.

    CLEAR : ls_exception.

    IF &lt;lfs_s_fupararef_exception&gt;-not_found EQ abap_true.
      &quot; Aucune Exception
      &quot;&quot;  --&gt; Supprime toutes les exceptions présentes (au cas où)
      FREE : ct_exceptions.

      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

    IF &lt;lfs_s_fupararef_exception&gt;-funcname NE iv_function_name.
      &quot; On ne traite plus le même MF
      &quot;&quot;  --&gt; Arrêt de la boucle
      EXIT.

    ENDIF.

    &quot; Recherche si l&apos;Exception est déjà renseigné
    READ TABLE ct_exceptions WITH TABLE KEY name = &lt;lfs_s_fupararef_exception&gt;-parameter
                               TRANSPORTING NO FIELDS.
    IF sy-subrc NE 0.
      &quot; Exception non ajoutée
      &quot;&quot;  --&gt; Ajout de l&apos;Exception
      ls_exception-name = &lt;lfs_s_fupararef_exception&gt;-parameter.
      ls_exception-value = lines( ct_exceptions ) + 1.
      INSERT ls_exception INTO TABLE ct_exceptions.

    ENDIF.

  ENDLOOP.      &quot;Fin de parcours des Exceptions

ENDFORM.                    &quot; EXCEPTION_TABLE_SET</include_source>
   </include>
   <include NAME="LZTEC_TASK_PARALLELTOP" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RMAND="100" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
    <include_source>FUNCTION-POOL ztec_task_parallel.           &quot;MESSAGE-ID ..


***------------------------------------------------------------------***
**                              MACCRO                                **
***------------------------------------------------------------------***


***------------------------------------------------------------------***
**                             CLASSES                                **
***------------------------------------------------------------------***


***------------------------------------------------------------------***
**                              TYPES                                 **
***------------------------------------------------------------------***

&quot; Déclaration de type pour stockage contenu de table
TYPES :
  BEGIN OF ty_table_data,
    name  TYPE        typename,
    value TYPE REF TO data,
  END OF   ty_table_data.

TYPES : ty_t_table_data TYPE SORTED TABLE OF ty_table_data
                             WITH UNIQUE KEY primary_key COMPONENTS name.


&quot; Déclaration de type pour stockage définition champ
TYPES:
  BEGIN OF ty_data_type_descr,
    component  TYPE        string,
    data_descr TYPE REF TO cl_abap_datadescr,
  END OF   ty_data_type_descr .
TYPES:
  ty_t_data_type_descr TYPE SORTED TABLE OF ty_data_type_descr
                                      WITH UNIQUE KEY primary_key COMPONENTS component .

&quot; Déclaration de type pour stockage paramètre d&apos;Exception
TYPES :
  BEGIN OF ty_fupararef_exception,
    funcname  TYPE fupararef-funcname,
    parameter TYPE fupararef-parameter,
    pposition TYPE fupararef-pposition,
    not_found TYPE flag,
  END OF   ty_fupararef_exception.

TYPES : ty_t_fupararef_exception TYPE SORTED TABLE OF ty_fupararef_exception
                                      WITH UNIQUE KEY primary_key COMPONENTS funcname parameter.


***------------------------------------------------------------------***
**                           CONSTANTES                               **
***------------------------------------------------------------------***
CONSTANTS :
  gc_table_line TYPE string VALUE &apos;TABLE_LINE&apos;.

***------------------------------------------------------------------***
**                             RANGES                                 **
***------------------------------------------------------------------***


***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
DATA :
  gt_fupararef_exception TYPE ty_t_fupararef_exception. &quot;#EC NEEDED


***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***


***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***


***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***


***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
* INCLUDE LZTEC_TASK_PARALLELD...            &quot; Local class definition</include_source>
   </include>
  </includeprograms>
  <functionmodules>
   <functionmodule NAME="Z_CONVERT_TABLE_DYN_TO_STATIC" STEXT="Conversion table dynamique en statique">
    <importing PARAMETER="IT_DATA" OPTIONAL="X" REFERENCE="X" TYP="ANY TABLE"/>
    <importing PARAMETER="IOT_DATA" OPTIONAL="X" REFERENCE="X" TYP="REF TO DATA" REF_CLASS="X"/>
    <importing PARAMETER="IV_SUB_DATA_GUID" OPTIONAL="X" TYP="SYSUUID_C32"/>
    <exporting PARAMETER="ET_CONTENT_STATIC" REFERENCE="X" TYP="ZTEC_T_CONTENT_DATA"/>
    <exporting PARAMETER="ET_CONTENT_RAW" REFERENCE="X" TYP="SRM_T_BINTAB"/>
    <exporting PARAMETER="ET_CONTENT_XSTRING" REFERENCE="X" TYP="XSTRINGTAB"/>
    <documentation PARAMETER="IT_DATA" KIND="P" STEXT="Table de donnÃ©es" INDEX=" 001"/>
    <documentation PARAMETER="IOT_DATA" KIND="P" STEXT="Table de donnÃ©es (RÃ©fÃ©rence)" INDEX=" 002"/>
    <documentation PARAMETER="IV_SUB_DATA_GUID" KIND="P" STEXT="GUID Sous-Ã‰lÃ©ment" INDEX=" 003"/>
    <documentation PARAMETER="ET_CONTENT_STATIC" KIND="P" STEXT="Type de table contenu de table" INDEX=" 004"/>
    <documentation PARAMETER="ET_CONTENT_RAW" KIND="P" STEXT="Table binaire" INDEX=" 005"/>
    <documentation PARAMETER="ET_CONTENT_XSTRING" KIND="P" STEXT="Table with XStrings" INDEX=" 006"/>
    <fm_source_new>***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_content_static  TYPE ztec_t_content_data,
    lt_data_type_descr TYPE ty_t_data_type_descr.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_content_data    TYPE ztec_s_content_data,
    ls_data_type_descr TYPE ty_data_type_descr.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_elem_descr   TYPE REF TO cl_abap_elemdescr,
    lo_table_descr  TYPE REF TO cl_abap_tabledescr,
    lo_struct_descr TYPE REF TO cl_abap_structdescr.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_t_table&gt; TYPE ANY TABLE.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : et_content_xstring, et_content_static, et_content_raw.

  IF iot_data IS BOUND.
    &quot; Initialisation &quot;pointeur&quot; sur les données
    ASSIGN iot_data-&gt;* TO &lt;lfs_t_table&gt;.

  ELSEIF it_data IS SUPPLIED.
    &quot; Utilisation table passée en paramètre
    ASSIGN it_data TO &lt;lfs_t_table&gt;.

  ELSE.
    &quot; Aucun paramètre
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.
  IF NOT &lt;lfs_t_table&gt; IS ASSIGNED.
    &quot; Erreur lors de l&apos;initialisation du pointeur
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; Récupération composition de la table
  lo_table_descr ?= cl_abap_tabledescr=&gt;describe_by_data( &lt;lfs_t_table&gt; ).
  TRY.
      &quot; Récupération composition de la table
      lo_struct_descr ?= lo_table_descr-&gt;get_table_line_type( ).

    CATCH cx_sy_move_cast_error.
      &quot; Erreur move-cast // Il s&apos;agit peut-être d&apos;une table de type élémentaire
      TRY.
          lo_elem_descr ?= lo_table_descr-&gt;get_table_line_type( ).

        CATCH cx_root. &quot;#EC CATCH_ALL
          &quot; Erreur
          &quot;&quot;  --&gt; Arrêt du traitement
          RETURN.

      ENDTRY.

    CATCH cx_root. &quot;#EC CATCH_ALL
      &quot; Erreur
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

  ENDTRY.

  &quot; Parcours l&apos;ensemble des données
  LOOP AT &lt;lfs_t_table&gt; ASSIGNING FIELD-SYMBOL(&lt;lfs_s_table&gt;).

    CLEAR : ls_content_data.
    FREE : lt_content_static.

    &quot; Initialisation numéro de ligne
    ls_content_data-line = sy-tabix.

    IF iv_sub_data_guid IS SUPPLIED.
      &quot; Initialisation GUID de Sous-élément
      ls_content_data-sub_data_guid = iv_sub_data_guid.

    ENDIF.

    IF lo_elem_descr IS BOUND.
      &quot; Cas d&apos;un type de table élémentaire
      ls_content_data-fieldname = gc_table_line.
      ls_content_data-fieldtype = lo_elem_descr-&gt;absolute_name.
      ls_content_data-fieldkind = lo_elem_descr-&gt;kind.
      ls_content_data-value     = &lt;lfs_s_table&gt;.

      IF et_content_static IS SUPPLIED.
        &quot; Ajout dans la table &quot;Statique&quot; classique
        INSERT ls_content_data INTO TABLE et_content_static.

      ENDIF.

    ELSEIF lo_struct_descr IS BOUND.

      &quot; Parcours l&apos;ensemble des champs de la structure
      LOOP AT lo_struct_descr-&gt;components ASSIGNING FIELD-SYMBOL(&lt;lfs_s_components&gt;).

        &quot; Récupération du champ correspondant
        ASSIGN COMPONENT &lt;lfs_s_components&gt;-name OF STRUCTURE &lt;lfs_s_table&gt;
                                                           TO FIELD-SYMBOL(&lt;lfs_s_source&gt;).
        IF sy-subrc NE 0.
          &quot; Pas de correspondance // Ne devrais pas se produire
          &quot;&quot;  --&gt; Passe à l&apos;itération suivante
          CONTINUE.

        ENDIF.

        &quot; Initialisation Nom du champ
        ls_content_data-fieldname = &lt;lfs_s_components&gt;-name.

        &quot; Récupération de la composition du champ
        READ TABLE lt_data_type_descr WITH TABLE KEY component = &lt;lfs_s_components&gt;-name
                                           ASSIGNING FIELD-SYMBOL(&lt;lfs_s_data_type_descr&gt;).
        IF sy-subrc NE 0.
          &quot; Pas encore récupérée
          &quot;&quot;  --&gt; Création novelle entrée
          ls_data_type_descr-component   = &lt;lfs_s_components&gt;-name.
          ls_data_type_descr-data_descr ?= cl_abap_datadescr=&gt;describe_by_data( &lt;lfs_s_source&gt; ).
          INSERT ls_data_type_descr INTO TABLE lt_data_type_descr ASSIGNING &lt;lfs_s_data_type_descr&gt;.

        ENDIF.

        &quot; Initialisation Type (DDIC) du champ
        ls_content_data-fieldtype = &lt;lfs_s_data_type_descr&gt;-data_descr-&gt;absolute_name.

        &quot; Initialisation Type (ABAP) de champ
        ls_content_data-fieldkind = &lt;lfs_s_data_type_descr&gt;-data_descr-&gt;kind.

        &quot; Suivant le type de champ
        CASE &lt;lfs_s_data_type_descr&gt;-data_descr-&gt;kind.

          WHEN cl_abap_typedescr=&gt;kind_ref.
            &quot; Instance
            &quot;&quot;  --&gt; ToDo : Ajouter traitement

          WHEN cl_abap_typedescr=&gt;kind_class
            OR cl_abap_typedescr=&gt;kind_intf.
            &quot; Classe
            &quot;&quot;  --&gt; ToDo : Ajouter traitement

          WHEN cl_abap_typedescr=&gt;kind_table.
            &quot; Table
            TRY.
                &quot;&quot;  --&gt; Génération ID Unique
                ls_content_data-value = cl_system_uuid=&gt;create_uuid_c32_static( ).

              CATCH cx_uuid_error.
                &quot;&quot; --&gt; Génération nombre aléatoire
                ls_content_data-value = CONV sysuuid_c32( cl_abap_random=&gt;seed( ) ).

            ENDTRY.

            &quot;&quot;  --&gt; Appel récursif pour type &quot;complexe&quot;
            CALL FUNCTION &apos;Z_CONVERT_TABLE_DYN_TO_STATIC&apos;
              EXPORTING
                it_data           = &lt;lfs_s_source&gt;
                iv_sub_data_guid  = CONV sysuuid_c32( ls_content_data-value )
              IMPORTING
                et_content_static = lt_content_static.
            INSERT LINES OF lt_content_static INTO TABLE et_content_static.

          WHEN cl_abap_typedescr=&gt;kind_elem.
            &quot; Type élémentaire
            &quot;&quot;  --&gt; Initialisation de la valeur
            ls_content_data-value = &lt;lfs_s_source&gt;.

          WHEN cl_abap_typedescr=&gt;kind_struct.
            &quot; Structure
            TRY.
                &quot;&quot;  --&gt; Génération ID Unique
                ls_content_data-value = cl_system_uuid=&gt;create_uuid_c32_static( ).

              CATCH cx_uuid_error.
                &quot;&quot; --&gt; Génération nombre aléatoire
                ls_content_data-value = CONV sysuuid_c32( cl_abap_random=&gt;seed( ) ).

            ENDTRY.

            &quot;&quot;  --&gt; Appel récursif pour type &quot;complexe&quot;
            CALL FUNCTION &apos;Z_CONVERT_STRUCT_DYN_TO_STATIC&apos;
              EXPORTING
                is_data           = &lt;lfs_s_source&gt;
                iv_sub_data_guid  = CONV sysuuid_c32( ls_content_data-value )
              IMPORTING
                et_content_static = lt_content_static.
            INSERT LINES OF lt_content_static INTO TABLE et_content_static.

          WHEN OTHERS.
            &quot; Autre
            &quot;&quot;  --&gt; ToDo : Traiter les autres cas
            CONTINUE.

        ENDCASE.

        IF et_content_static IS SUPPLIED.
          &quot; Ajout dans la table &quot;Statique&quot; classique
          INSERT ls_content_data INTO TABLE et_content_static.

        ENDIF.

      ENDLOOP.        &quot;Fin parcours des champs de la table

    ENDIF.            &quot;Fin de test du type de table

  ENDLOOP.            &quot;Fin de parcours des données</fm_source_new>
   </functionmodule>
   <functionmodule NAME="Z_CONVERT_TABLE_STATIC_TO_DYN" STEXT="Conversion table statique en dynamique">
    <importing PARAMETER="IV_TYPE" OPTIONAL="X" TYP="CLIKE"/>
    <importing PARAMETER="IV_SUB_DATA_GUID" OPTIONAL="X" TYP="SYSUUID_C32"/>
    <importing PARAMETER="IT_CONTENT_STATIC" OPTIONAL="X" REFERENCE="X" TYP="ZTEC_T_CONTENT_DATA"/>
    <importing PARAMETER="IT_CONTENT_RAW" OPTIONAL="X" REFERENCE="X" TYP="SRM_T_BINTAB"/>
    <importing PARAMETER="IT_CONTENT_XSTRING" OPTIONAL="X" REFERENCE="X" TYP="XSTRINGTAB"/>
    <exporting PARAMETER="ET_DATA" REFERENCE="X" TYP="ANY TABLE"/>
    <exporting PARAMETER="EOT_DATA" REFERENCE="X" TYP="REF TO DATA" REF_CLASS="X"/>
    <changing PARAMETER="CT_DATA" OPTIONAL="X" REFERENCE="X" TYP="ANY TABLE"/>
    <changing PARAMETER="COT_DATA" OPTIONAL="X" REFERENCE="X" TYP="REF TO DATA" REF_CLASS="X"/>
    <documentation PARAMETER="IV_TYPE" KIND="P" STEXT="Type de table" INDEX=" 001"/>
    <documentation PARAMETER="IV_SUB_DATA_GUID" KIND="P" STEXT="GUID Sous-Ã‰lÃ©ment" INDEX=" 002"/>
    <documentation PARAMETER="IT_CONTENT_STATIC" KIND="P" STEXT="Type de table contenu de table" INDEX=" 003"/>
    <documentation PARAMETER="IT_CONTENT_RAW" KIND="P" STEXT="Table binaire" INDEX=" 004"/>
    <documentation PARAMETER="IT_CONTENT_XSTRING" KIND="P" STEXT="Table with XStrings" INDEX=" 005"/>
    <documentation PARAMETER="ET_DATA" KIND="P" INDEX=" 006"/>
    <documentation PARAMETER="EOT_DATA" KIND="P" STEXT="Table dynamique" INDEX=" 007"/>
    <documentation PARAMETER="CT_DATA" KIND="P" INDEX=" 008"/>
    <documentation PARAMETER="COT_DATA" KIND="P" INDEX=" 009"/>
    <fm_source_new>***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lot_data       TYPE REF TO data,
    los_data       TYPE REF TO data,
    lo_table_descr TYPE REF TO cl_abap_tabledescr.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_tabix TYPE sy-tabix.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_s_data&gt;           TYPE            any,
    &lt;lfs_t_data&gt;           TYPE ANY TABLE,
    &lt;lfs_sub_data&gt;         TYPE            any,
    &lt;lfs_s_content_static&gt; TYPE            ztec_s_content_data.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : eot_data, et_data.

  &quot; -----------------------------------------------------------
  &quot; Contrôle paramètre d&apos;Import
  &quot; -----------------------------------------------------------

  IF  it_content_raw     IS SUPPLIED
  AND it_content_static  IS SUPPLIED
  AND it_content_xstring IS SUPPLIED.
    &quot; Un seul paramètre doit être renseigné
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Création et Alimentation de la table de sortie
  &quot; -----------------------------------------------------------

  IF eot_data IS SUPPLIED.
    &quot; Gestion par référence
    &quot;&quot;  --&gt; Rcupération composition de la table
    lo_table_descr ?= cl_abap_typedescr=&gt;describe_by_name( iv_type ).

    &quot;&quot;  --&gt; Création de la table
    CREATE DATA eot_data TYPE (lo_table_descr-&gt;absolute_name).

    &quot;&quot;  --&gt; Initialisation pointeur sur les données de la table
    ASSIGN eot_data-&gt;* TO &lt;lfs_t_data&gt;.

  ELSEIF et_data IS SUPPLIED.
    &quot; Gestion par table de données
    &quot;&quot;  --&gt; Initialisation pointeur sur les données de la table
    ASSIGN et_data TO &lt;lfs_t_data&gt;.

    &quot;&quot;  --&gt; Rcupération composition de la table
    lo_table_descr ?= cl_abap_typedescr=&gt;describe_by_data( &lt;lfs_t_data&gt; ).

  ELSEIF cot_data IS SUPPLIED.
    &quot; Gestion par référence déjà créé
    &quot;&quot;  --&gt; Initialisation pointeur sur les données de la table
    ASSIGN cot_data-&gt;* TO &lt;lfs_t_data&gt;.

    &quot;&quot;  --&gt; Rcupération composition de la table
    lo_table_descr ?= cl_abap_typedescr=&gt;describe_by_data( &lt;lfs_t_data&gt; ).

  ELSEIF ct_data IS SUPPLIED.
    &quot; Gestion par table de données
    &quot;&quot;  --&gt; Initialisation pointeur sur les données de la table
    ASSIGN ct_data TO &lt;lfs_t_data&gt;.

    &quot;&quot;  --&gt; Rcupération composition de la table
    lo_table_descr ?= cl_abap_typedescr=&gt;describe_by_data( &lt;lfs_t_data&gt; ).

  ENDIF.

  IF it_content_static IS SUPPLIED.
    &quot; Utilisation table statique
    IF NOT iv_sub_data_guid IS INITIAL.
      &quot; GUID de Sous-Ã‰lément valorisé
      &quot;&quot;  --&gt; Récupération position première occurence
      READ TABLE it_content_static WITH KEY sub_data_guid = iv_sub_data_guid
                               TRANSPORTING NO FIELDS BINARY SEARCH.
      IF sy-subrc EQ 0.
        &quot; Première position déterminée
        &quot;&quot;  --&gt; Initialisation Index
        lv_tabix = sy-tabix.

      ELSE.
        &quot; Aucune correspondance
        &quot;&quot;  --&gt; Arrêt du traitement
        RETURN.

      ENDIF.

    ELSE.
      &quot; Il ne s&apos;agit pas d&apos;un Sous-Ã‰lément
      &quot;&quot; --&gt; Initialisation Index première entrée
      lv_tabix = 1.

    ENDIF.

    LOOP AT it_content_static ASSIGNING &lt;lfs_s_content_static&gt;
                                   FROM lv_tabix.

      IF &lt;lfs_s_content_static&gt;-sub_data_guid NE iv_sub_data_guid.
        &quot; On ne traite pas le bon sous-élement
        &quot;&quot;  --&gt; Passe à l&apos;itération suivante
        EXIT.

      ENDIF.

      AT NEW line.
        &quot; A chaque changement de ligne
        IF &lt;lfs_s_data&gt; IS ASSIGNED AND NOT &lt;lfs_s_data&gt; IS INITIAL.
          &quot;&quot;  --&gt; Ajout de la l&apos;entrée
          INSERT &lt;lfs_s_data&gt; INTO TABLE &lt;lfs_t_data&gt;.

        ENDIF.

        &quot;&quot;  --&gt; Réinitialisation des données
        CREATE DATA los_data TYPE LINE OF (lo_table_descr-&gt;absolute_name).
        ASSIGN los_data-&gt;* TO &lt;lfs_s_data&gt;.

      ENDAT.

      &quot; Initialisation pointeur sur champ de la structure
      IF &lt;lfs_s_content_static&gt;-fieldname EQ gc_table_line.
        &quot; Cas d&apos;une table de type élémentaire
        &lt;lfs_s_data&gt; = &lt;lfs_s_content_static&gt;-value.

      ELSE.
        &quot; Cas d&apos;une structure &quot;complexe&quot;
        ASSIGN COMPONENT &lt;lfs_s_content_static&gt;-fieldname OF STRUCTURE &lt;lfs_s_data&gt;
                                                                    TO FIELD-SYMBOL(&lt;lfs_value_target&gt;).
        IF sy-subrc NE 0.
          &quot; Pas de correspondance // Ce cas ne devrais pas se produire
          &quot;&quot;  --&gt; Passe à l&apos;itération suivante
          CONTINUE.

        ENDIF.

        &quot; Suivant le type de champ
        CASE &lt;lfs_s_content_static&gt;-fieldkind.

          WHEN cl_abap_typedescr=&gt;kind_ref.
            &quot; Instance
            &quot;&quot;  --&gt; ToDo : Ajouter traitement

          WHEN cl_abap_typedescr=&gt;kind_class
            OR cl_abap_typedescr=&gt;kind_intf.
            &quot; Classe
            &quot;&quot;  --&gt; ToDo : Ajouter traitement

          WHEN cl_abap_typedescr=&gt;kind_table.
            &quot; Table
            &quot;&quot;  --&gt; Appel récursif pour type &quot;complexe&quot;
            CALL FUNCTION &apos;Z_CONVERT_TABLE_STATIC_TO_DYN&apos;
              EXPORTING
                iv_type           = &lt;lfs_s_content_static&gt;-fieldtype
                iv_sub_data_guid  = CONV sysuuid_c32( &lt;lfs_s_content_static&gt;-value )
                it_content_static = it_content_static
              IMPORTING
                eot_data          = lot_data.

            &quot;&quot;  --&gt; Alimentation de la zone
            ASSIGN lot_data-&gt;* TO &lt;lfs_sub_data&gt;.
            &lt;lfs_value_target&gt; = &lt;lfs_sub_data&gt;.

          WHEN cl_abap_typedescr=&gt;kind_elem.
            &quot; Type élémentaire
            &quot;&quot;  --&gt; Initialisation de la valeur
            &lt;lfs_value_target&gt; = &lt;lfs_s_content_static&gt;-value.

          WHEN cl_abap_typedescr=&gt;kind_struct.
            &quot; Structure
            &quot;&quot;  --&gt; Appel récursif pour type &quot;complexe&quot;
            CALL FUNCTION &apos;Z_CONVERT_STRUCT_STATIC_TO_DYN&apos;
              EXPORTING
                iv_type           = &lt;lfs_s_content_static&gt;-fieldtype
                iv_sub_data_guid  = CONV sysuuid_c32( &lt;lfs_s_content_static&gt;-value )
                it_content_static = it_content_static
              IMPORTING
                eos_data          = los_data.

            &quot;&quot;  --&gt; Alimentation de la zone
            ASSIGN los_data-&gt;* TO &lt;lfs_sub_data&gt;.
            &lt;lfs_value_target&gt; = &lt;lfs_sub_data&gt;.

          WHEN OTHERS.
            &quot; Autre
            &quot;&quot;  --&gt; ToDo : Traiter les autres cas
            CONTINUE.

        ENDCASE.

      ENDIF.

    ENDLOOP.

    IF &lt;lfs_s_data&gt; IS ASSIGNED AND NOT &lt;lfs_s_data&gt; IS INITIAL.
      &quot;&quot;  --&gt; Ajout de la l&apos;entrée
      INSERT &lt;lfs_s_data&gt; INTO TABLE &lt;lfs_t_data&gt;.

    ENDIF.

  ENDIF.</fm_source_new>
   </functionmodule>
   <functionmodule NAME="Z_CONVERT_STRUCT_DYN_TO_STATIC" STEXT="Conversion structure dynamique en statique">
    <importing PARAMETER="IS_DATA" OPTIONAL="X" REFERENCE="X" TYP="ANY"/>
    <importing PARAMETER="IOS_DATA" OPTIONAL="X" REFERENCE="X" TYP="REF TO DATA" REF_CLASS="X"/>
    <importing PARAMETER="IV_SUB_DATA_GUID" OPTIONAL="X" REFERENCE="X" TYP="SYSUUID_C32"/>
    <exporting PARAMETER="ET_CONTENT_STATIC" REFERENCE="X" TYP="ZTEC_T_CONTENT_DATA"/>
    <documentation PARAMETER="IS_DATA" KIND="P" STEXT="Structure de donnÃ©es" INDEX=" 001"/>
    <documentation PARAMETER="IOS_DATA" KIND="P" STEXT="Structure de donnÃ©es (RÃ©fÃ©rence)" INDEX=" 002"/>
    <documentation PARAMETER="IV_SUB_DATA_GUID" KIND="P" STEXT="16 Byte UUID in 16 Bytes (Raw Format)" INDEX=" 003"/>
    <documentation PARAMETER="ET_CONTENT_STATIC" KIND="P" STEXT="Type de table contenu de table" INDEX=" 004"/>
    <fm_source_new>***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_content_static  TYPE ztec_t_content_data,
    lt_data_type_descr TYPE ty_t_data_type_descr.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_content_data    TYPE ztec_s_content_data,
    ls_data_type_descr TYPE ty_data_type_descr.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_elem_descr   TYPE REF TO cl_abap_elemdescr,
    lo_struct_descr TYPE REF TO cl_abap_structdescr.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_s_structure&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : et_content_static.

  &quot; -----------------------------------------------------------
  &quot; Récupération composante de la Structure
  &quot; -----------------------------------------------------------

  IF ios_data IS BOUND.
    &quot; Initialisation &quot;pointeur&quot; sur les données
    ASSIGN ios_data-&gt;* TO &lt;lfs_s_structure&gt;.

  ELSEIF is_data IS SUPPLIED.
    &quot; Utilisation structure passée en paramètre
    ASSIGN is_data TO &lt;lfs_s_structure&gt;.

  ELSE.
    &quot; Aucun paramètre
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.
  IF NOT &lt;lfs_s_structure&gt; Is ASSIGNED.
    &quot; Erreur lors de l&apos;initialisation du pointeur
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  TRY.
      &quot; Récupération composition de la structure
      lo_struct_descr ?= cl_abap_structdescr=&gt;describe_by_data( &lt;lfs_s_structure&gt; ).

    CATCH cx_sy_move_cast_error.
      &quot; Erreur move-cast // Il s&apos;agit peut-être d&apos;une table de type élémentaire
      TRY.
          lo_elem_descr ?= cl_abap_structdescr=&gt;describe_by_data( &lt;lfs_s_structure&gt; ).

        CATCH cx_root. &quot;#EC CATCH_ALL
          &quot; Erreur
          &quot;&quot;  --&gt; Arrêt du traitement
          RETURN.

      ENDTRY.

    CATCH cx_root. &quot;#EC CATCH_ALL
      &quot; Erreur
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

  ENDTRY.

  &quot; -----------------------------------------------------------
  &quot; Initialisation table de données statique
  &quot; -----------------------------------------------------------

  IF lo_elem_descr IS BOUND.
    &quot; Cas d&apos;un type de table élémentaire
    ls_content_data-fieldname = gc_table_line.
    ls_content_data-fieldtype = lo_elem_descr-&gt;absolute_name.
    ls_content_data-fieldkind = lo_elem_descr-&gt;kind.
    ls_content_data-value     = &lt;lfs_s_structure&gt;.

    IF et_content_static IS SUPPLIED.
      &quot; Ajout dans la table &quot;Statique&quot; classique
      INSERT ls_content_data INTO TABLE et_content_static.

    ENDIF.

  ELSEIF lo_struct_descr IS BOUND.

    &quot; Parcours l&apos;ensemble des champs de la structure
    LOOP AT lo_struct_descr-&gt;components ASSIGNING FIELD-SYMBOL(&lt;lfs_s_components&gt;).

      FREE : lt_content_static.

      &quot; Récupération du champ correspondant
      ASSIGN COMPONENT &lt;lfs_s_components&gt;-name OF STRUCTURE &lt;lfs_s_structure&gt;
                                                         TO FIELD-SYMBOL(&lt;lfs_s_source&gt;).
      IF sy-subrc NE 0.
        &quot; Pas de correspondance // Ne devrais pas se produire
        &quot;&quot;  --&gt; Passe à l&apos;itération suivante
        CONTINUE.

      ENDIF.

      &quot; Initialisation Nom du champ
      ls_content_data-fieldname = &lt;lfs_s_components&gt;-name.

      &quot; Récupération de la composition du champ
      READ TABLE lt_data_type_descr WITH TABLE KEY component = &lt;lfs_s_components&gt;-name
                                         ASSIGNING FIELD-SYMBOL(&lt;lfs_s_data_type_descr&gt;).
      IF sy-subrc NE 0.
        &quot; Pas encore récupérée
        &quot;&quot;  --&gt; Création novelle entrée
        ls_data_type_descr-component   = &lt;lfs_s_components&gt;-name.
        ls_data_type_descr-data_descr ?= cl_abap_datadescr=&gt;describe_by_data( &lt;lfs_s_source&gt; ).
        INSERT ls_data_type_descr INTO TABLE lt_data_type_descr ASSIGNING &lt;lfs_s_data_type_descr&gt;.

      ENDIF.

      &quot; Initialisation Type (DDIC) du champ
      ls_content_data-fieldtype = &lt;lfs_s_data_type_descr&gt;-data_descr-&gt;absolute_name.

      &quot; Initialisation Type (ABAP) de champ
      ls_content_data-fieldkind = &lt;lfs_s_data_type_descr&gt;-data_descr-&gt;kind.

      &quot; Suivant le type de champ
      CASE &lt;lfs_s_data_type_descr&gt;-data_descr-&gt;kind.

        WHEN cl_abap_typedescr=&gt;kind_ref.
          &quot; Instance
          &quot;&quot;  --&gt; ToDo : Ajouter traitement

        WHEN cl_abap_typedescr=&gt;kind_class
          OR cl_abap_typedescr=&gt;kind_intf.
          &quot; Classe
          &quot;&quot;  --&gt; ToDo : Ajouter traitement

        WHEN cl_abap_typedescr=&gt;kind_table.
          &quot; Table
          TRY.
              &quot;&quot;  --&gt; Génération ID Unique
              ls_content_data-value = cl_system_uuid=&gt;create_uuid_c32_static( ).

            CATCH cx_uuid_error.
              &quot;&quot; --&gt; Génération nombre aléatoire
              ls_content_data-value = CONV sysuuid_c32( cl_abap_random=&gt;seed( ) ).

          ENDTRY.

          &quot;&quot;  --&gt; Appel récursif pour type &quot;complexe&quot;
          CALL FUNCTION &apos;Z_CONVERT_TABLE_DYN_TO_STATIC&apos;
            EXPORTING
              it_data           = &lt;lfs_s_source&gt;
              iv_sub_data_guid  = CONV sysuuid_c32( ls_content_data-value )
            IMPORTING
              et_content_static = lt_content_static.
          INSERT LINES OF lt_content_static INTO TABLE et_content_static.

        WHEN cl_abap_typedescr=&gt;kind_elem.
          &quot; Type élémentaire
          &quot;&quot;  --&gt; Initialisation de la valeur
          ls_content_data-value = &lt;lfs_s_source&gt;.

        WHEN cl_abap_typedescr=&gt;kind_struct.
          &quot; Structure
          TRY.
              &quot;&quot;  --&gt; Génération ID Unique
              ls_content_data-value = cl_system_uuid=&gt;create_uuid_c32_static( ).

            CATCH cx_uuid_error.
              &quot;&quot; --&gt; Génération nombre aléatoire
              ls_content_data-value = CONV sysuuid_c32( cl_abap_random=&gt;seed( ) ).

          ENDTRY.

          &quot;&quot;  --&gt; Appel récursif pour type &quot;complexe&quot;
          CALL FUNCTION &apos;Z_CONVERT_STRUCT_DYN_TO_STATIC&apos;
            EXPORTING
              is_data           = &lt;lfs_s_source&gt;
              iv_sub_data_guid  = CONV sysuuid_c32( ls_content_data-value )
            IMPORTING
              et_content_static = lt_content_static.
          INSERT LINES OF lt_content_static INTO TABLE et_content_static.

        WHEN OTHERS.
          &quot; Autre
          &quot;&quot;  --&gt; ToDo : Traiter les autres cas
          CONTINUE.

      ENDCASE.

      IF et_content_static IS SUPPLIED.
        &quot; Ajout dans la table &quot;Statique&quot; classique
        INSERT ls_content_data INTO TABLE et_content_static.

      ENDIF.

    ENDLOOP.        &quot;Fin parcours des champs de la table

  ENDIF.            &quot;Fin de test du type de table</fm_source_new>
   </functionmodule>
   <functionmodule NAME="Z_CONVERT_STRUCT_STATIC_TO_DYN" STEXT="Conversion table statique en dynamique">
    <importing PARAMETER="IV_TYPE" TYP="CLIKE"/>
    <importing PARAMETER="IV_SUB_DATA_GUID" OPTIONAL="X" TYP="SYSUUID_C32"/>
    <importing PARAMETER="IT_CONTENT_STATIC" REFERENCE="X" TYP="ZTEC_T_CONTENT_DATA"/>
    <exporting PARAMETER="ES_DATA" REFERENCE="X" TYP="ANY"/>
    <exporting PARAMETER="EOS_DATA" REFERENCE="X" TYP="REF TO DATA" REF_CLASS="X"/>
    <documentation PARAMETER="IV_TYPE" KIND="P" STEXT="Type de table" INDEX=" 001"/>
    <documentation PARAMETER="IV_SUB_DATA_GUID" KIND="P" STEXT="GUID Sous-Ã‰lÃ©ment" INDEX=" 002"/>
    <documentation PARAMETER="IT_CONTENT_STATIC" KIND="P" STEXT="Type de table contenu de table" INDEX=" 003"/>
    <documentation PARAMETER="ES_DATA" KIND="P" INDEX=" 004"/>
    <documentation PARAMETER="EOS_DATA" KIND="P" STEXT="Structure dynamique" INDEX=" 005"/>
    <fm_source_new>***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    los_data        TYPE REF TO data,
    lot_data        TYPE REF TO data,
    lo_struct_descr TYPE REF TO cl_abap_structdescr.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_s_data&gt;   TYPE any,
    &lt;lfs_sub_data&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : eos_data, es_data.

  &quot; -----------------------------------------------------------
  &quot; Création et Alimentation de la table de sortie
  &quot; -----------------------------------------------------------

  &quot; Rcupération composition de la structure
  lo_struct_descr ?= cl_abap_typedescr=&gt;describe_by_name( iv_type ).

  IF eos_data IS SUPPLIED.
    &quot; Gestion par référence
    &quot;&quot;  --&gt; Création de la structure
    CREATE DATA eos_data TYPE (lo_struct_descr-&gt;absolute_name).

    &quot;&quot;  --&gt; Initialisation pointeur sur les données de la structure
    ASSIGN eos_data-&gt;* TO &lt;lfs_s_data&gt;.

  ELSE.
    &quot; Gestion &quot;simple&quot;
    &quot;&quot;  --&gt; Initialisation pointeur sur les données de la structure
    ASSIGN es_data TO &lt;lfs_s_data&gt;.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Alimentation de la structure de sortie
  &quot; -----------------------------------------------------------

  &quot; Utilisation table statique
  LOOP AT it_content_static ASSIGNING FIELD-SYMBOL(&lt;lfs_s_content_static&gt;).

    &quot; Initialisation pointeur sur champ de la structure
    IF &lt;lfs_s_content_static&gt;-fieldname EQ gc_table_line.
      &quot; Cas d&apos;une table de type élémentaire
      &lt;lfs_s_data&gt; = &lt;lfs_s_content_static&gt;-value.

    ELSE.
      &quot; Cas d&apos;une structure &quot;complexe&quot;
      ASSIGN COMPONENT &lt;lfs_s_content_static&gt;-fieldname OF STRUCTURE &lt;lfs_s_data&gt;
                                                                  TO FIELD-SYMBOL(&lt;lfs_value_target&gt;).
      IF sy-subrc NE 0.
        &quot; Pas de correspondance // Ce cas ne devrais pas se produire
        &quot;&quot;  --&gt; Passe à l&apos;itération suivante
        CONTINUE.

      ENDIF.

      &quot; Suivant le type de champ
      CASE &lt;lfs_s_content_static&gt;-fieldkind.

        WHEN cl_abap_typedescr=&gt;kind_ref.
          &quot; Instance
          &quot;&quot;  --&gt; ToDo : Ajouter traitement

        WHEN cl_abap_typedescr=&gt;kind_class
          OR cl_abap_typedescr=&gt;kind_intf.
          &quot; Classe
          &quot;&quot;  --&gt; ToDo : Ajouter traitement

        WHEN cl_abap_typedescr=&gt;kind_table.
          &quot; Table
          &quot;&quot;  --&gt; Appel récursif pour type &quot;complexe&quot;
          CALL FUNCTION &apos;Z_CONVERT_TABLE_STATIC_TO_DYN&apos;
            EXPORTING
              iv_type           = &lt;lfs_s_content_static&gt;-fieldtype
              iv_sub_data_guid  = CONV sysuuid_c32( &lt;lfs_s_content_static&gt;-value )
              it_content_static = it_content_static
            IMPORTING
              eot_data          = lot_data.

          &quot;&quot;  --&gt; Alimentation de la zone
          ASSIGN lot_data-&gt;* TO &lt;lfs_sub_data&gt;.
          &lt;lfs_value_target&gt; = &lt;lfs_sub_data&gt;.

        WHEN cl_abap_typedescr=&gt;kind_elem.
          &quot; Type élémentaire
          &quot;&quot;  --&gt; Initialisation de la valeur
          &lt;lfs_value_target&gt; = &lt;lfs_s_content_static&gt;-value.

        WHEN cl_abap_typedescr=&gt;kind_struct.
          &quot; Structure
          &quot;&quot;  --&gt; Appel récursif pour type &quot;complexe&quot;
          CALL FUNCTION &apos;Z_CONVERT_STRUCT_STATIC_TO_DYN&apos;
            EXPORTING
              iv_type           = &lt;lfs_s_content_static&gt;-fieldtype
              iv_sub_data_guid  = CONV sysuuid_c32( &lt;lfs_s_content_static&gt;-value )
              it_content_static = it_content_static
            IMPORTING
              eos_data          = los_data.

          &quot;&quot;  --&gt; Alimentation de la zone
          ASSIGN los_data-&gt;* TO &lt;lfs_sub_data&gt;.
          &lt;lfs_value_target&gt; = &lt;lfs_sub_data&gt;.

        WHEN OTHERS.
          &quot; Autre
          &quot;&quot;  --&gt; ToDo : Traiter les autres cas
          CONTINUE.

      ENDCASE.

    ENDIF.

  ENDLOOP.</fm_source_new>
   </functionmodule>
   <functionmodule NAME="Z_TASK_CALL_PROCESS" REMOTE="R" STEXT="Appel traitement //">
    <importing PARAMETER="IV_FUNCTION_NAME" TYP="RS38L_FNAM"/>
    <importing PARAMETER="IT_FUNCTION_PARAMETERS" TYP="ZTEC_T_FUNCTION_PARAMETERS"/>
    <exporting PARAMETER="ET_RESULT" TYP="ZTEC_T_FUNCTION_PARAMETERS"/>
    <exceptions EXCEPTION="DYNAMIC_CONVERT_ERROR"/>
    <documentation PARAMETER="IV_FUNCTION_NAME" KIND="P" STEXT="Nom du module fonction" INDEX=" 001"/>
    <documentation PARAMETER="IT_FUNCTION_PARAMETERS" KIND="P" STEXT="Table paramètres d&apos;appel statique" INDEX=" 002"/>
    <documentation PARAMETER="ET_RESULT" KIND="P" STEXT="Table paramètres d&apos;appel statique" INDEX=" 003"/>
    <documentation PARAMETER="DYNAMIC_CONVERT_ERROR" KIND="X" INDEX=" 004"/>
    <fm_source_new>***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_table_data TYPE ty_t_table_data,
    lt_exceptions TYPE abap_func_excpbind_tab,
    lt_parameters TYPE abap_func_parmbind_tab.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_subrc TYPE sy-subrc. &quot;#EC NEEDED

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Initialisation tables paramètres d&apos;appel Dynamique
      &quot; -----------------------------------------------------------

      &quot; Initialisation des paramètres dynamique
      PERFORM dynamic_parameters_set USING iv_function_name
                                           it_function_parameters
                                  CHANGING lt_table_data
                                           lt_parameters
                                           lt_exceptions.

    CATCH cx_root.                                       &quot;#EC CATCH_ALL
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Arrêt du traitement
      MESSAGE ID zif_task_constant=&gt;mc_message_class_id
            TYPE &apos;E&apos;                                        &quot;#EC NOTEXT
          NUMBER 006                                        &quot;#EC NOTEXT
         RAISING dynamic_convert_error.

  ENDTRY.

  IF lt_exceptions[] IS INITIAL.
    &quot; -----------------------------------------------------------
    &quot; Gestion des Exceptions // Afin d&apos;éviter toute erreur
    &quot; -----------------------------------------------------------
    PERFORM exception_table_set USING iv_function_name
                             CHANGING lt_exceptions.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Appel du MF
  &quot; -----------------------------------------------------------

  &quot; Appel du MF avec paramètres dynamique
  CALL FUNCTION iv_function_name
    PARAMETER-TABLE lt_parameters
    EXCEPTION-TABLE lt_exceptions.
  lv_subrc = sy-subrc.

  &quot; -----------------------------------------------------------
  &quot; Initialisation table de retour
  &quot; -----------------------------------------------------------

  &quot; Conserve uniquement les paramètres d&apos;Export / Changing / Table (vue du MF)
  DELETE lt_parameters WHERE kind EQ abap_func_exporting.
  IF NOT lt_parameters[] IS INITIAL.
    &quot; Initialisation table de retour
    PERFORM result_set USING lt_parameters
                             it_function_parameters
                    CHANGING et_result.

  ENDIF.</fm_source_new>
   </functionmodule>
   <functionmodule NAME="Z_TASK_TRACE_SAVE_TO_DB" REMOTE="R" STEXT="Trace Tâche - Sauvegarde dans la DB">
    <importing PARAMETER="IT_ZTASK_TRACE" TYP="ZTASK_TRACE_H_T"/>
    <importing PARAMETER="IV_COMMIT" OPTIONAL="X" TYP="FLAG"/>
    <exporting PARAMETER="EV_SUBRC" TYP="SY-SUBRC"/>
    <documentation PARAMETER="IT_ZTASK_TRACE" KIND="P" STEXT="Trace Tâche - Type de table" INDEX=" 001"/>
    <documentation PARAMETER="IV_COMMIT" KIND="P" STEXT="Commit des données ?" INDEX=" 002"/>
    <documentation PARAMETER="EV_SUBRC" KIND="P" STEXT="Zone système ABAP : code retour des instructions ABAP" INDEX=" 003"/>
    <fm_source>***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle des données
  &quot; -----------------------------------------------------------

  IF it_ztask_trace[] IS INITIAL.
    &quot; Aucune données
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Sauvegarde les Traces d&apos;exécution des Tâches
      &quot; -----------------------------------------------------------

      &quot; Modification données en DB
      MODIFY ztask_trace_h FROM TABLE it_ztask_trace.
      ev_subrc = sy-subrc.

      IF iv_commit EQ abap_true.
        &quot; Commit
        COMMIT WORK.

      ENDIF.

    CATCH cx_root. &quot;#EC CATCH_ALL
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Initialisation code retour en erreur
      ev_subrc = 4.

  ENDTRY.</fm_source>
   </functionmodule>
  </functionmodules>
 </FUGR>
 <CLAS CLSNAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_DYNAMIC_CHECK">
  <implementing CLSNAME="ZCX_TYPE_DEFINITION" REFCLSNAME="IF_T100_MESSAGE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_TYPE_DEFINITION" REFCLSNAME="CX_DYNAMIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_TASK_SHM" VERSION="1" LANGU="F" DESCRIPT="Tâche - SHM - Classe exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZTASK" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_DYNAMIC_CHECK">
  <implementing CLSNAME="ZCX_TASK_SHM" REFCLSNAME="IF_T100_MESSAGE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_TASK_SHM" REFCLSNAME="CX_DYNAMIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Manager Tâche" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZTASK" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_DYNAMIC_CHECK">
  <implementing CLSNAME="ZCX_TASK_MANAGER" REFCLSNAME="IF_T100_MESSAGE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_TASK_MANAGER" REFCLSNAME="CX_DYNAMIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_TASK_CALL" VERSION="1" LANGU="F" DESCRIPT="Tâche - Classe exception Appel" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZTASK" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_DYNAMIC_CHECK">
  <implementing CLSNAME="ZCX_TASK_CALL" REFCLSNAME="IF_T100_MESSAGE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_TASK_CALL" REFCLSNAME="CX_DYNAMIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_TASK" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZTASK" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_DYNAMIC_CHECK">
  <implementing CLSNAME="ZCX_TASK" REFCLSNAME="IF_T100_MESSAGE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_TASK" REFCLSNAME="CX_DYNAMIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" VERSION="1" LANGU="F" DESCRIPT="Définition de Type - Classe Root (Mémoire partagée)" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" CLSSHAREDMEMORY="X" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="TY_COMPONENTS_INTERN" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="9 " SRCCOLUMN2="32 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_components_intern,
      name         TYPE string,
      type         TYPE string,
      position     TYPE int4,
      subtype_guid TYPE sysuuid_c32,
    END OF   ty_components_intern
"/>
  <types CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="TY_T_COMPONENTS_INTERN" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="11 " SRCCOLUMN1="4 " SRCROW2="12 " SRCCOLUMN2="66 " TYPESRC_LENG="0 " TYPESRC="ty_t_components_intern TYPE STANDARD TABLE OF ty_components_intern
                    WITH NON-UNIQUE KEY primary_key COMPONENTS name
"/>
  <types CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="TY_TYPE_DEFINITION" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="14 " SRCCOLUMN1="4 " SRCROW2="21 " SRCCOLUMN2="30 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_type_definition,
      type                TYPE string,
      kind                TYPE abap_typecategory,
      table_kind          TYPE abap_tablekind,
      table_key           TYPE abap_table_keydescr_tab,
      t_components_intern TYPE ty_t_components_intern,
      rowkind             TYPE typekind,
    END OF   ty_type_definition
"/>
  <types CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="TY_T_TYPE_DEFINITION" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="23 " SRCCOLUMN1="4 " SRCROW2="24 " SRCCOLUMN2="76 " TYPESRC_LENG="0 " TYPESRC="ty_t_type_definition TYPE SORTED TABLE OF ty_type_definition
                                  WITH UNIQUE KEY primary_key COMPONENTS type
"/>
  <implementing CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" REFCLSNAME="IF_SHM_BUILD_INSTANCE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="MT_TYPE_DEFINITION" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_T_TYPE_DEFINITION" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CPDNAME="IF_SHM_BUILD_INSTANCE~BUILD">
   <source>METHOD if_shm_build_instance~build.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

ENDMETHOD.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_ADD" VERSION="1" LANGU="F" DESCRIPT="Ajout définition d&apos;un Type" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_ADD" SCONAME="IO_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
   <source>METHOD definition_type_add.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_TYPE_ADD                               *
*&amp; Classe          : ZCL_TYPE_DEF_AREAHANDLE_ROOT                      *
*&amp; Description     : Ajout d&apos;une définition de type                    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Création / Modification du type
  &quot; -----------------------------------------------------------

  &quot; Ajout du Type
  me-&gt;__definition_type_add( io_definition ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_DELETE" VERSION="1" LANGU="F" DESCRIPT="Suppression d&apos;un Type" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_DELETE" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_DELETE" SCONAME="EV_SUBRC" VERSION="1" LANGU="F" DESCRIPT="Zone système ABAP : code retour des instructions ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_DELETE" SCONAME="RV_EMPTY_LIST" VERSION="1" LANGU="F" DESCRIPT="Plus de Définition de Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG"/>
   <source>METHOD definition_type_delete.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_TYPE_DELETE                            *
*&amp; Classe          : ZCL_TYPE_DEF_AREAHANDLE_ROOT                      *
*&amp; Description     : Suppression d&apos;une définition de type              *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR : ev_subrc.

  &quot; -----------------------------------------------------------
  &quot; Suppression de la définition du type
  &quot; -----------------------------------------------------------

  &quot; Recherche si la définition de type existe
  READ TABLE me-&gt;mt_type_definition WITH TABLE KEY type = iv_type
                                      TRANSPORTING NO FIELDS.
  IF sy-subrc EQ 0.
    &quot; La définition du type existe
    &quot;&quot;  --&gt; Suppression du Type
    DELETE me-&gt;mt_type_definition INDEX sy-tabix.
    ev_subrc = sy-subrc.

  ENDIF.

  &quot; Retourne Liste Vide
  rv_empty_list = boolc( me-&gt;mt_type_definition[] IS INITIAL ). &quot;Vrai si plus de définition de Type

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_EXIST" VERSION="1" LANGU="F" DESCRIPT="La Défintion du Type existe ?" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_EXIST" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_EXIST" SCONAME="IO_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_EXIST" SCONAME="RV_FOUND" VERSION="1" LANGU="F" DESCRIPT="Existe ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG"/>
   <source>METHOD definition_type_exist.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_TYPE_EXIST                             *
*&amp; Classe          : ZCL_TYPE_DEF_AREAHANDLE_ROOT                      *
*&amp; Description     : Détermine si la définition de type existe déjà    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_type TYPE me-&gt;ty_type_definition-type.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Initialisation valeur à utiliser
  &quot; -----------------------------------------------------------

  IF NOT iv_type IS INITIAL.
    &quot; Utilisation du Type
    lv_type = iv_type.

  ELSEIF io_definition IS BOUND.
    &quot; Utiliasation instance
    lv_type = io_definition-&gt;absolute_name.

  ELSE.
    &quot; Aucun paramètre
    &quot;&quot;  --&gt; On retourne Type trouvé.
    rv_found = abap_true.
    RETURN.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Initialisation valeur à utiliser
      &quot; -----------------------------------------------------------

      &quot; Recherche si la définition de type existe
      rv_found = boolc( line_exists( me-&gt;mt_type_definition[ type = lv_type ] ) ). &quot;Vrai si Définition Type existe

    CATCH cx_sy_itab_line_not_found.
      &quot; Le Type n&apos;existe pas
      &quot;&quot;  --&gt; Réinitialisation indicateur
      CLEAR : rv_found.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_GET" VERSION="1" LANGU="F" DESCRIPT="Récupération définition d&apos;un Type" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_GET" SCONAME="IV_TYPE" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_GET" SCONAME="RO_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
   <source>METHOD definition_type_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_TYPE_GET                               *
*&amp; Classe          : ZCL_TYPE_DEF_AREAHANDLE_ROOT                      *
*&amp; Description     : Récupération d&apos;une définition de type             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération définition du Type
  &quot; -----------------------------------------------------------

  &quot; Récupération du Type
  ro_definition = me-&gt;__definition_type_get( iv_type ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_ADD" VERSION="1" LANGU="F" DESCRIPT="Internal use - Ajout définition Type" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_ADD" SCONAME="IO_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_ADD" SCONAME="IV_SUBTYPE_GUID" VERSION="1" LANGU="F" DESCRIPT="GUID Sous-Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYSUUID_C32" PAROPTIONL="X"/>
   <source>METHOD __definition_type_add.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __DEFINITION_TYPE_ADD                             *
*&amp; Classe          : ZCL_TYPE_DEF_AREAHANDLE_ROOT                      *
*&amp; Description     : Usage Interne - Ajout d&apos;une définition de type    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_abap_elemdescr   TYPE REF TO cl_abap_elemdescr,
    lo_abap_datadescr   TYPE REF TO cl_abap_datadescr,
    lo_abap_tabledescr  TYPE REF TO cl_abap_tabledescr,
    lo_abap_structdescr TYPE REF TO cl_abap_structdescr.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_type_definition   TYPE zcl_type_def_areahandle_root=&gt;ty_type_definition,
    ls_components_intern TYPE zcl_type_def_areahandle_root=&gt;ty_components_intern.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_type TYPE string.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Pré-Traitement
  &quot; -----------------------------------------------------------

  IF NOT iv_subtype_guid IS INITIAL.
    &quot; Cas d&apos;un sous-élèment
    &quot;&quot;  --&gt; Initialisation Type à la valeur du GUID transmis
    lv_type = iv_subtype_guid.

  ELSE.
    &quot;Cas d&apos;un élèment &quot;classique&quot;
    &quot;&quot;  --&gt; Initialisation Type au nom du Type
    lv_type = io_definition-&gt;absolute_name.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Création / Modification du type
  &quot; -----------------------------------------------------------

  &quot; Récupération de la définition du Type existante
  READ TABLE me-&gt;mt_type_definition WITH TABLE KEY type = lv_type
                                         ASSIGNING FIELD-SYMBOL(&lt;lfs_s_type_definition&gt;).
  IF sy-subrc NE 0.
    &quot; Le Type n&apos;existe pas
    &quot;&quot;  --&gt; Création d&apos;une nouvelle entrée
    ls_type_definition-type = lv_type.
    ls_type_definition-kind = io_definition-&gt;kind.
    INSERT ls_type_definition INTO TABLE me-&gt;mt_type_definition ASSIGNING &lt;lfs_s_type_definition&gt;.

  ENDIF.

  &quot; Suivant le type de données
  IF io_definition-&gt;kind EQ cl_abap_typedescr=&gt;kind_elem.
    &quot; Elementaire
    lo_abap_datadescr ?= io_definition.

  ELSEIF io_definition-&gt;kind EQ cl_abap_typedescr=&gt;kind_table
      OR io_definition-&gt;kind EQ cl_abap_typedescr=&gt;kind_struct.
    &quot; Table ou Structure
    IF io_definition-&gt;kind EQ cl_abap_typedescr=&gt;kind_table.
      &quot; Table
      &quot;&quot;  --&gt; Move-Cast dans le bon type
      lo_abap_tabledescr ?= io_definition.

      &quot;&quot;  --&gt; Initialisation type de table
      &lt;lfs_s_type_definition&gt;-table_kind = lo_abap_tabledescr-&gt;table_kind.

      &quot;&quot;  --&gt; Récupération des Clefs
      &lt;lfs_s_type_definition&gt;-table_key = lo_abap_tabledescr-&gt;get_keys( ).

      TRY.
          &quot;&quot;  --&gt; Récupération structure utilisé
          lo_abap_structdescr ?= lo_abap_tabledescr-&gt;get_table_line_type( ).

        CATCH cx_sy_move_cast_error.
          &quot; Type de table de données Elémentaire
          TRY.
              &quot;&quot;  --&gt; Récupération description
              lo_abap_elemdescr ?= lo_abap_tabledescr-&gt;get_table_line_type( ).

              &quot;&quot;  --&gt; Initialisation indicateur table de données Elémentaire
              &lt;lfs_s_type_definition&gt;-rowkind = lo_abap_elemdescr-&gt;kind.

              &quot;&quot;  --&gt; Ajout de l&apos;entrée
              ls_components_intern-name     = &apos;TABLE_LINE&apos;. &quot;#EC NOTEXT
              ls_components_intern-position = 1.
              ls_components_intern-type     = lo_abap_elemdescr-&gt;absolute_name.
              APPEND ls_components_intern TO &lt;lfs_s_type_definition&gt;-t_components_intern.

              &quot;&quot;  --&gt; Arrêt du traitement
              RETURN.

            CATCH cx_root.
              &quot; Autre cas
              &quot;&quot;  --&gt; Non géré // Arrêt du traitement
              RETURN.

          ENDTRY.

      ENDTRY.

    ELSE.
      &quot; Structure
      lo_abap_structdescr ?= io_definition.

    ENDIF.

    &quot; Récupération des champs
    LOOP AT lo_abap_structdescr-&gt;get_components( ) ASSIGNING FIELD-SYMBOL(&lt;lfs_s_components&gt;).

      CLEAR : ls_components_intern.

      &quot; Initialisation des données
      ls_components_intern-type     = &lt;lfs_s_components&gt;-type-&gt;absolute_name.
      ls_components_intern-name     = &lt;lfs_s_components&gt;-name.
      ls_components_intern-position = sy-tabix.

      IF &lt;lfs_s_components&gt;-type-&gt;is_ddic_type( ) EQ abap_false.
        &quot; Encore un type non DDIC
        TRY.
            &quot;&quot;  --&gt; Génération ID Unique
            ls_components_intern-subtype_guid = cl_system_uuid=&gt;create_uuid_c32_static( ).

          CATCH cx_uuid_error.
            &quot; Erreur génération GUID
            &quot;&quot;  --&gt; Génération ID aléatoire
            ls_components_intern-subtype_guid = cl_abap_random=&gt;seed( ).

        ENDTRY.

        &quot;&quot;  --&gt; Appel récursif pour stockage définition du type
        me-&gt;__definition_type_add(
          io_definition   = &lt;lfs_s_components&gt;-type
          iv_subtype_guid = ls_components_intern-subtype_guid
        ).

      ENDIF.

      &quot; Ajout de l&apos;entrée
      APPEND ls_components_intern TO &lt;lfs_s_type_definition&gt;-t_components_intern.

    ENDLOOP.

    &quot; Tri dans le doute ...
    SORT &lt;lfs_s_type_definition&gt;-t_components_intern BY position.

  ELSE.
    &quot; Autre
    &quot;&quot;  --&gt; Non géré
    RETURN.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_GET" VERSION="1" LANGU="F" DESCRIPT="Internal use - Récupération définition Type" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_GET" SCONAME="IV_TYPE" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_GET" SCONAME="RO_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
   <source>METHOD __definition_type_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __DEFINITION_TYPE_GET                             *
*&amp; Classe          : ZCL_TYPE_DEF_AREAHANDLE_ROOT                      *
*&amp; Description     : Usage Interne - Récupération définition de type   *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_key        TYPE abap_keydescr_tab,
    lt_components TYPE cl_abap_structdescr=&gt;component_table.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_key        TYPE         abap_keydescr,
    ls_components TYPE LINE OF cl_abap_structdescr=&gt;component_table.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_table            TYPE REF TO data,
    lo_cx_exception     TYPE REF TO cx_root,
    lo_abap_elemdescr   TYPE REF TO cl_abap_elemdescr,
    lo_abap_datadescr   TYPE REF TO cl_abap_datadescr,
    lo_abap_tabledescr  TYPE REF TO cl_abap_tabledescr,
    lo_abap_structdescr TYPE REF TO cl_abap_structdescr.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
        lv_elemen_type TYPE string.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_s_table_key&gt; TYPE abap_table_keydescr.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération de la définition du Type
  &quot; -----------------------------------------------------------

  &quot; Récupération de la définition du type
  READ TABLE me-&gt;mt_type_definition WITH TABLE KEY type = iv_type
                                         ASSIGNING FIELD-SYMBOL(&lt;lfs_s_type_definition&gt;).
  IF sy-subrc NE 0.
    &quot; Aucune correspondance
    &quot;&quot;  --&gt; Arrêt du traitment
    RETURN.

  ENDIF.

  IF &lt;lfs_s_type_definition&gt;-kind EQ cl_abap_typedescr=&gt;kind_elem.
    &quot; Elementaire
    ro_definition = cl_abap_typedescr=&gt;describe_by_name( p_name = iv_type ).

  ELSEIF &lt;lfs_s_type_definition&gt;-kind EQ cl_abap_typedescr=&gt;kind_table
      OR &lt;lfs_s_type_definition&gt;-kind EQ cl_abap_typedescr=&gt;kind_struct.
    &quot; Table ou Structure

    TRY.
        IF NOT &lt;lfs_s_type_definition&gt;-rowkind IS INITIAL.
          &quot; Table de données &quot;spéciale&quot;
          &quot;&quot;  --&gt; Suivant le type de ligne
          CASE &lt;lfs_s_type_definition&gt;-rowkind.

            WHEN &apos;E&apos;.                                       &quot;#EC NOTEXT
              &quot;Elémentaire
              &quot;&quot;  --&gt; Récupération définition élèment
              lo_abap_elemdescr ?= cl_abap_elemdescr=&gt;describe_by_name( &lt;lfs_s_type_definition&gt;-t_components_intern[ 1 ]-type ).

              &quot;&quot;  --&gt; Création de la table suivant type de table
              CASE &lt;lfs_s_type_definition&gt;-table_kind.

                WHEN cl_abap_tabledescr=&gt;tablekind_std
                  OR cl_abap_tabledescr=&gt;tablekind_any.
                  &quot; Table de type standard
                  CREATE DATA lo_table TYPE STANDARD TABLE OF (lo_abap_elemdescr-&gt;absolute_name).

                WHEN cl_abap_tabledescr=&gt;tablekind_hashed.
                  &quot; Table hashée
                  CREATE DATA lo_table TYPE HASHED TABLE OF (lo_abap_elemdescr-&gt;absolute_name) WITH UNIQUE KEY table_line.

                WHEN cl_abap_tabledescr=&gt;tablekind_index
                  OR cl_abap_tabledescr=&gt;tablekind_sorted.
                  &quot; Table de type triée
                  CREATE DATA lo_table TYPE SORTED TABLE OF (lo_abap_elemdescr-&gt;absolute_name) WITH UNIQUE KEY table_line.

                WHEN OTHERS.
                  &quot; Autres

              ENDCASE.

            WHEN OTHERS.
              &quot; Autre

          ENDCASE.

          IF lo_table IS BOUND.
            &quot; Retourne définition du type
            ro_definition = cl_abap_typedescr=&gt;describe_by_data_ref( lo_table ).

          ENDIF.

        ELSE.
          &quot; Table de données structurées
          &quot;&quot;  --&gt; Préparation de la structure
          LOOP AT &lt;lfs_s_type_definition&gt;-t_components_intern ASSIGNING FIELD-SYMBOL(&lt;lfs_s_components_intern&gt;).

            CLEAR : ls_components.

            &quot; Initialisation des données
            ls_components-name = &lt;lfs_s_components_intern&gt;-name.
            ls_components-type ?= cl_abap_datadescr=&gt;describe_by_name( &lt;lfs_s_components_intern&gt;-type ).

            &quot; Ajout de l&apos;entrée
            APPEND ls_components TO lt_components.

          ENDLOOP.

          &quot;&quot;  --&gt; Création de la structure
          lo_abap_structdescr = cl_abap_structdescr=&gt;create( p_components = lt_components ).

          IF &lt;lfs_s_type_definition&gt;-kind EQ cl_abap_typedescr=&gt;kind_table.
            &quot; Table
            &quot;&quot;  --&gt; Conversion dans le type attendu
            lo_abap_datadescr ?= lo_abap_structdescr.

            TRY.
                IF lines( &lt;lfs_s_type_definition&gt;-table_key ) EQ 1.
                  &quot; Une seule clef
                  READ TABLE &lt;lfs_s_type_definition&gt;-table_key INDEX 1 ASSIGNING &lt;lfs_s_table_key&gt;.
                  APPEND &lt;lfs_s_table_key&gt;-name TO lt_key.

                  &quot;&quot;  --&gt; Création du type de table
                  lo_abap_tabledescr = cl_abap_tabledescr=&gt;create(
                    p_line_type  = lo_abap_datadescr
                    p_table_kind = &lt;lfs_s_type_definition&gt;-table_kind
                    p_unique     = &lt;lfs_s_table_key&gt;-is_unique
                    p_key        = lt_key
                    p_key_kind   = &lt;lfs_s_table_key&gt;-key_kind
                  ).

                ELSE.
                  &quot; Plusieurs Clefs
                  &quot;&quot;  --&gt; Création du type de table avec plusieurs avec Clefs
                  lo_abap_tabledescr = cl_abap_tabledescr=&gt;create_with_keys(
                    p_line_type    = lo_abap_datadescr
                    p_keys         = &lt;lfs_s_type_definition&gt;-table_key
                 ).

                ENDIF.

              CATCH cx_root.
                &quot; Erreur lors de la création de la table avec les Clefs spécifié
                &quot;&quot;  --&gt; Création de la table sans Clefs
                lo_abap_tabledescr = cl_abap_tabledescr=&gt;create(
                  p_line_type  = lo_abap_datadescr
                  p_table_kind = &lt;lfs_s_type_definition&gt;-table_kind
                ).

            ENDTRY.

            &quot;&quot;  --&gt; Retourne la définition du type
            ro_definition ?= lo_abap_tabledescr.

          ELSE.
            &quot; Structure
            &quot;&quot;  --&gt; Retourne la définition du type
            ro_definition ?= lo_abap_structdescr.

          ENDIF.

        ENDIF.

      CATCH cx_root INTO lo_cx_exception.
        &quot; Erreur lors de la création de la structure
        &quot;&quot;  --&gt; Arrêt du traitement
        WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
        RAISE EXCEPTION lo_cx_exception.

    ENDTRY.

  ELSE.
    &quot; Autre
    &quot;&quot;  --&gt; Non géré
    RETURN.

  ENDIF.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" VERSION="1" LANGU="F" DESCRIPT="Définition de type - SHM" CATEGORY="45" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" RSTAT="S" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CL_SHM_AREA">
  <friends CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" REFCLSNAME="CL_SHM_AREA" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros></localMacros>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="AREA_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of an Area Class" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="&apos;ZCL_TYPE_DEF_AREAHANDLE_AREA&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SHM_AREA_NAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ROOT" VERSION="1" LANGU="F" DESCRIPT="SHM: Model of a Data Class" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_TYPE_DEF_AREAHANDLE_ROOT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="_CLIENT_DEPENDENT" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="5 " ATTDECLTYP="2" ATTVALUE="ABAP_FALSE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="_LIFE_CONTEXT" VERSION="1" LANGU="F" DESCRIPT="Lifetime of an Area (Constants in CL_SHM_AREA)" EXPOSURE="0" STATE="1" EDITORDER="6 " ATTDECLTYP="2" ATTVALUE="CL_SHM_AREA=&gt;LIFE_CONTEXT_APPSERVER" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SHM_LIFE_CONTEXT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="_TRACE_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="(Internal) Flag: Trace Active?" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="1" ATTVALUE="ABAP_FALSE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="_TRACE_SERVICE" VERSION="1" LANGU="F" DESCRIPT="(Internal) Reference to Trace Class" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="3" TYPE="IF_SHM_TRACE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="_TRANSACTIONAL" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="2" ATTVALUE="ABAP_FALSE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="_VERSION_" VERSION="1" LANGU="F" DESCRIPT="(internal)" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="22" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" REFCLSNAME="CL_SHM_AREA" VERSION="1" STATE="1">
   <redefinition CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" REFCLSNAME="CL_SHM_AREA" VERSION="1" MTDNAME="GET_ROOT" EXPOSURE="0"/>
  </inheritance>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" VERSION="1" LANGU="F" DESCRIPT="Request a Read Lock" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="HANDLE" VERSION="1" LANGU="F" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TYPE_DEF_AREAHANDLE_AREA"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_INCONSISTENT" VERSION="1" LANGU="F" DESCRIPT="Different Definitions Between Program and Area" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_NO_ACTIVE_VERSION" VERSION="1" LANGU="F" DESCRIPT="No active version exists for an attach" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_READ_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Request for a Second Read Lock" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="5 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="A Change Lock Is Already Active" MTDTYPE="0" EDITORDER="6 "/>
   <source>method ATTACH_FOR_READ.

  DATA:
    l_attributes       TYPE shma_attributes,
    l_root             TYPE REF TO object,
    l_cx               TYPE REF TO cx_root,
    l_client           TYPE shm_client,
    l_client_supplied  TYPE abap_bool. &quot;#EC NEEDED

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.


  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_read = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

*   try sneak mode first
    handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                      sneak_mode   = abap_true
                                      life_context = _life_context
                            IMPORTING root         = l_root ).

    IF l_root IS INITIAL.
*     no root object returned, sneak mode was not successful.
*     -&gt; read area properties from database and try again.
      cl_shm_service=&gt;initialize(
        EXPORTING area_name       = handle-&gt;area_name
                  client          = l_client
        IMPORTING attributes      = l_attributes
      ).

      handle-&gt;properties = l_attributes-properties.
      handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                        sneak_mode   = abap_false
                                        life_context = _life_context
                              IMPORTING root         = l_root ).

    ENDIF.

    handle-&gt;root ?= l_root.
*   &lt;

  ELSE.

    TRY.

*       &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                          sneak_mode   = abap_true
                                          life_context = _life_context
                                IMPORTING root         = l_root ).

        IF l_root IS INITIAL.
*         no root object returned, sneak mode was not successful.
*         -&gt; read area properties from database and try again.
          cl_shm_service=&gt;initialize(
            EXPORTING area_name       = handle-&gt;area_name
                      client          = l_client
            IMPORTING attributes      = l_attributes
          ).

          handle-&gt;properties = l_attributes-properties.
          handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                            sneak_mode   = abap_false
                                            life_context = _life_context
                                  IMPORTING root         = l_root ).

        ENDIF.
        handle-&gt;root ?= l_root.

*       &lt;
        _trace_service-&gt;trin_attach_for_read(
          area_name = area_name
          inst_name = inst_name
          client    = l_client ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_read(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" VERSION="1" LANGU="F" DESCRIPT="Request a Change Lock" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="ATTACH_MODE" VERSION="1" LANGU="F" DESCRIPT="Mode of ATTACH (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_ATTACH_MODE" PARVALUE="CL_SHM_AREA=&gt;ATTACH_MODE_DEFAULT"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="WAIT_TIME" VERSION="1" LANGU="F" DESCRIPT="Maximum Wait Time (in Milliseconds)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="0"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="HANDLE" VERSION="1" LANGU="F" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TYPE_DEF_AREAHANDLE_AREA"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_INCONSISTENT" VERSION="1" LANGU="F" DESCRIPT="Different Definitions Between Program and Area" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_NO_ACTIVE_VERSION" VERSION="1" LANGU="F" DESCRIPT="No active version exists for an attach" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_VERSION_LIMIT_EXCEEDED" VERSION="1" LANGU="F" DESCRIPT="No Additional Versions Available" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="A write lock is already active" MTDTYPE="0" EDITORDER="5 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Passed Parameter Has Incorrect Value" MTDTYPE="0" EDITORDER="6 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_PENDING_LOCK_REMOVED" VERSION="1" LANGU="F" DESCRIPT="Shared Objects: Waiting Lock Was Deleted" MTDTYPE="0" EDITORDER="7 "/>
   <source>method ATTACH_FOR_UPDATE.

  DATA:
    l_attributes             TYPE shma_attributes,
    l_root                   TYPE REF TO object,
    l_cx                     TYPE REF TO cx_root,
    l_client                 TYPE shm_client,
    l_client_supplied        TYPE abap_bool, &quot;#EC NEEDED
    l_wait_time              TYPE i,
    l_wait_time_per_loop     TYPE i,
    l_wait_time_per_loop_sec TYPE f.

  l_wait_time = wait_time.

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.


  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_upd = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

    cl_shm_service=&gt;initialize(
      EXPORTING area_name    = handle-&gt;area_name
                client       = l_client
      IMPORTING attributes   = l_attributes
    ).

    handle-&gt;properties = l_attributes-properties.

    handle-&gt;_attach_update70(
      EXPORTING area_name = handle-&gt;area_name
                mode      = attach_mode
      IMPORTING root      = l_root
      CHANGING  wait_time = l_wait_time ).

    IF abap_true = l_attributes-properties-has_versions AND
       handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
      handle-&gt;_attach_update70(
        EXPORTING area_name = handle-&gt;area_name
                  mode      = attach_mode
        IMPORTING root      = l_root
        CHANGING  wait_time = l_wait_time ).
    ENDIF.

    IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
       handle-&gt;_lock IS INITIAL.

      l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
      IF l_wait_time_per_loop &lt; 2000.
        l_wait_time_per_loop = 2000.
      ELSEIF l_wait_time_per_loop &gt; 300000.
        l_wait_time_per_loop = 300000.
      ENDIF.

      l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

      WHILE handle-&gt;_lock IS INITIAL.

        IF l_wait_time_per_loop &gt; l_wait_time.
          l_wait_time_per_loop = l_wait_time.
          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
        ENDIF.

        WAIT UP TO l_wait_time_per_loop_sec SECONDS.
        l_wait_time = l_wait_time - l_wait_time_per_loop.

        handle-&gt;_attach_update70(
          EXPORTING area_name = handle-&gt;area_name
                    mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
          IMPORTING root      = l_root
          CHANGING  wait_time = l_wait_time ).

        IF abap_true = l_attributes-properties-has_versions AND
           handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
          handle-&gt;_attach_update70(
            EXPORTING area_name = handle-&gt;area_name
                      mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
            IMPORTING root      = l_root
            CHANGING  wait_time = l_wait_time ).
        ENDIF.

      ENDWHILE.

    ENDIF.

    handle-&gt;root ?= l_root.

*   &lt;

  ELSE.

    TRY.

*       &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        cl_shm_service=&gt;initialize(
          EXPORTING area_name    = handle-&gt;area_name
                    client       = l_client
          IMPORTING attributes   = l_attributes
        ).

        handle-&gt;properties = l_attributes-properties.

        handle-&gt;_attach_update70(
          EXPORTING area_name = handle-&gt;area_name
                    mode      = attach_mode
          IMPORTING root      = l_root
          CHANGING  wait_time = l_wait_time ).

        IF abap_true = l_attributes-properties-has_versions AND
           handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
          handle-&gt;_attach_update70(
            EXPORTING area_name = handle-&gt;area_name
                      mode      = attach_mode
            IMPORTING root      = l_root
            CHANGING  wait_time = l_wait_time ).
        ENDIF.

        IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
           handle-&gt;_lock IS INITIAL.

          l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
          IF l_wait_time_per_loop &lt; 2000.
            l_wait_time_per_loop = 2000.
          ELSEIF l_wait_time_per_loop &gt; 300000.
            l_wait_time_per_loop = 300000.
          ENDIF.

          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

          WHILE handle-&gt;_lock IS INITIAL.

            IF l_wait_time_per_loop &gt; l_wait_time.
              l_wait_time_per_loop = l_wait_time.
              l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
            ENDIF.

            WAIT UP TO l_wait_time_per_loop_sec SECONDS.
            l_wait_time = l_wait_time - l_wait_time_per_loop.

            handle-&gt;_attach_update70(
              EXPORTING
                area_name = handle-&gt;area_name
                mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
              IMPORTING
                root      = l_root
              CHANGING
                wait_time = l_wait_time ).

            IF abap_true = l_attributes-properties-has_versions AND
               handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
              handle-&gt;_attach_update70(
                EXPORTING
                  area_name = handle-&gt;area_name
                  mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
                IMPORTING
                  root      = l_root
                CHANGING
                  wait_time = l_wait_time ).
            ENDIF.

          ENDWHILE.

        ENDIF.

        handle-&gt;root ?= l_root.

*       &lt;
        _trace_service-&gt;trin_attach_for_update(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_update(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" VERSION="1" LANGU="F" DESCRIPT="Request a Write Lock" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="ATTACH_MODE" VERSION="1" LANGU="F" DESCRIPT="Mode of ATTACH (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_ATTACH_MODE" PARVALUE="CL_SHM_AREA=&gt;ATTACH_MODE_DEFAULT"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="WAIT_TIME" VERSION="1" LANGU="F" DESCRIPT="Maximum Wait Time (in Milliseconds)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="0"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="HANDLE" VERSION="1" LANGU="F" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TYPE_DEF_AREAHANDLE_AREA"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_VERSION_LIMIT_EXCEEDED" VERSION="1" LANGU="F" DESCRIPT="No Additional Versions Available" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="A write lock is already active" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Passed Parameter Has Incorrect Value" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_PENDING_LOCK_REMOVED" VERSION="1" LANGU="F" DESCRIPT="Shared Objects: Waiting Lock Was Deleted" MTDTYPE="0" EDITORDER="5 "/>
   <source>method ATTACH_FOR_WRITE.

  DATA:
    l_attributes             TYPE shma_attributes,
    l_cx                     TYPE REF TO cx_root,
    l_client                 TYPE shm_client,
    l_client_supplied        TYPE abap_bool, &quot;#EC NEEDED
    l_wait_time              TYPE i,
    l_wait_time_per_loop     TYPE i,
    l_wait_time_per_loop_sec TYPE f.

  l_wait_time = wait_time.

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.


  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_write = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

    cl_shm_service=&gt;initialize(
      EXPORTING area_name    = handle-&gt;area_name
                client       = l_client
      IMPORTING attributes   = l_attributes
    ).

    handle-&gt;properties = l_attributes-properties.

    handle-&gt;_attach_write70(
      EXPORTING
        area_name = handle-&gt;area_name
        mode      = attach_mode
      CHANGING
        wait_time = l_wait_time ).

    IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
       handle-&gt;_lock IS INITIAL.

      l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
      IF l_wait_time_per_loop &lt; 2000.
        l_wait_time_per_loop = 2000.
      ELSEIF l_wait_time_per_loop &gt; 300000.
        l_wait_time_per_loop = 300000.
      ENDIF.

      l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

      WHILE handle-&gt;_lock IS INITIAL.

        IF l_wait_time_per_loop &gt; l_wait_time.
          l_wait_time_per_loop = l_wait_time.
          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
        ENDIF.

        WAIT UP TO l_wait_time_per_loop_sec SECONDS.
        l_wait_time = l_wait_time - l_wait_time_per_loop.

        handle-&gt;_attach_write70(
          EXPORTING
            area_name = handle-&gt;area_name
            mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
          CHANGING
            wait_time = l_wait_time ).

      ENDWHILE.

    ENDIF.

*   &lt;

  ELSE.

    TRY.

*     &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        cl_shm_service=&gt;initialize(
          EXPORTING area_name    = handle-&gt;area_name
                    client       = l_client
          IMPORTING attributes   = l_attributes
        ).

        handle-&gt;properties = l_attributes-properties.

        handle-&gt;_attach_write70(
          EXPORTING
            area_name = handle-&gt;area_name
            mode      = attach_mode
          CHANGING
            wait_time = l_wait_time ).

        IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
           handle-&gt;_lock IS INITIAL.

          l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
          IF l_wait_time_per_loop &lt; 2000.
            l_wait_time_per_loop = 2000.
          ELSEIF l_wait_time_per_loop &gt; 300000.
            l_wait_time_per_loop = 300000.
          ENDIF.

          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

          WHILE handle-&gt;_lock IS INITIAL.

            IF l_wait_time_per_loop &gt; l_wait_time.
              l_wait_time_per_loop = l_wait_time.
              l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
            ENDIF.

            WAIT UP TO l_wait_time_per_loop_sec SECONDS.
            l_wait_time = l_wait_time - l_wait_time_per_loop.

            handle-&gt;_attach_write70(
              EXPORTING
                area_name = handle-&gt;area_name
                mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
              CHANGING
                wait_time = l_wait_time ).

          ENDWHILE.

        ENDIF.

*     &lt;

        _trace_service-&gt;trin_attach_for_write(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
        ).
      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_write(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="BUILD" VERSION="1" LANGU="F" DESCRIPT="Direct Call of Area Constructor" EXPOSURE="2" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="BUILD" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="BUILD" SCONAME="CX_SHMA_NOT_CONFIGURED" VERSION="1" LANGU="F" DESCRIPT="SHM Administration: Area Property Is Not Configured" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="BUILD" SCONAME="CX_SHMA_INCONSISTENT" VERSION="1" LANGU="F" DESCRIPT="SHM Administration: Inconsistent Attribute Combination" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="BUILD" SCONAME="CX_SHM_BUILD_FAILED" VERSION="1" LANGU="F" DESCRIPT="Constructor Run Failed" MTDTYPE="0" EDITORDER="3 "/>
   <source>method BUILD.

  DATA:
    l_cls_name TYPE shm_auto_build_class_name,
    l_cx TYPE REF TO cx_root.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-build = abap_false.

*   &gt;
    l_cls_name =
      cl_shm_service=&gt;get_auto_build_class_name( area_name ).

    CALL METHOD (l_cls_name)=&gt;if_shm_build_instance~build
      EXPORTING
        inst_name = inst_name.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        l_cls_name =
          cl_shm_service=&gt;get_auto_build_class_name( area_name ).

        CALL METHOD (l_cls_name)=&gt;if_shm_build_instance~build
          EXPORTING
            inst_name = inst_name.
*       &lt;
        _trace_service-&gt;trin_build(
          area_name         = area_name
          inst_name         = inst_name
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_build(
          area_name         = area_name
          inst_name         = inst_name
          cx                = l_cx
        ).
    ENDTRY.

  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="CLASS_CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CLASS_CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <source>method CLASS_CONSTRUCTOR.

* TRACE { DO NOT REMOVE THIS LINE !
  _trace_active = abap_false.
  TRY.
      _trace_service =
        cl_shm_service=&gt;trace_get_service( area_name ).
      IF NOT _trace_service IS INITIAL.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      ENDIF.
    CATCH cx_root. &quot;#EC NO_HANDLER
                   &quot;#EC CATCH_ALL
  ENDTRY.
* TRACE } DO NOT REMOVE THIS LINE !

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="DETACH_AREA" VERSION="1" LANGU="F" DESCRIPT="Release all locks on all instances" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="DETACH_AREA" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <source>method DETACH_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.


* &gt;
  rc = _detach_area71( area_name        = area_name
                       client           = l_client
                       client_supplied  = l_client_supplied
                       client_dependent = _client_dependent
                       life_context     = _life_context
       ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-detach_area = abap_true.
      _trace_service-&gt;trin_detach_area(
        area_name = area_name
        client    = l_client
        rc        = rc
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_AREA" VERSION="1" LANGU="F" DESCRIPT="Delete all instances" EXPOSURE="2" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_AREA" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="F" DESCRIPT="Writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_AREA" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_AREA" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method FREE_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.


* &gt;
  rc = _free_area71( area_name         = area_name
                     client            = l_client
                     client_supplied   = l_client_supplied
                     client_dependent  = _client_dependent
                     transactional     = _transactional
                     terminate_changer = terminate_changer
                     affect_server     = affect_server
                     life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-free_area = abap_true.
      _trace_service-&gt;trin_free_area(
      area_name         = area_name
      client            = l_client
      terminate_changer = terminate_changer
      affect_server     = affect_server
      rc                = rc
    ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="Deletion of an Instance" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_INSTANCE" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_INSTANCE" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="F" DESCRIPT="Writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_INSTANCE" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_INSTANCE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method FREE_INSTANCE.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.


* &gt;
  rc = _free_instance71( area_name         = area_name
                         inst_name         = inst_name
                         client            = l_client
                         client_supplied   = l_client_supplied
                         client_dependent  = _client_dependent
                         transactional     = _transactional
                         terminate_changer = terminate_changer
                         affect_server     = affect_server
                         life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-free_instance = abap_true.
      _trace_service-&gt;trin_free_instance(
        area_name         = area_name
        inst_name         = inst_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="GET_GENERATOR_VERSION" VERSION="1" LANGU="F" DESCRIPT="Query Generator Version" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="GET_GENERATOR_VERSION" SCONAME="GENERATOR_VERSION" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
   <source>method GET_GENERATOR_VERSION.
  generator_version = _version_.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="GET_INSTANCE_INFOS" VERSION="1" LANGU="F" DESCRIPT="Returns the names of all instances" EXPOSURE="2" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="GET_INSTANCE_INFOS" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance in an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="GET_INSTANCE_INFOS" SCONAME="INFOS" VERSION="1" LANGU="F" DESCRIPT="Overview of all Instances of an SHM Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_INST_INFOS"/>
   <source>method GET_INSTANCE_INFOS.

  DATA:
    l_client             TYPE shm_client,
    l_client_supplied    TYPE abap_bool VALUE abap_false,
    l_inst_name_supplied TYPE abap_bool VALUE abap_false.


  IF inst_name IS SUPPLIED.
    l_inst_name_supplied = abap_true.
  ENDIF.

* &gt;
  TRY.
      CALL METHOD (&apos;_GET_INSTANCE_INFOS804&apos;)
        EXPORTING
          area_name          = area_name
          client             = l_client
          client_supplied    = l_client_supplied
          client_dependent   = _client_dependent
          life_context       = _life_context
          inst_name          = inst_name
          inst_name_supplied = l_inst_name_supplied
        RECEIVING
          infos              = infos.
    CATCH cx_sy_dyn_call_illegal_method.
*     New kernel and/or new basis SP missing -&gt; use slow fallback
      infos = _get_instance_infos71(
                area_name        = area_name
                client           = l_client
                client_supplied  = l_client_supplied
                client_dependent = _client_dependent
                life_context     = _life_context
              ).
      IF abap_true = l_inst_name_supplied.
        DELETE infos WHERE name &lt;&gt; inst_name.
      ENDIF.
  ENDTRY.
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-get_instance_inf = abap_true.
      _trace_service-&gt;trin_get_instance_infos(
        area_name         = area_name
        client            = l_client
        infos             = infos
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="CL_SHM_AREA" CMPNAME="GET_ROOT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method GET_ROOT.

  DATA:
    l_cx        TYPE REF TO cx_root,
    l_area_name TYPE string,
    l_inst_name TYPE string,
    l_client    TYPE string.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-get_root = abap_false.

*   &gt;
    IF is_valid( ) = abap_false.
      l_area_name = me-&gt;area_name.
      l_inst_name = me-&gt;inst_name.
      l_client    = me-&gt;client.
      RAISE EXCEPTION TYPE cx_shm_already_detached
        EXPORTING
          area_name = l_area_name
          inst_name = l_inst_name
          client    = l_client.
    ENDIF.
    root = me-&gt;root.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        IF is_valid( ) = abap_false.
          l_area_name = me-&gt;area_name.
          l_inst_name = me-&gt;inst_name.
          l_client    = me-&gt;client.
          RAISE EXCEPTION TYPE cx_shm_already_detached
            EXPORTING
              area_name = l_area_name
              inst_name = l_inst_name
              client    = l_client.
        ENDIF.
        root = me-&gt;root.
*       &lt;

        _trace_service-&gt;trin_get_root(
          area_name = area_name
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_get_root(
          area_name = area_name
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_AREA" VERSION="1" LANGU="F" DESCRIPT="Active versions of all instances will be set to obsolete" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="F" DESCRIPT="Active writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method INVALIDATE_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.


* &gt;
  rc = _invalidate_area71( area_name         = area_name
                           client            = l_client
                           client_supplied   = l_client_supplied
                           client_dependent  = _client_dependent
                           transactional     = _transactional
                           terminate_changer = terminate_changer
                           affect_server     = affect_server
                           life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-invalidate_area = abap_true.
      _trace_service-&gt;trin_invalidate_area(
        area_name         = area_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="Active version of one instance will be set to obsolete" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="F" DESCRIPT="Active writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method INVALIDATE_INSTANCE.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool value abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.


* &gt;
  rc = _invalidate_instance71(
    area_name         = area_name
    inst_name         = inst_name
    client            = l_client
    client_supplied   = l_client_supplied
    client_dependent  = _client_dependent
    transactional     = _transactional
    terminate_changer = terminate_changer
    affect_server     = affect_server
    life_context      = _life_context
  ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-invalidate_inst = abap_true.
      _trace_service-&gt;trin_invalidate_instance(
        area_name         = area_name
        inst_name         = inst_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="SET_ROOT" VERSION="1" LANGU="F" DESCRIPT="Sets Root Objects" EXPOSURE="2" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="SET_ROOT" SCONAME="ROOT" VERSION="1" LANGU="F" DESCRIPT="Root object" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_TYPE_DEF_AREAHANDLE_ROOT"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="SET_ROOT" SCONAME="CX_SHM_INITIAL_REFERENCE" VERSION="1" LANGU="F" DESCRIPT="Initial Reference Passed" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="SET_ROOT" SCONAME="CX_SHM_WRONG_HANDLE" VERSION="1" LANGU="F" DESCRIPT="Incorrect Handle" MTDTYPE="0" EDITORDER="2 "/>
   <source>method SET_ROOT.

  DATA:
    l_cx TYPE REF TO cx_root.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-set_root = abap_false.

*   &gt;
    _set_root( root ).
    me-&gt;root = root.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        _set_root( root ).
        me-&gt;root = root.
*       &lt;
        _trace_service-&gt;trin_set_root(
          area_name         = area_name
          inst_name         = inst_name
          root              = root
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_set_root(
          area_name         = area_name
          inst_name         = inst_name
          root              = root
          cx                = l_cx
        ).
    ENDTRY.

  ENDIF.

  endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="SHM - Classe utilitaire Définition de Type" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="MO_ATTACH_READ" VERSION="1" LANGU="F" DESCRIPT="Area pour définition de Type" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_TYPE_DEF_AREAHANDLE_AREA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="MO_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="SHM - Classe utilitaire Définition de Type" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_TYPE_DEFINITION" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CONSTRUCTOR" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <exception CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="CONSTRUCTOR" SCONAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" MTDTYPE="2" EDITORDER="1 "/>
   <source>METHOD constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_TYPE_DEFINITION                               *
*&amp; Description     : Création instance pour utilisation SHM Déf. Type  *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception  TYPE REF TO cx_root,
    lo_attach_write  TYPE REF TO zcl_type_def_areahandle_area,
    lo_type_def_root TYPE REF TO zcl_type_def_areahandle_root.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
        lv_retry_count TYPE i.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Récupération version courante
      &quot; -----------------------------------------------------------

      &quot; Lecture de la version courante
      me-&gt;mo_attach_read = zcl_type_def_areahandle_area=&gt;attach_for_read( ).

    CATCH cx_shm_no_active_version INTO lo_cx_exception.
      &quot; Aucune version existante
      TRY.
          &quot;&quot;  --&gt; Création instance d&apos;écriture
          lo_attach_write = zcl_type_def_areahandle_area=&gt;attach_for_write( ).

          &quot;&quot;  --&gt; Création d&apos;une nouvelle version
          CREATE OBJECT lo_type_def_root AREA HANDLE lo_attach_write.

          &quot;&quot;  --&gt; Initialisation de la version
          lo_attach_write-&gt;set_root( lo_type_def_root ).

          &quot;&quot;  --&gt; Sauvegarde la version
          lo_attach_write-&gt;detach_commit( ).

          &quot;&quot;  --&gt; Récupère l&apos;instance de lecture
          me-&gt;mo_attach_read = zcl_type_def_areahandle_area=&gt;attach_for_read( ).

        CATCH cx_root INTO lo_cx_exception.
          &quot; Une erreur est survenue
          &quot;&quot;  --&gt; Lève l&apos;exception
          WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
          RAISE EXCEPTION TYPE zcx_type_definition
            EXPORTING
              previous = lo_cx_exception.

      ENDTRY.

    CATCH cx_shm_inconsistent INTO lo_cx_exception.
      &quot; Mauvaise gestion version
      &quot;&quot;  --&gt; Régénérer instance // ToDo
**      zcl_type_def_areahandle_area=&gt;detach_area( ).
**      zcl_type_def_areahandle_area=&gt;detach_all_areas( ).
***      zcl_type_def_areahandle_area=&gt;free_area(
****          terminate_changer = ABAP_TRUE
***      ).
      zcl_type_def_areahandle_area=&gt;invalidate_instance(
*        EXPORTING
*          inst_name              = CL_SHM_AREA=&gt;DEFAULT_INSTANCE    &quot; Name of a Shared Object Instance of an Area
*          terminate_changer      = ABAP_TRUE    &quot; Active writing processes will be ended
*        RECEIVING
*          rc                     =     &quot; Detach Return Value (Constants in CL_SHM_AREA)
      ).
**      zcl_type_def_areahandle_area=&gt;free_instance(
***        EXPORTING
***          inst_name              = CL_SHM_AREA=&gt;DEFAULT_INSTANCE    &quot; Name of a Shared Object Instance of an Area
***          terminate_changer      = ABAP_TRUE    &quot; Writing processes will be ended
***        RECEIVING
***          rc                     =     &quot; Return Value (Constants in CL_SHM_AREA)
**      ).

      IF lv_retry_count GT 1.
        &quot; Le traitement a déjà été relancé
        &quot;&quot;  --&gt; Lève une Exception
        WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
        RAISE EXCEPTION TYPE zcx_type_definition
          EXPORTING
            previous = lo_cx_exception.

      ENDIF.

      &quot;&quot;  --&gt; Relance traitement
      ADD 1 TO lv_retry_count.
      RETRY.

    CATCH cx_root INTO lo_cx_exception.
      &quot; Erreur lors de la récupération du Token de Lecture
      &quot;&quot;  --&gt; Lève l&apos;exception
      WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
      RAISE EXCEPTION TYPE zcx_type_definition
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

  &quot; Initialisation instance courante
  zcl_type_definition=&gt;mo_instance = me.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_ADD" VERSION="1" LANGU="F" DESCRIPT="Définition Type - Ajout" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_ADD" SCONAME="IO_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_ADD" SCONAME="RV_SUBRC" VERSION="1" LANGU="F" DESCRIPT="Zone système ABAP : code retour des instructions ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <exception CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_ADD" SCONAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD definition_type_add.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_TYPE_ADD                               *
*&amp; Classe          : ZCL_TYPE_DEFINITION                               *
*&amp; Description     : Ajout définition de Type                          *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception  TYPE REF TO cx_root,
    lo_attach_update TYPE REF TO zcl_type_def_areahandle_area.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle définition de type déjà existante
  &quot; -----------------------------------------------------------

  &quot; Détermine si la définition de Type existe déjà
  IF me-&gt;mo_attach_read-&gt;root-&gt;definition_type_exist( io_definition-&gt;absolute_name ) EQ abap_true.
    &quot; La définition du Type existe déjà
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Ajout de la définition de type
  &quot; -----------------------------------------------------------

  TRY.
      &quot;&quot;  --&gt;  Récupération instance de mise à jour
      lo_attach_update = zcl_type_def_areahandle_area=&gt;attach_for_update( ).

      &quot;&quot;  --&gt; Ajout de la définition de type
      lo_attach_update-&gt;root-&gt;definition_type_add( io_definition ).

      &quot;&quot;  --&gt; Pousse la mise à jour
      lo_attach_update-&gt;detach_commit( ).

      IF me-&gt;mo_attach_read-&gt;is_active_version( ) EQ abap_false.
        &quot;&quot;  --&gt; Libère le Token courant
        me-&gt;mo_attach_read-&gt;detach( ).

        &quot;&quot;  --&gt; Recharge l&apos;instance de lecture
        me-&gt;mo_attach_read = zcl_type_def_areahandle_area=&gt;attach_for_read( ).

      ENDIF.

    CATCH cx_root INTO lo_cx_exception.
      &quot; Une erreur est survenue
      IF lo_attach_update IS BOUND.
        TRY.
            &quot;&quot;  --&gt; Libération Token
            lo_attach_update-&gt;detach_rollback( ).

          CATCH cx_root. &quot;#EC NO_HANDLER
            &quot; Erreur libération token

        ENDTRY.

      ENDIF.

      &quot;&quot;  --&gt; Initialisation code retour en erreur
      rv_subrc = 4.

      &quot;&quot;  --&gt; Lève l&apos;exception
      WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
      RAISE EXCEPTION TYPE zcx_type_definition
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_DELETE" VERSION="1" LANGU="F" DESCRIPT="Définition Type - Suppression" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_DELETE" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_DELETE" SCONAME="IV_FREE_SHM_IF_EMPTY" VERSION="1" LANGU="F" DESCRIPT="Libération SHM si plus de Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_DELETE" SCONAME="RV_SUBRC" VERSION="1" LANGU="F" DESCRIPT="Zone système ABAP : code retour des instructions ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <exception CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_DELETE" SCONAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD definition_type_delete.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_TYPE_DELETE                            *
*&amp; Classe          : ZCL_TYPE_DEFINITION                               *
*&amp; Description     : Suppression définition de Type                    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception  TYPE REF TO cx_root,
    lo_attach_update TYPE REF TO zcl_type_def_areahandle_area.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_empty TYPE flag.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle définition de type déjà existante
  &quot; -----------------------------------------------------------

  &quot; Détermine si la définition de Type existe déjà
  IF me-&gt;mo_attach_read-&gt;root-&gt;definition_type_exist( iv_type ) EQ abap_false.
    &quot; La définition du Type n&apos;existe pas
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Suppression de la définition de type
  &quot; -----------------------------------------------------------

  TRY.
      &quot;&quot;  --&gt;  Récupération instance de mise à jour
      lo_attach_update = zcl_type_def_areahandle_area=&gt;attach_for_update( ).

      &quot;&quot;  --&gt; Ajout de la définition de type
      lv_empty = lo_attach_update-&gt;root-&gt;definition_type_delete( iv_type ).

      &quot;&quot;  --&gt; Pousse la mise à jour
      lo_attach_update-&gt;detach_commit( ).

      IF me-&gt;mo_attach_read-&gt;is_active_version( ) EQ abap_false.
        &quot;&quot;  --&gt; Libère le Token courant
        me-&gt;mo_attach_read-&gt;detach( ).

        &quot;&quot;  --&gt; Recharge l&apos;instance de lecture
        me-&gt;mo_attach_read = zcl_type_def_areahandle_area=&gt;attach_for_read( ).

      ENDIF.

    CATCH cx_root INTO lo_cx_exception.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Initialisation code retour en erreur
      rv_subrc = 4.

      &quot;&quot;  --&gt; Lève l&apos;exception
      WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
      RAISE EXCEPTION TYPE zcx_type_definition
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

  IF iv_free_shm_if_empty EQ abap_true AND lv_empty EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Suppression de l&apos;instance SHM
    &quot; -----------------------------------------------------------

    rv_subrc = me-&gt;__internal_use_free_shm( iv_areas_invalidate = abap_true ).

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_FINISH" VERSION="1" LANGU="F" DESCRIPT="Définition Type - Ferme les versions courantes" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <exception CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_FINISH" SCONAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD definition_type_finish.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_TYPE_FINISH                            *
*&amp; Classe          : ZCL_TYPE_DEFINITION                               *
*&amp; Description     : Ferme les Tokens SHM                              *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_cx_exception TYPE REF TO cx_root.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  IF  me-&gt;mo_attach_read IS BOUND
  AND me-&gt;mo_attach_read-&gt;is_valid( ) EQ abap_true.
    TRY.
        &quot; Libération Token de lecture
        me-&gt;mo_attach_read-&gt;detach( ).

      CATCH cx_root INTO lo_cx_exception.
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Lève l&apos;Exception
        WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
        RAISE EXCEPTION TYPE zcx_type_definition
          EXPORTING
            previous = lo_cx_exception.

    ENDTRY.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_GET" VERSION="1" LANGU="F" DESCRIPT="Définition Type - Récupération" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_GET" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_GET" SCONAME="RO_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
   <exception CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_GET" SCONAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD definition_type_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_TYPE_GET                               *
*&amp; Classe          : ZCL_TYPE_DEFINITION                               *
*&amp; Description     : Récupération définition de Type                   *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception TYPE REF TO cx_root.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; Retourne la définition du Type
      ro_definition = me-&gt;mo_attach_read-&gt;root-&gt;definition_type_get( iv_type ).

    CATCH cx_root INTO lo_cx_exception.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Lève une exception
      RAISE EXCEPTION TYPE zcx_type_definition
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="GET_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="Définition Type - Récupération Instance" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="GET_INSTANCE" SCONAME="RO_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="SHM - Classe utilitaire Définition de Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TYPE_DEFINITION"/>
   <exception CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="GET_INSTANCE" SCONAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD get_instance.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : GET_INSTANCE                                      *
*&amp; Classe          : ZCL_TYPE_DEFINITION                               *
*&amp; Description     : Récupération instance utilisation SHM Déf. Type   *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_cx_exception TYPE REF TO cx_root.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      IF NOT zcl_type_definition=&gt;mo_instance IS BOUND.
        &quot; Création d&apos;une nouvelle instance
        CREATE OBJECT zcl_type_definition=&gt;mo_instance.

      ELSEIF NOT zcl_type_definition=&gt;mo_instance-&gt;mo_attach_read IS BOUND
              OR zcl_type_definition=&gt;mo_instance-&gt;mo_attach_read-&gt;is_valid( )          EQ abap_false
              OR zcl_type_definition=&gt;mo_instance-&gt;mo_attach_read-&gt;is_active_version( ) EQ abap_false.
        &quot; Instance existante mais sans canal de lecture ou pas dans la version active
        TRY.
            &quot;&quot;  --&gt; Libère les Tokens existant sur cette version
            zcl_type_definition=&gt;mo_instance-&gt;definition_type_finish( ).

          CATCH zcx_type_definition.                     &quot;#EC NOHANDLER

        ENDTRY.

        &quot;&quot;  --&gt; Libération de l&apos;instance
        FREE : zcl_type_definition=&gt;mo_instance.

        &quot;&quot;  --&gt; Création nouvelle instance
        CREATE OBJECT zcl_type_definition=&gt;mo_instance.

      ENDIF.

      &quot; Retourne l&apos;instance
      ro_instance = zcl_type_definition=&gt;mo_instance.

    CATCH zcx_type_definition INTO lo_cx_exception.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Lève l&apos;Exception
      RAISE EXCEPTION TYPE zcx_type_definition
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="__INTERNAL_USE_FREE_SHM" VERSION="1" LANGU="F" DESCRIPT="Supprime toutes les versions" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="IV_AREAS_DETACH" VERSION="1" LANGU="F" DESCRIPT="Libére les Tokens" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="IV_AREAS_FREE" VERSION="1" LANGU="F" DESCRIPT="Supprime les Versions" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="IV_AREAS_INVALIDATE" VERSION="1" LANGU="F" DESCRIPT="Invalide les Versions" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="RV_RC" VERSION="1" LANGU="F" DESCRIPT="Valeur de retour (constantes dans CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <source>METHOD __internal_use_free_shm.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __INTERNAL_USE_FREE_SHM                           *
*&amp; Classe          : ZCL_TYPE_DEFINITION                               *
*&amp; Description     : Usage Interne : Suppression toutes versions       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  IF iv_areas_free EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Libération des Versions
    &quot; -----------------------------------------------------------

    TRY.
        &quot; Libération des Versions
        rv_rc = zcl_type_def_areahandle_area=&gt;free_instance( ).

      CATCH cx_shm_parameter_error.
        &quot; Une erreur est survenue
        rv_rc = cl_shm_area=&gt;rc_nothing_to_be_done.

    ENDTRY.

    RETURN.

  ELSEIF iv_areas_invalidate EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Invalidation des Versions
    &quot; -----------------------------------------------------------

    TRY.
        &quot; Invalide les Versions
        rv_rc = zcl_type_def_areahandle_area=&gt;invalidate_instance( ).

      CATCH cx_shm_parameter_error.
        &quot; Une erreur est survenue
        rv_rc = cl_shm_area=&gt;rc_nothing_to_be_done.

    ENDTRY.

    RETURN.

  ELSEIF iv_areas_detach EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Livération des Tokens
    &quot; -----------------------------------------------------------

    &quot; Libération des Tokens
    rv_rc = zcl_type_def_areahandle_area=&gt;detach_all_areas( ).

  ENDIF.

  FREE : zcl_type_definition=&gt;mo_instance.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_TRACE" VERSION="1" LANGU="F" DESCRIPT="Tâche - Trace exécution" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZTASK" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_TASK_TRACE" CMPNAME="TY_T_ZTASK_TRACE_H" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="4 " SRCCOLUMN2="109 " TYPESRC_LENG="0 " TYPESRC="ty_t_ZTASK_TRACE_H TYPE SORTED TABLE OF ZTASK_TRACE_H WITH UNIQUE KEY PRIMARY_KEY COMPONENTS task_trace_id
"/>
  <friends CLSNAME="ZCL_TASK_TRACE" REFCLSNAME="ZCL_TASK_MANAGER" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeClasDef CLSNAME="ZCL_TASK_TRACE" TYPEGROUP="ZCL_TASK_PARAM" VERSION="1" TPUTYPE="1" IMPLICIT="X"/>
  <attribute CLSNAME="ZCL_TASK_TRACE" CMPNAME="MT_ZTASK_TRACE" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_T_ZTASK_TRACE_H" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_TRACE" CMPNAME="MT_ZTASK_TRACE_TMP" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_T_ZTASK_TRACE_H" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_TRACE" CMPNAME="MV_TRACE_MEMORY" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZTRACE_MEM_XFELD" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_TRACE" CMPNAME="MV_TRACE_MEMORY_TMP" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZTRACE_MEM_XFELD" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TASK_TRACE" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CONSTRUCTOR" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="CONSTRUCTOR" SCONAME="IV_TRACE_MEMORY" VERSION="1" LANGU="F" DESCRIPT="Activation Trace mémoire" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTRACE_MEM_XFELD" PAROPTIONL="X"/>
   <source>METHOD constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_TASK_TRACE                                    *
*&amp; Description     : Constructeur instance Trace d&apos;exécution des Tâches*
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Initialisation variable locale
  &quot; -----------------------------------------------------------

  me-&gt;mv_trace_memory = iv_trace_memory.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_ADD" VERSION="1" LANGU="F" DESCRIPT="Trace - Ajout de la Trace" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_ADD" SCONAME="IV_TASK_TRACE_ID" VERSION="1" LANGU="F" DESCRIPT="ID Trace Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYSUUID_C32"/>
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_ADD" SCONAME="IV_LOG_IMMEDIATE" VERSION="1" LANGU="F" DESCRIPT="Trace - Enregistrement immédiat" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <source>METHOD task_trace_add.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_TRACE_ADD                                    *
*&amp; Classe          : ZCL_TASK_TRACE                                    *
*&amp; Description     : Ajotu de la Trace d&apos;exécution                     *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération de l&apos;entrée correspondante
  &quot; -----------------------------------------------------------

  READ TABLE me-&gt;mt_ztask_trace_tmp WITH TABLE KEY task_trace_id = iv_task_trace_id
                                         ASSIGNING FIELD-SYMBOL(&lt;lfs_s_ztask_trace_tmp&gt;).
  IF sy-subrc NE 0.
    &quot; Aucune correspondance
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Ajout de la Trace dans table définitive
  &quot; -----------------------------------------------------------

  &quot; Ajout de l&apos;entrée dans table définitive
  INSERT &lt;lfs_s_ztask_trace_tmp&gt; INTO TABLE me-&gt;mt_ztask_trace.

  &quot; Suppression de l&apos;entrée dans table temporaire
  DELETE TABLE me-&gt;mt_ztask_trace_tmp FROM &lt;lfs_s_ztask_trace_tmp&gt;.

  IF iv_log_immediate EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Enregistrement en DB
    &quot; -----------------------------------------------------------

    me-&gt;task_trace_save_to_db( ).

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_GET_PARAM" VERSION="1" LANGU="F" DESCRIPT="Trace - Récupération configuration" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_GET_PARAM" SCONAME="IV_FUNCTION_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom du module fonction" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="RS38L_FNAM"/>
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_GET_PARAM" SCONAME="RS_PARAM" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZCL_TASK_PARAM=&gt;TY_TASK_FUNCTION_PARAM"/>
   <source>METHOD task_trace_get_param.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_TRACE_GET_PARAM                              *
*&amp; Classe          : ZCL_TASK_TRACE                                    *
*&amp; Description     : Récupération configuration Trace                  *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération entrée correpsondante
  &quot; -----------------------------------------------------------

  &quot; Récupération de la configuration de Trace
  rs_param = zcl_task_param=&gt;task_param_get( iv_function_name ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_IS_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Trace - Trace Active sur MF ?" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_IS_ACTIVE" SCONAME="IV_FUNCTION_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom du module fonction" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="RS38L_FNAM"/>
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_IS_ACTIVE" SCONAME="RV_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Trace Active" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG"/>
   <source>METHOD task_trace_is_active.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_TRACE_IS_ACTIVE                              *
*&amp; Classe          : ZCL_TASK_TRACE                                    *
*&amp; Description     : Trace Active sur MF ?                             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération entrée correpsondante
  &quot; -----------------------------------------------------------

  &quot; Retourne l&apos;indicateur d&apos;activation de la Trace sur le MF
  rv_active = zcl_task_param=&gt;task_param_get( iv_function_name )-trace_active.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_SAVE_TO_DB" VERSION="1" LANGU="F" DESCRIPT="Trace - Sauvegarde les Traces d&apos;exécution" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_SAVE_TO_DB" SCONAME="RV_SUBRC" VERSION="1" LANGU="F" DESCRIPT="Zone système ABAP : code retour des instructions ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <source>METHOD task_trace_save_to_db.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : SAVE_TO_DB                                        *
*&amp; Classe          : ZCL_TASK_TRACE                                    *
*&amp; Description     : Sauvegarde Trace d&apos;exéuction en DB                *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Sauvegarde les données en DB
  &quot; -----------------------------------------------------------

  &quot; Sauvegarde les données en DB
  CALL FUNCTION &apos;Z_TASK_TRACE_SAVE_TO_DB&apos;
    EXPORTING
      it_ztask_trace = CONV ztask_trace_h_t( me-&gt;mt_ztask_trace )
    IMPORTING
      ev_subrc       = rv_subrc.

  IF rv_subrc IS INITIAL.
    &quot; Suppression des données
    FREE : me-&gt;mt_ztask_trace.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_START" VERSION="1" LANGU="F" DESCRIPT="Trace - Début" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_START" SCONAME="IV_TASK_MANAGER_ID" VERSION="1" LANGU="F" DESCRIPT="ID Manager de Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYSUUID_C32"/>
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_START" SCONAME="IV_TASK_ID" VERSION="1" LANGU="F" DESCRIPT="ID Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYSUUID_C32"/>
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_START" SCONAME="IV_FUNCTION_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom du module fonction" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="RS38L_FNAM"/>
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_START" SCONAME="IV_TRACE_MEMORY" VERSION="1" LANGU="F" DESCRIPT="Trace - Activation Trace mémoire" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTRACE_MEM_XFELD" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_START" SCONAME="RV_TASK_TRACE_ID" VERSION="1" LANGU="F" DESCRIPT="ID Trace Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SYSUUID_C32"/>
   <source>METHOD task_trace_start.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_TRACE_START                                  *
*&amp; Classe          : ZCL_TASK_TRACE                                    *
*&amp; Description     : Début de la Trace d&apos;exécution                     *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_abap_callstack TYPE abap_callstack.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_task_trace_h TYPE ztask_trace_h.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Création nouvelle entrée exécution
  &quot; -----------------------------------------------------------

  &quot; Initialisation
  ls_task_trace_h-mandt           = sy-mandt.
  ls_task_trace_h-uname           = sy-uname.
  ls_task_trace_h-task_id         = iv_task_id.
  ls_task_trace_h-funcname        = iv_function_name.
  ls_task_trace_h-task_manager_id = iv_task_manager_id.
  GET RUN TIME FIELD   ls_task_trace_h-runtime_beg.
  GET TIME STAMP FIELD ls_task_trace_h-timestamp_beg.

  &quot; Récupération Pile d&apos;Appel
  CALL FUNCTION &apos;SYSTEM_CALLSTACK&apos;
    EXPORTING
      max_level = 4 &quot;Appelant du Manager -&gt; TASK_START_NEW #EC NOTEXT
    IMPORTING
      callstack = lt_abap_callstack.

  TRY.
      &quot; Initialisation données Appelant
      MOVE-CORRESPONDING lt_abap_callstack[ lines( lt_abap_callstack ) ] TO ls_task_trace_h.

    CATCH cx_sy_itab_line_not_found.
      &quot; Aucune correspondance

  ENDTRY.

  TRY.
      &quot; Génération ID unique de Trace
      ls_task_trace_h-task_trace_id = cl_system_uuid=&gt;create_uuid_c32_static( ).

    CATCH cx_uuid_error.
      &quot; Erreur de la génération de l&apos;ID
      &quot;&quot;  --&gt; Utilisation nombre aléatoire
      ls_task_trace_h-task_trace_id = cl_abap_random=&gt;seed( ).

  ENDTRY.

  &quot; Ajout de l&apos;entrée dans table temporaire
  INSERT ls_task_trace_h INTO TABLE me-&gt;mt_ztask_trace_tmp.

  IF iv_trace_memory     EQ abap_true
  OR me-&gt;mv_trace_memory EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Trace consommation mémoire
    &quot; -----------------------------------------------------------

    &quot; Mesure utilisation mémoire
    cl_abap_memory_utilities=&gt;get_total_used_size( IMPORTING size = ls_task_trace_h-mem_before ).

    IF me-&gt;mv_trace_memory EQ abap_false AND iv_trace_memory EQ abap_true.
      &quot; Initialisation Indicateur temporaire de mesure mémoire
      me-&gt;mv_trace_memory_tmp = abap_true.

    ENDIF.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Retourne l&apos;ID de Trace
  &quot; -----------------------------------------------------------

  rv_task_trace_id = ls_task_trace_h-task_trace_id.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_STOP" VERSION="1" LANGU="F" DESCRIPT="Trace - Fin" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_STOP" SCONAME="IV_TASK_TRACE_ID" VERSION="1" LANGU="F" DESCRIPT="ID Trace Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYSUUID_C32"/>
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_STOP" SCONAME="IV_LOG_IMMEDIATE" VERSION="1" LANGU="F" DESCRIPT="Trace - Enregistrement immédiat" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <source>METHOD task_trace_stop.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_TRACE_STOP                                   *
*&amp; Classe          : ZCL_TASK_TRACE                                    *
*&amp; Description     : Fin de la Trace d&apos;exécution                       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération de l&apos;entrée correspondante
  &quot; -----------------------------------------------------------

  READ TABLE me-&gt;mt_ztask_trace_tmp WITH TABLE KEY task_trace_id = iv_task_trace_id
                                         ASSIGNING FIELD-SYMBOL(&lt;lfs_s_ztask_trace_tmp&gt;).
  IF sy-subrc NE 0.
    &quot; Aucune correspondance
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Initialisation données fin d&apos;exécution de la Tâche
  &quot; -----------------------------------------------------------

  &quot; Initialisation Temps fin
  GET RUN TIME FIELD   &lt;lfs_s_ztask_trace_tmp&gt;-runtime_end.
  GET TIME STAMP FIELD &lt;lfs_s_ztask_trace_tmp&gt;-timestamp_end.

  &quot; Initialisation durée d&apos;exécution
  &lt;lfs_s_ztask_trace_tmp&gt;-runtime_exec = &lt;lfs_s_ztask_trace_tmp&gt;-runtime_end - &lt;lfs_s_ztask_trace_tmp&gt;-runtime_beg.

  IF me-&gt;mv_trace_memory     EQ abap_true
  OR me-&gt;mv_trace_memory_tmp EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Initialisation Empreinte mémoire
    &quot; -----------------------------------------------------------

    &quot; Mesure mémoire après exécution
    cl_abap_memory_utilities=&gt;get_total_used_size( IMPORTING size = &lt;lfs_s_ztask_trace_tmp&gt;-mem_after ).

    &quot; Calcul Empreinte mémoire utilisée
    &lt;lfs_s_ztask_trace_tmp&gt;-mem_allocated = &lt;lfs_s_ztask_trace_tmp&gt;-mem_after - &lt;lfs_s_ztask_trace_tmp&gt;-mem_before.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Ajout de la Trace dans table définitive
  &quot; -----------------------------------------------------------

  me-&gt;task_trace_add(
    iv_task_trace_id = iv_task_trace_id
    iv_log_immediate = iv_log_immediate
  ).

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_SHM_ROOT" VERSION="1" LANGU="F" DESCRIPT="Tâche - SHM Racine" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" CLSSHAREDMEMORY="X" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <implementing CLSNAME="ZCL_TASK_SHM_ROOT" REFCLSNAME="IF_SHM_BUILD_INSTANCE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="MT_TASK_MANAGER_ID" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="EPIC_T_GUID" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_TASK_SHM_ROOT" CPDNAME="IF_SHM_BUILD_INSTANCE~BUILD">
   <source>METHOD if_shm_build_instance~build.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

ENDMETHOD.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="TASK_MANAGER_DEREGISTER" VERSION="1" LANGU="F" DESCRIPT="Manager Tâche - Désenregistrement" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="TASK_MANAGER_DEREGISTER" SCONAME="IV_TASK_MANAGER_ID" VERSION="1" LANGU="F" DESCRIPT="Tâche - ID Manager Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTASK_MANAGER_ID"/>
   <parameter CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="TASK_MANAGER_DEREGISTER" SCONAME="RV_EMPTY_LIST" VERSION="1" LANGU="F" DESCRIPT="Plus de Tâches présentes" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG"/>
   <source>METHOD task_manager_deregister.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_MANAGER_DEREGISTER                           *
*&amp; Classe          : ZCL_TASK_SHM_ROOT                                 *
*&amp; Description     : Désenregistrement du Manager de Tâche             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Désenregistrement du Manager de Tâche
  &quot; -----------------------------------------------------------

  &quot; Récupération index du Manager de Tâche
  READ TABLE me-&gt;mt_task_manager_id WITH KEY table_line = iv_task_manager_id
                                TRANSPORTING NO FIELDS BINARY SEARCH.
  IF sy-subrc EQ 0.
    &quot; Position trouvé
    &quot;&quot;  --&gt; Suppression du Manager de Tâche
    DELETE me-&gt;mt_task_manager_id INDEX sy-tabix.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Retourne indicateur de présence d&apos;autre Manager de Tâche
  &quot; -----------------------------------------------------------

  rv_empty_list = boolc( me-&gt;mt_task_manager_id[] IS INITIAL ). &quot;Vrai si plus de Manager Tâche présent

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="TASK_MANAGER_IS_REGISTERED" VERSION="1" LANGU="F" DESCRIPT="Manager Tâche - Déjà enregistrée ?" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="TASK_MANAGER_IS_REGISTERED" SCONAME="IV_TASK_MANAGER_ID" VERSION="1" LANGU="F" DESCRIPT="Tâche - ID Manager Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTASK_MANAGER_ID"/>
   <parameter CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="TASK_MANAGER_IS_REGISTERED" SCONAME="RV_FOUND" VERSION="1" LANGU="F" DESCRIPT="Tâche déjà enregistrée" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG"/>
   <source>METHOD task_manager_is_registered.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_MANAGER_IS_REGISTERED                        *
*&amp; Classe          : ZCL_TASK_SHM_ROOT                                 *
*&amp; Description     : Contrôle présence du Manager de Tâche             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle présence du Manager de Tâche
  &quot; -----------------------------------------------------------

  READ TABLE me-&gt;mt_task_manager_id WITH KEY table_line = iv_task_manager_id
                                TRANSPORTING NO FIELDS BINARY SEARCH.
  rv_found = boolc( sy-subrc EQ 0 ). &quot;Vrai si ID Tâche existe

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="TASK_MANAGER_REGISTER" VERSION="1" LANGU="F" DESCRIPT="Manager Tâche - Enregistrement" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="TASK_MANAGER_REGISTER" SCONAME="IV_TASK_MANAGER_ID" VERSION="1" LANGU="F" DESCRIPT="Tâche - ID Manager Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTASK_MANAGER_ID"/>
   <source>METHOD task_manager_register.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_MANAGER_REGISTER                             *
*&amp; Classe          : ZCL_TASK_SHM_ROOT                                 *
*&amp; Description     : Ajout du Manager de Tâche                         *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Ajout de l&apos;ID Manager de Tâche
  &quot; -----------------------------------------------------------

  READ TABLE me-&gt;mt_task_manager_id WITH KEY table_line = iv_task_manager_id
                                TRANSPORTING NO FIELDS BINARY SEARCH.
  IF sy-subrc NE 0.
    &quot; ID Tâche non présent
    &quot;&quot;  --&gt; Ajout de l&apos;ID
    INSERT iv_task_manager_id INTO me-&gt;mt_task_manager_id INDEX sy-tabix.

  ENDIF.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_SHM_AREA" VERSION="1" LANGU="F" DESCRIPT="Tâche - Mémoire partagée" CATEGORY="45" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" RSTAT="S" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CL_SHM_AREA">
  <friends CLSNAME="ZCL_TASK_SHM_AREA" REFCLSNAME="CL_SHM_AREA" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros></localMacros>
  <attribute CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="AREA_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of an Area Class" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="&apos;ZCL_TASK_SHM_AREA&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SHM_AREA_NAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ROOT" VERSION="1" LANGU="F" DESCRIPT="SHM: Model of a Data Class" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_TASK_SHM_ROOT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="_CLIENT_DEPENDENT" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="5 " ATTDECLTYP="2" ATTVALUE="ABAP_FALSE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="_LIFE_CONTEXT" VERSION="1" LANGU="F" DESCRIPT="Lifetime of an Area (Constants in CL_SHM_AREA)" EXPOSURE="0" STATE="1" EDITORDER="6 " ATTDECLTYP="2" ATTVALUE="CL_SHM_AREA=&gt;LIFE_CONTEXT_APPSERVER" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SHM_LIFE_CONTEXT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="_TRACE_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="(Internal) Flag: Trace Active?" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="1" ATTVALUE="ABAP_FALSE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="_TRACE_SERVICE" VERSION="1" LANGU="F" DESCRIPT="(Internal) Reference to Trace Class" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="3" TYPE="IF_SHM_TRACE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="_TRANSACTIONAL" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="2" ATTVALUE="ABAP_FALSE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="_VERSION_" VERSION="1" LANGU="F" DESCRIPT="(internal)" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="22" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCL_TASK_SHM_AREA" REFCLSNAME="CL_SHM_AREA" VERSION="1" STATE="1">
   <redefinition CLSNAME="ZCL_TASK_SHM_AREA" REFCLSNAME="CL_SHM_AREA" VERSION="1" MTDNAME="GET_ROOT" EXPOSURE="0"/>
  </inheritance>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" VERSION="1" LANGU="F" DESCRIPT="Request a Read Lock" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="HANDLE" VERSION="1" LANGU="F" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK_SHM_AREA"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_INCONSISTENT" VERSION="1" LANGU="F" DESCRIPT="Different Definitions Between Program and Area" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_NO_ACTIVE_VERSION" VERSION="1" LANGU="F" DESCRIPT="No active version exists for an attach" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_READ_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Request for a Second Read Lock" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="5 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="A Change Lock Is Already Active" MTDTYPE="0" EDITORDER="6 "/>
   <source>method ATTACH_FOR_READ.

  DATA:
    l_attributes       TYPE shma_attributes,
    l_root             TYPE REF TO object,
    l_cx               TYPE REF TO cx_root,
    l_client           TYPE shm_client,
    l_client_supplied  TYPE abap_bool. &quot;#EC NEEDED

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.


  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_read = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

*   try sneak mode first
    handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                      sneak_mode   = abap_true
                                      life_context = _life_context
                            IMPORTING root         = l_root ).

    IF l_root IS INITIAL.
*     no root object returned, sneak mode was not successful.
*     -&gt; read area properties from database and try again.
      cl_shm_service=&gt;initialize(
        EXPORTING area_name       = handle-&gt;area_name
                  client          = l_client
        IMPORTING attributes      = l_attributes
      ).

      handle-&gt;properties = l_attributes-properties.
      handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                        sneak_mode   = abap_false
                                        life_context = _life_context
                              IMPORTING root         = l_root ).

    ENDIF.

    handle-&gt;root ?= l_root.
*   &lt;

  ELSE.

    TRY.

*       &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                          sneak_mode   = abap_true
                                          life_context = _life_context
                                IMPORTING root         = l_root ).

        IF l_root IS INITIAL.
*         no root object returned, sneak mode was not successful.
*         -&gt; read area properties from database and try again.
          cl_shm_service=&gt;initialize(
            EXPORTING area_name       = handle-&gt;area_name
                      client          = l_client
            IMPORTING attributes      = l_attributes
          ).

          handle-&gt;properties = l_attributes-properties.
          handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                            sneak_mode   = abap_false
                                            life_context = _life_context
                                  IMPORTING root         = l_root ).

        ENDIF.
        handle-&gt;root ?= l_root.

*       &lt;
        _trace_service-&gt;trin_attach_for_read(
          area_name = area_name
          inst_name = inst_name
          client    = l_client ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_read(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" VERSION="1" LANGU="F" DESCRIPT="Request a Change Lock" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="ATTACH_MODE" VERSION="1" LANGU="F" DESCRIPT="Mode of ATTACH (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_ATTACH_MODE" PARVALUE="CL_SHM_AREA=&gt;ATTACH_MODE_DEFAULT"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="WAIT_TIME" VERSION="1" LANGU="F" DESCRIPT="Maximum Wait Time (in Milliseconds)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="0"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="HANDLE" VERSION="1" LANGU="F" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK_SHM_AREA"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_INCONSISTENT" VERSION="1" LANGU="F" DESCRIPT="Different Definitions Between Program and Area" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_NO_ACTIVE_VERSION" VERSION="1" LANGU="F" DESCRIPT="No active version exists for an attach" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_VERSION_LIMIT_EXCEEDED" VERSION="1" LANGU="F" DESCRIPT="No Additional Versions Available" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="A write lock is already active" MTDTYPE="0" EDITORDER="5 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Passed Parameter Has Incorrect Value" MTDTYPE="0" EDITORDER="6 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_PENDING_LOCK_REMOVED" VERSION="1" LANGU="F" DESCRIPT="Shared Objects: Waiting Lock Was Deleted" MTDTYPE="0" EDITORDER="7 "/>
   <source>method ATTACH_FOR_UPDATE.

  DATA:
    l_attributes             TYPE shma_attributes,
    l_root                   TYPE REF TO object,
    l_cx                     TYPE REF TO cx_root,
    l_client                 TYPE shm_client,
    l_client_supplied        TYPE abap_bool, &quot;#EC NEEDED
    l_wait_time              TYPE i,
    l_wait_time_per_loop     TYPE i,
    l_wait_time_per_loop_sec TYPE f.

  l_wait_time = wait_time.

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.


  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_upd = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

    cl_shm_service=&gt;initialize(
      EXPORTING area_name    = handle-&gt;area_name
                client       = l_client
      IMPORTING attributes   = l_attributes
    ).

    handle-&gt;properties = l_attributes-properties.

    handle-&gt;_attach_update70(
      EXPORTING area_name = handle-&gt;area_name
                mode      = attach_mode
      IMPORTING root      = l_root
      CHANGING  wait_time = l_wait_time ).

    IF abap_true = l_attributes-properties-has_versions AND
       handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
      handle-&gt;_attach_update70(
        EXPORTING area_name = handle-&gt;area_name
                  mode      = attach_mode
        IMPORTING root      = l_root
        CHANGING  wait_time = l_wait_time ).
    ENDIF.

    IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
       handle-&gt;_lock IS INITIAL.

      l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
      IF l_wait_time_per_loop &lt; 2000.
        l_wait_time_per_loop = 2000.
      ELSEIF l_wait_time_per_loop &gt; 300000.
        l_wait_time_per_loop = 300000.
      ENDIF.

      l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

      WHILE handle-&gt;_lock IS INITIAL.

        IF l_wait_time_per_loop &gt; l_wait_time.
          l_wait_time_per_loop = l_wait_time.
          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
        ENDIF.

        WAIT UP TO l_wait_time_per_loop_sec SECONDS.
        l_wait_time = l_wait_time - l_wait_time_per_loop.

        handle-&gt;_attach_update70(
          EXPORTING area_name = handle-&gt;area_name
                    mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
          IMPORTING root      = l_root
          CHANGING  wait_time = l_wait_time ).

        IF abap_true = l_attributes-properties-has_versions AND
           handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
          handle-&gt;_attach_update70(
            EXPORTING area_name = handle-&gt;area_name
                      mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
            IMPORTING root      = l_root
            CHANGING  wait_time = l_wait_time ).
        ENDIF.

      ENDWHILE.

    ENDIF.

    handle-&gt;root ?= l_root.

*   &lt;

  ELSE.

    TRY.

*       &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        cl_shm_service=&gt;initialize(
          EXPORTING area_name    = handle-&gt;area_name
                    client       = l_client
          IMPORTING attributes   = l_attributes
        ).

        handle-&gt;properties = l_attributes-properties.

        handle-&gt;_attach_update70(
          EXPORTING area_name = handle-&gt;area_name
                    mode      = attach_mode
          IMPORTING root      = l_root
          CHANGING  wait_time = l_wait_time ).

        IF abap_true = l_attributes-properties-has_versions AND
           handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
          handle-&gt;_attach_update70(
            EXPORTING area_name = handle-&gt;area_name
                      mode      = attach_mode
            IMPORTING root      = l_root
            CHANGING  wait_time = l_wait_time ).
        ENDIF.

        IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
           handle-&gt;_lock IS INITIAL.

          l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
          IF l_wait_time_per_loop &lt; 2000.
            l_wait_time_per_loop = 2000.
          ELSEIF l_wait_time_per_loop &gt; 300000.
            l_wait_time_per_loop = 300000.
          ENDIF.

          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

          WHILE handle-&gt;_lock IS INITIAL.

            IF l_wait_time_per_loop &gt; l_wait_time.
              l_wait_time_per_loop = l_wait_time.
              l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
            ENDIF.

            WAIT UP TO l_wait_time_per_loop_sec SECONDS.
            l_wait_time = l_wait_time - l_wait_time_per_loop.

            handle-&gt;_attach_update70(
              EXPORTING
                area_name = handle-&gt;area_name
                mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
              IMPORTING
                root      = l_root
              CHANGING
                wait_time = l_wait_time ).

            IF abap_true = l_attributes-properties-has_versions AND
               handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
              handle-&gt;_attach_update70(
                EXPORTING
                  area_name = handle-&gt;area_name
                  mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
                IMPORTING
                  root      = l_root
                CHANGING
                  wait_time = l_wait_time ).
            ENDIF.

          ENDWHILE.

        ENDIF.

        handle-&gt;root ?= l_root.

*       &lt;
        _trace_service-&gt;trin_attach_for_update(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_update(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" VERSION="1" LANGU="F" DESCRIPT="Request a Write Lock" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="ATTACH_MODE" VERSION="1" LANGU="F" DESCRIPT="Mode of ATTACH (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_ATTACH_MODE" PARVALUE="CL_SHM_AREA=&gt;ATTACH_MODE_DEFAULT"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="WAIT_TIME" VERSION="1" LANGU="F" DESCRIPT="Maximum Wait Time (in Milliseconds)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="0"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="HANDLE" VERSION="1" LANGU="F" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK_SHM_AREA"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_VERSION_LIMIT_EXCEEDED" VERSION="1" LANGU="F" DESCRIPT="No Additional Versions Available" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="A write lock is already active" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Passed Parameter Has Incorrect Value" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_PENDING_LOCK_REMOVED" VERSION="1" LANGU="F" DESCRIPT="Shared Objects: Waiting Lock Was Deleted" MTDTYPE="0" EDITORDER="5 "/>
   <source>method ATTACH_FOR_WRITE.

  DATA:
    l_attributes             TYPE shma_attributes,
    l_cx                     TYPE REF TO cx_root,
    l_client                 TYPE shm_client,
    l_client_supplied        TYPE abap_bool, &quot;#EC NEEDED
    l_wait_time              TYPE i,
    l_wait_time_per_loop     TYPE i,
    l_wait_time_per_loop_sec TYPE f.

  l_wait_time = wait_time.

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.


  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_write = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

    cl_shm_service=&gt;initialize(
      EXPORTING area_name    = handle-&gt;area_name
                client       = l_client
      IMPORTING attributes   = l_attributes
    ).

    handle-&gt;properties = l_attributes-properties.

    handle-&gt;_attach_write70(
      EXPORTING
        area_name = handle-&gt;area_name
        mode      = attach_mode
      CHANGING
        wait_time = l_wait_time ).

    IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
       handle-&gt;_lock IS INITIAL.

      l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
      IF l_wait_time_per_loop &lt; 2000.
        l_wait_time_per_loop = 2000.
      ELSEIF l_wait_time_per_loop &gt; 300000.
        l_wait_time_per_loop = 300000.
      ENDIF.

      l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

      WHILE handle-&gt;_lock IS INITIAL.

        IF l_wait_time_per_loop &gt; l_wait_time.
          l_wait_time_per_loop = l_wait_time.
          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
        ENDIF.

        WAIT UP TO l_wait_time_per_loop_sec SECONDS.
        l_wait_time = l_wait_time - l_wait_time_per_loop.

        handle-&gt;_attach_write70(
          EXPORTING
            area_name = handle-&gt;area_name
            mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
          CHANGING
            wait_time = l_wait_time ).

      ENDWHILE.

    ENDIF.

*   &lt;

  ELSE.

    TRY.

*     &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        cl_shm_service=&gt;initialize(
          EXPORTING area_name    = handle-&gt;area_name
                    client       = l_client
          IMPORTING attributes   = l_attributes
        ).

        handle-&gt;properties = l_attributes-properties.

        handle-&gt;_attach_write70(
          EXPORTING
            area_name = handle-&gt;area_name
            mode      = attach_mode
          CHANGING
            wait_time = l_wait_time ).

        IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
           handle-&gt;_lock IS INITIAL.

          l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
          IF l_wait_time_per_loop &lt; 2000.
            l_wait_time_per_loop = 2000.
          ELSEIF l_wait_time_per_loop &gt; 300000.
            l_wait_time_per_loop = 300000.
          ENDIF.

          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

          WHILE handle-&gt;_lock IS INITIAL.

            IF l_wait_time_per_loop &gt; l_wait_time.
              l_wait_time_per_loop = l_wait_time.
              l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
            ENDIF.

            WAIT UP TO l_wait_time_per_loop_sec SECONDS.
            l_wait_time = l_wait_time - l_wait_time_per_loop.

            handle-&gt;_attach_write70(
              EXPORTING
                area_name = handle-&gt;area_name
                mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
              CHANGING
                wait_time = l_wait_time ).

          ENDWHILE.

        ENDIF.

*     &lt;

        _trace_service-&gt;trin_attach_for_write(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
        ).
      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_write(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="BUILD" VERSION="1" LANGU="F" DESCRIPT="Direct Call of Area Constructor" EXPOSURE="2" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="BUILD" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="BUILD" SCONAME="CX_SHMA_NOT_CONFIGURED" VERSION="1" LANGU="F" DESCRIPT="SHM Administration: Area Property Is Not Configured" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="BUILD" SCONAME="CX_SHMA_INCONSISTENT" VERSION="1" LANGU="F" DESCRIPT="SHM Administration: Inconsistent Attribute Combination" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="BUILD" SCONAME="CX_SHM_BUILD_FAILED" VERSION="1" LANGU="F" DESCRIPT="Constructor Run Failed" MTDTYPE="0" EDITORDER="3 "/>
   <source>method BUILD.

  DATA:
    l_cls_name TYPE shm_auto_build_class_name,
    l_cx TYPE REF TO cx_root.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-build = abap_false.

*   &gt;
    l_cls_name =
      cl_shm_service=&gt;get_auto_build_class_name( area_name ).

    CALL METHOD (l_cls_name)=&gt;if_shm_build_instance~build
      EXPORTING
        inst_name = inst_name.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        l_cls_name =
          cl_shm_service=&gt;get_auto_build_class_name( area_name ).

        CALL METHOD (l_cls_name)=&gt;if_shm_build_instance~build
          EXPORTING
            inst_name = inst_name.
*       &lt;
        _trace_service-&gt;trin_build(
          area_name         = area_name
          inst_name         = inst_name
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_build(
          area_name         = area_name
          inst_name         = inst_name
          cx                = l_cx
        ).
    ENDTRY.

  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="CLASS_CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CLASS_CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <source>method CLASS_CONSTRUCTOR.

* TRACE { DO NOT REMOVE THIS LINE !
  _trace_active = abap_false.
  TRY.
      _trace_service =
        cl_shm_service=&gt;trace_get_service( area_name ).
      IF NOT _trace_service IS INITIAL.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      ENDIF.
    CATCH cx_root. &quot;#EC NO_HANDLER
                   &quot;#EC CATCH_ALL
  ENDTRY.
* TRACE } DO NOT REMOVE THIS LINE !

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="DETACH_AREA" VERSION="1" LANGU="F" DESCRIPT="Release all locks on all instances" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="DETACH_AREA" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <source>method DETACH_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.


* &gt;
  rc = _detach_area71( area_name        = area_name
                       client           = l_client
                       client_supplied  = l_client_supplied
                       client_dependent = _client_dependent
                       life_context     = _life_context
       ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-detach_area = abap_true.
      _trace_service-&gt;trin_detach_area(
        area_name = area_name
        client    = l_client
        rc        = rc
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_AREA" VERSION="1" LANGU="F" DESCRIPT="Delete all instances" EXPOSURE="2" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_AREA" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="F" DESCRIPT="Writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_AREA" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_AREA" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method FREE_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.


* &gt;
  rc = _free_area71( area_name         = area_name
                     client            = l_client
                     client_supplied   = l_client_supplied
                     client_dependent  = _client_dependent
                     transactional     = _transactional
                     terminate_changer = terminate_changer
                     affect_server     = affect_server
                     life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-free_area = abap_true.
      _trace_service-&gt;trin_free_area(
      area_name         = area_name
      client            = l_client
      terminate_changer = terminate_changer
      affect_server     = affect_server
      rc                = rc
    ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="Deletion of an Instance" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_INSTANCE" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_INSTANCE" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="F" DESCRIPT="Writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_INSTANCE" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_INSTANCE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method FREE_INSTANCE.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.


* &gt;
  rc = _free_instance71( area_name         = area_name
                         inst_name         = inst_name
                         client            = l_client
                         client_supplied   = l_client_supplied
                         client_dependent  = _client_dependent
                         transactional     = _transactional
                         terminate_changer = terminate_changer
                         affect_server     = affect_server
                         life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-free_instance = abap_true.
      _trace_service-&gt;trin_free_instance(
        area_name         = area_name
        inst_name         = inst_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="GET_GENERATOR_VERSION" VERSION="1" LANGU="F" DESCRIPT="Query Generator Version" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="GET_GENERATOR_VERSION" SCONAME="GENERATOR_VERSION" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
   <source>method GET_GENERATOR_VERSION.
  generator_version = _version_.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="GET_INSTANCE_INFOS" VERSION="1" LANGU="F" DESCRIPT="Returns the names of all instances" EXPOSURE="2" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="GET_INSTANCE_INFOS" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance in an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="GET_INSTANCE_INFOS" SCONAME="INFOS" VERSION="1" LANGU="F" DESCRIPT="Overview of all Instances of an SHM Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_INST_INFOS"/>
   <source>method GET_INSTANCE_INFOS.

  DATA:
    l_client             TYPE shm_client,
    l_client_supplied    TYPE abap_bool VALUE abap_false,
    l_inst_name_supplied TYPE abap_bool VALUE abap_false.


  IF inst_name IS SUPPLIED.
    l_inst_name_supplied = abap_true.
  ENDIF.

* &gt;
  TRY.
      CALL METHOD (&apos;_GET_INSTANCE_INFOS804&apos;)
        EXPORTING
          area_name          = area_name
          client             = l_client
          client_supplied    = l_client_supplied
          client_dependent   = _client_dependent
          life_context       = _life_context
          inst_name          = inst_name
          inst_name_supplied = l_inst_name_supplied
        RECEIVING
          infos              = infos.
    CATCH cx_sy_dyn_call_illegal_method.
*     New kernel and/or new basis SP missing -&gt; use slow fallback
      infos = _get_instance_infos71(
                area_name        = area_name
                client           = l_client
                client_supplied  = l_client_supplied
                client_dependent = _client_dependent
                life_context     = _life_context
              ).
      IF abap_true = l_inst_name_supplied.
        DELETE infos WHERE name &lt;&gt; inst_name.
      ENDIF.
  ENDTRY.
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-get_instance_inf = abap_true.
      _trace_service-&gt;trin_get_instance_infos(
        area_name         = area_name
        client            = l_client
        infos             = infos
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="CL_SHM_AREA" CMPNAME="GET_ROOT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method GET_ROOT.

  DATA:
    l_cx        TYPE REF TO cx_root,
    l_area_name TYPE string,
    l_inst_name TYPE string,
    l_client    TYPE string.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-get_root = abap_false.

*   &gt;
    IF is_valid( ) = abap_false.
      l_area_name = me-&gt;area_name.
      l_inst_name = me-&gt;inst_name.
      l_client    = me-&gt;client.
      RAISE EXCEPTION TYPE cx_shm_already_detached
        EXPORTING
          area_name = l_area_name
          inst_name = l_inst_name
          client    = l_client.
    ENDIF.
    root = me-&gt;root.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        IF is_valid( ) = abap_false.
          l_area_name = me-&gt;area_name.
          l_inst_name = me-&gt;inst_name.
          l_client    = me-&gt;client.
          RAISE EXCEPTION TYPE cx_shm_already_detached
            EXPORTING
              area_name = l_area_name
              inst_name = l_inst_name
              client    = l_client.
        ENDIF.
        root = me-&gt;root.
*       &lt;

        _trace_service-&gt;trin_get_root(
          area_name = area_name
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_get_root(
          area_name = area_name
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_AREA" VERSION="1" LANGU="F" DESCRIPT="Active versions of all instances will be set to obsolete" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="F" DESCRIPT="Active writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method INVALIDATE_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.


* &gt;
  rc = _invalidate_area71( area_name         = area_name
                           client            = l_client
                           client_supplied   = l_client_supplied
                           client_dependent  = _client_dependent
                           transactional     = _transactional
                           terminate_changer = terminate_changer
                           affect_server     = affect_server
                           life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-invalidate_area = abap_true.
      _trace_service-&gt;trin_invalidate_area(
        area_name         = area_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="Active version of one instance will be set to obsolete" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="F" DESCRIPT="Active writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method INVALIDATE_INSTANCE.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool value abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.


* &gt;
  rc = _invalidate_instance71(
    area_name         = area_name
    inst_name         = inst_name
    client            = l_client
    client_supplied   = l_client_supplied
    client_dependent  = _client_dependent
    transactional     = _transactional
    terminate_changer = terminate_changer
    affect_server     = affect_server
    life_context      = _life_context
  ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-invalidate_inst = abap_true.
      _trace_service-&gt;trin_invalidate_instance(
        area_name         = area_name
        inst_name         = inst_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="SET_ROOT" VERSION="1" LANGU="F" DESCRIPT="Sets Root Objects" EXPOSURE="2" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="SET_ROOT" SCONAME="ROOT" VERSION="1" LANGU="F" DESCRIPT="Root object" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_TASK_SHM_ROOT"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="SET_ROOT" SCONAME="CX_SHM_INITIAL_REFERENCE" VERSION="1" LANGU="F" DESCRIPT="Initial Reference Passed" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="SET_ROOT" SCONAME="CX_SHM_WRONG_HANDLE" VERSION="1" LANGU="F" DESCRIPT="Incorrect Handle" MTDTYPE="0" EDITORDER="2 "/>
   <source>method SET_ROOT.

  DATA:
    l_cx TYPE REF TO cx_root.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-set_root = abap_false.

*   &gt;
    _set_root( root ).
    me-&gt;root = root.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        _set_root( root ).
        me-&gt;root = root.
*       &lt;
        _trace_service-&gt;trin_set_root(
          area_name         = area_name
          inst_name         = inst_name
          root              = root
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_set_root(
          area_name         = area_name
          inst_name         = inst_name
          root              = root
          cx                = l_cx
        ).
    ENDTRY.

  ENDIF.

  endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_SHM" VERSION="1" LANGU="F" DESCRIPT="Tâche - Exploitation SHM" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_TASK_SHM" CMPNAME="TY_INSTANCE" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="7 " SRCCOLUMN2="23 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_instance,
      type     TYPE        shm_inst_name,
      instance TYPE REF TO zcl_task_shm,
    END OF   ty_instance
"/>
  <types CLSNAME="ZCL_TASK_SHM" CMPNAME="TY_T_INSTANCE" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="4 " SRCROW2="10 " SRCCOLUMN2="60 " TYPESRC_LENG="0 " TYPESRC="ty_t_instance TYPE SORTED TABLE OF ty_instance
                  WITH UNIQUE KEY primary_key COMPONENTS type
"/>
  <types CLSNAME="ZCL_TASK_SHM" CMPNAME="TY_SHM_AREA" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="12 " SRCCOLUMN1="4 " SRCROW2="15 " SRCCOLUMN2="23 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_shm_area,
      shm_area_name     TYPE        shm_inst_name,
      shm_area_instance TYPE REF TO zcl_task_shm_area,
    END OF   ty_shm_area
"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_TASK_SHM" CMPNAME="MS_SHM_AREA" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_SHM_AREA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_SHM" CMPNAME="MT_INSTANCE" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_T_INSTANCE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TASK_SHM" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CONSTRUCTOR" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="CONSTRUCTOR" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <source>METHOD constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_TASK_SHM                                      *
*&amp; Description     : Création instance pour utilisation SHM Task       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception  TYPE REF TO cx_root,
    lo_attach_write  TYPE REF TO zcl_task_shm_area,
    lo_task_shm_root TYPE REF TO zcl_task_shm_root.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Récupération version courante
      &quot; -----------------------------------------------------------

      &quot; Lecture de la version courante
      me-&gt;ms_shm_area-shm_area_name     = iv_type.
      me-&gt;ms_shm_area-shm_area_instance = zcl_task_shm_area=&gt;attach_for_read( me-&gt;ms_shm_area-shm_area_name ).

    CATCH cx_shm_no_active_version.
      &quot; Aucune version existante
      TRY.
          &quot;&quot;  --&gt; Création instance d&apos;écriture
          lo_attach_write = zcl_task_shm_area=&gt;attach_for_write( me-&gt;ms_shm_area-shm_area_name ).

          &quot;&quot;  --&gt; Création d&apos;une nouvelle version
          CREATE OBJECT lo_task_shm_root AREA HANDLE lo_attach_write.

          &quot;&quot;  --&gt; Initialisation de la version
          lo_attach_write-&gt;set_root( lo_task_shm_root ).

          &quot;&quot;  --&gt; Sauvegarde la version
          lo_attach_write-&gt;detach_commit( ).

          &quot;&quot;  --&gt; Récupère l&apos;instance de lecture
          me-&gt;ms_shm_area-shm_area_instance = zcl_task_shm_area=&gt;attach_for_read( me-&gt;ms_shm_area-shm_area_name ).

        CATCH cx_root INTO lo_cx_exception.
          &quot; Une erreur est survenue
          &quot;&quot;  --&gt; Lève l&apos;exception
          WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
          RAISE EXCEPTION lo_cx_exception.

      ENDTRY.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM" CMPNAME="GET_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="SHM - Récupération instance" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="GET_INSTANCE" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="GET_INSTANCE" SCONAME="RO_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="Tâche - Exploitation SHM" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK_SHM"/>
   <source>METHOD get_instance.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_TASK_SHM                                      *
*&amp; Description     : Création instance pour utilisation SHM Task       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_instance TYPE zcl_task_shm=&gt;ty_instance.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération version courante
  &quot; -----------------------------------------------------------

  READ TABLE zcl_task_shm=&gt;mt_instance WITH TABLE KEY type = CONV shm_inst_name( iv_type )
                                            ASSIGNING FIELD-SYMBOL(&lt;lfs_s_instance&gt;).
  IF sy-subrc NE 0.
    &quot; Instance non existante pour ce MF
    &quot;&quot;  --&gt; Création nouvelle entrée
    ls_instance-type = iv_type.

    &quot;&quot;  --&gt; Création de l&apos;instance
    CREATE OBJECT ls_instance-instance
      EXPORTING
        iv_type = iv_type.

    &quot;&quot;  --&gt; Ajout de l&apos;entrée
    INSERT ls_instance INTO TABLE zcl_task_shm=&gt;mt_instance ASSIGNING &lt;lfs_s_instance&gt;.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Retourne l&apos;instance
  &quot; -----------------------------------------------------------

  ro_instance = &lt;lfs_s_instance&gt;-instance.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM" CMPNAME="TASK_MANAGER_DEREGISTER" VERSION="1" LANGU="F" DESCRIPT="SHM - Désenregistrement Manager Tâche" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="TASK_MANAGER_DEREGISTER" SCONAME="IV_TASK_MANAGER_ID" VERSION="1" LANGU="F" DESCRIPT="ID Manager de Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTASK_MANAGER_ID"/>
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="TASK_MANAGER_DEREGISTER" SCONAME="RV_SUBRC" VERSION="1" LANGU="F" DESCRIPT="Zone système ABAP : code retour des instructions ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <exception CLSNAME="ZCL_TASK_SHM" CMPNAME="TASK_MANAGER_DEREGISTER" SCONAME="ZCX_TASK_SHM" VERSION="1" LANGU="F" DESCRIPT="Tâche - SHM - Classe exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD task_manager_deregister.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_DEREGISTER                                   *
*&amp; Classe          : ZCL_TASK_SHM                                      *
*&amp; Description     : Désenregistrement du Manager de Tâche             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception  TYPE REF TO cx_root,
    lo_attach_update TYPE REF TO zcl_task_shm_area.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_empty TYPE flag.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle présence de l&apos;ID
  &quot; -----------------------------------------------------------

  IF me-&gt;ms_shm_area-shm_area_instance-&gt;root-&gt;task_manager_is_registered( iv_task_manager_id ) EQ abap_false.
    &quot; ID inexistant
    &quot;&quot; --&gt; Ne rien faire
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Récupération version courante
  &quot; -----------------------------------------------------------

  TRY.
      &quot;&quot;  --&gt;  Récupération instance de mise à jour
*      me-&gt;ms_shm_area-shm_area_instance-&gt;detach( ).
      lo_attach_update = zcl_task_shm_area=&gt;attach_for_update( me-&gt;ms_shm_area-shm_area_name ).

      &quot;&quot;  --&gt; Suppression de l&apos;ID du Manager de Tâche
      lv_empty = lo_attach_update-&gt;root-&gt;task_manager_deregister( iv_task_manager_id ).

      &quot;&quot;  --&gt; Pousse la mise à jour
      lo_attach_update-&gt;detach_commit( ).

      IF me-&gt;ms_shm_area-shm_area_instance-&gt;is_active_version( ) EQ abap_false.
        &quot;&quot;  --&gt; Libère le Token courant
        me-&gt;ms_shm_area-shm_area_instance-&gt;detach( ).

        &quot;&quot;  --&gt; Recharge l&apos;instance de lecture
        me-&gt;ms_shm_area-shm_area_instance = zcl_task_shm_area=&gt;attach_for_read( me-&gt;ms_shm_area-shm_area_name ).

      ENDIF.

    CATCH cx_root INTO lo_cx_exception.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Retour code en erreur
      rv_subrc = 4.

      &quot;&quot;  --&gt; Lève l&apos;exception
      WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
      RAISE EXCEPTION TYPE zcx_task_shm
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

  IF lv_empty EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Suppression des SHMs inutilisées
    &quot; -----------------------------------------------------------

    TRY.
        &quot; Suppression de la Définition du Type dans la SHM
        zcl_type_definition=&gt;get_instance( )-&gt;definition_type_delete(
            iv_type              = me-&gt;ms_shm_area-shm_area_name
            iv_free_shm_if_empty = abap_true
        ).

      CATCH zcx_type_definition. &quot;#EC NOHANDLER
        &quot; Erreur suppression Type dans la SHM
        &quot;&quot;  --&gt; Tant pis ...

    ENDTRY.

    &quot; Suppression de l&apos;entrée dans la SHM des Tâches
    me-&gt;__internal_use_free_shm(
        iv_shm_area_name    = me-&gt;ms_shm_area-shm_area_name
        iv_areas_invalidate = abap_true
    ).

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM" CMPNAME="TASK_MANAGER_REGISTER" VERSION="1" LANGU="F" DESCRIPT="SHM - Enregistrement Manager Tâche" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="TASK_MANAGER_REGISTER" SCONAME="IV_TASK_MANAGER_ID" VERSION="1" LANGU="F" DESCRIPT="ID Manager de Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTASK_MANAGER_ID"/>
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="TASK_MANAGER_REGISTER" SCONAME="RV_SUBRC" VERSION="1" LANGU="F" DESCRIPT="Zone système ABAP : code retour des instructions ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <source>METHOD task_manager_register.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_MANAGER_REGISTER                             *
*&amp; Classe          : ZCL_TASK_SHM                                      *
*&amp; Description     : Enregistrement du Manager de Tâche                *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception  TYPE REF TO cx_root,
    lo_attach_update TYPE REF TO zcl_task_shm_area.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle Manager de Tâche existante
  &quot; -----------------------------------------------------------

  &quot; Détermine si le Manager de Tâche est enregistrée sur la SHM
  IF me-&gt;ms_shm_area-shm_area_instance-&gt;root-&gt;task_manager_is_registered( iv_task_manager_id ) EQ abap_true.
    &quot; Manager de Tâche existe déjà
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Ajout du Manager de Tâche
  &quot; -----------------------------------------------------------

  TRY.
      &quot;&quot;  --&gt;  Récupération instance de mise à jour
      lo_attach_update = zcl_task_shm_area=&gt;attach_for_update( me-&gt;ms_shm_area-shm_area_name ).

      &quot;&quot;  --&gt; Ajout de l&apos;ID de Manager Tâche
      lo_attach_update-&gt;root-&gt;task_manager_register( iv_task_manager_id ).

      &quot;&quot;  --&gt; Pousse la mise à jour
      lo_attach_update-&gt;detach_commit( ).

      IF me-&gt;ms_shm_area-shm_area_instance-&gt;is_active_version( ) EQ abap_false.
        &quot;&quot;  --&gt; Libère le Token courant
        me-&gt;ms_shm_area-shm_area_instance-&gt;detach( ).

        &quot;&quot;  --&gt; Recharge l&apos;instance de lecture
        me-&gt;ms_shm_area-shm_area_instance = zcl_task_shm_area=&gt;attach_for_read( me-&gt;ms_shm_area-shm_area_name ).

      ENDIF.

    CATCH cx_root INTO lo_cx_exception.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Retour code en erreur
      rv_subrc = 4.

      &quot;&quot;  --&gt; Lève l&apos;exception
      WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
      RAISE EXCEPTION lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM" CMPNAME="__INTERNAL_USE_FREE_SHM" VERSION="1" LANGU="F" DESCRIPT="SHM - Suppression toutes versions" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="IV_SHM_AREA_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom d&apos;une instance d&apos;objet partagé d&apos;un domaine" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="IV_AREAS_DETACH" VERSION="1" LANGU="F" DESCRIPT="Libére les Tokens" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="IV_AREAS_FREE" VERSION="1" LANGU="F" DESCRIPT="Supprime les Versions" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="IV_AREAS_INVALIDATE" VERSION="1" LANGU="F" DESCRIPT="Invalide les Versions" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="RV_RC" VERSION="1" LANGU="F" DESCRIPT="Valeur de retour (constantes dans CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <source>METHOD __internal_use_free_shm.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __INTERNAL_USE_FREE_SHM                           *
*&amp; Classe          : ZCL_TASK_SHM                                      *
*&amp; Description     : Usage Interne : Suppression toutes versions       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  IF NOT iv_shm_area_name IS INITIAL.
    &quot; -----------------------------------------------------------
    &quot; Libération de la Version spécifiée
    &quot; -----------------------------------------------------------

    IF iv_areas_free EQ abap_true.
      &quot; -----------------------------------------------------------
      &quot; Libération de la Version
      &quot; -----------------------------------------------------------

      TRY.
          &quot; Libération de la Version
          rv_rc = zcl_task_shm_area=&gt;free_instance( iv_shm_area_name ).

        CATCH cx_shm_parameter_error.
          &quot; Une erreur est survenue
          rv_rc = cl_shm_area=&gt;rc_nothing_to_be_done.

      ENDTRY.

    ELSEIF iv_areas_invalidate EQ abap_true.
      &quot; -----------------------------------------------------------
      &quot; Invalidation de la Version
      &quot; -----------------------------------------------------------

      TRY.
          &quot; Invalide de la Version
          rv_rc = zcl_task_shm_area=&gt;invalidate_instance( iv_shm_area_name ).

        CATCH cx_shm_parameter_error.
          rv_rc = cl_shm_area=&gt;rc_nothing_to_be_done.

      ENDTRY.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Suppression de l&apos;instance globale
    &quot; -----------------------------------------------------------

    &quot; Suppression de l&apos;entrée dans la globale
    READ TABLE zcl_task_shm=&gt;mt_instance WITH TABLE KEY type = iv_shm_area_name
                                           TRANSPORTING NO FIELDS.
    IF sy-subrc EQ 0.
      &quot; Suppression de l&apos;entrée
      DELETE zcl_task_shm=&gt;mt_instance INDEX sy-tabix.

    ENDIF.

  ELSE.
    IF iv_areas_free EQ abap_true.
      &quot; -----------------------------------------------------------
      &quot; Libération des Versions
      &quot; -----------------------------------------------------------

      TRY.
          &quot; Libération des Versions
          rv_rc = zcl_task_shm_area=&gt;free_area( ).

        CATCH cx_shm_parameter_error.
          &quot; Une erreur est survenue
          rv_rc = cl_shm_area=&gt;rc_nothing_to_be_done.

      ENDTRY.

    ELSEIF iv_areas_invalidate EQ abap_true.
      &quot; -----------------------------------------------------------
      &quot; Invalidation des Versions
      &quot; -----------------------------------------------------------

      TRY.
          &quot; Invalide les Versions
          rv_rc = zcl_task_shm_area=&gt;invalidate_area( ).

        CATCH cx_shm_parameter_error.
          rv_rc = cl_shm_area=&gt;rc_nothing_to_be_done.

      ENDTRY.

    ELSEIF iv_areas_detach EQ abap_true.
      &quot; -----------------------------------------------------------
      &quot; Livération des Tokens
      &quot; -----------------------------------------------------------

      &quot; Libération des Tokens
      rv_rc = zcl_task_shm_area=&gt;detach_all_areas( ).

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Suppression des instances globale
    &quot; -----------------------------------------------------------

    FREE : zcl_task_shm=&gt;mt_instance.

  ENDIF.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_PARAM" VERSION="1" LANGU="F" DESCRIPT="Tâche - Exploitation paramétrage" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_TASK_PARAM" CMPNAME="TY_T_ZTASK_FUNC_PARAM" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="4 " SRCCOLUMN2="110 " TYPESRC_LENG="0 " TYPESRC="ty_t_ZTASK_FUNC_PARAM TYPE SORTED TABLE OF ZTASK_FUNC_PARAM WITH UNIQUE KEY PRIMARY_KEY COMPONENTS funcname
"/>
  <types CLSNAME="ZCL_TASK_PARAM" CMPNAME="TY_TASK_FUNCTION_PARAM" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="6 " SRCROW2="13 " SRCCOLUMN2="36 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_task_function_param.
            INCLUDE TYPE ztec_s_task_trace_param.
    TYPES :
      shm_management TYPE ztask_func_param-shm_management,
      END OF   ty_task_function_param
"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_TASK_PARAM" CMPNAME="MT_ZTASK_FUNC_PARAM" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_T_ZTASK_FUNC_PARAM" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TASK_PARAM" CMPNAME="CLASS_CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CLASS_CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD class_constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CLASS_CONSTRUCTOR                                 *
*&amp; Classe          : ZCL_TASK_PARAM                                    *
*&amp; Description     : Constructeur statique                             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération des données de la table de paramétrage
  &quot; -----------------------------------------------------------

  SELECT * FROM ztask_func_param INTO TABLE zcl_task_param=&gt;mt_ztask_func_param.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_PARAM" CMPNAME="TASK_PARAM_GET" VERSION="1" LANGU="F" DESCRIPT="Récupération paramétrage" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_PARAM" CMPNAME="TASK_PARAM_GET" SCONAME="IV_FUNCTION_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom du module fonction" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="RS38L_FNAM"/>
   <parameter CLSNAME="ZCL_TASK_PARAM" CMPNAME="TASK_PARAM_GET" SCONAME="RS_PARAM" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_TASK_FUNCTION_PARAM"/>
   <source>METHOD task_param_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_PARAM_GET                                    *
*&amp; Classe          : ZCL_TASK_PARAM                                    *
*&amp; Description     : Récupération paramétrage                          *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_ztask_func_param TYPE ztask_func_param.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Récupération entrée correpsondante
      &quot; -----------------------------------------------------------

      &quot; Retourne l&apos;indicateur d&apos;activation de la Trace sur le MF
      MOVE-CORRESPONDING zcl_task_param=&gt;mt_ztask_func_param[ funcname = iv_function_name ] TO rs_param.

    CATCH cx_sy_itab_line_not_found.
      &quot; Aucune correspondance
      &quot;&quot;  --&gt; Récupération de l&apos;entrée en DB
      SELECT SINGLE * FROM ztask_func_param &quot;Table bufferisée en DB
                      INTO ls_ztask_func_param
                     WHERE funcname EQ iv_function_name.
      IF sy-subrc NE 0.
        &quot; Aucune correspondance
        &quot;&quot;  --&gt; Force l&apos;ajout dans table statique pour éviter recherche ultérieur
        ls_ztask_func_param-funcname = iv_function_name.

      ENDIF.

      &quot; Ajout de l&apos;entrée
      INSERT ls_ztask_func_param INTO TABLE zcl_task_param=&gt;mt_ztask_func_param.

      &quot; Retourne le paramétrage
      MOVE-CORRESPONDING ls_ztask_func_param TO rs_param.

  ENDTRY.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Gestion Processus //" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZTASK" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TY_TFDIR" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="7 " SRCCOLUMN2="20 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_tfdir,
      funcname  TYPE tfdir-funcname,
      not_found TYPE flag,
    END OF   ty_tfdir
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TY_T_TFDIR" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="4 " SRCROW2="10 " SRCCOLUMN2="72 " TYPESRC_LENG="0 " TYPESRC="ty_t_tfdir TYPE SORTED TABLE OF ty_tfdir
                          WITH UNIQUE KEY primary_key COMPONENTS funcname
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TY_RZLLITAB" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="12 " SRCCOLUMN1="4 " SRCROW2="15 " SRCCOLUMN2="23 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_rzllitab,
      classname TYPE rzllitab-classname,
      not_found TYPE flag,
    END OF   ty_rzllitab
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TY_T_RZLLITAB" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="17 " SRCCOLUMN1="4 " SRCROW2="18 " SRCCOLUMN2="76 " TYPESRC_LENG="0 " TYPESRC="ty_t_rzllitab TYPE SORTED TABLE OF ty_rzllitab
                             WITH UNIQUE KEY primary_key COMPONENTS classname
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TY_TASK_MANAGER_DATA" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="5 " TYPTYPE="4" SRCROW1="20 " SRCCOLUMN1="4 " SRCROW2="28 " SRCCOLUMN2="32 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_task_manager_data,
      task_manager_id          TYPE        ztask_manager_id,
      shm_management           TYPE        zshm_management,
      t_task_list              TYPE        zcl_task_manager=&gt;ty_t_task_list,
      t_definition_type_in_shm TYPE        stringtab,
      o_task_trace             TYPE REF TO zcl_task_trace,
      o_task_handler           TYPE REF TO zcl_task_handler,
      task_trace_param         TYPE        ztec_s_task_trace_param,
    END OF   ty_task_manager_data
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TY_TASK" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="11 " SRCCOLUMN1="4 " SRCROW2="15 " SRCCOLUMN2="21 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_task,
        task_id      TYPE zcl_task=&gt;ty_task-task_id,
        task_running TYPE zcl_task=&gt;ty_task-task_running,
        process_data TYPE REF TO data,
      END OF   ty_task
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TY_T_TASK" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="17 " SRCCOLUMN1="4 " SRCROW2="18 " SRCCOLUMN2="72 " TYPESRC_LENG="0 " TYPESRC="ty_t_task TYPE SORTED TABLE OF ty_task
                           WITH UNIQUE KEY primary_key COMPONENTS task_id
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TY_TASK_LIST" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="20 " SRCCOLUMN1="4 " SRCROW2="24 " SRCCOLUMN2="24 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_task_list,
      task_id       TYPE        zcl_task=&gt;ty_task-task_id,
      task_running  TYPE REF TO zcl_task=&gt;ty_task-task_running,
      task_instance TYPE REF TO zcl_task,
    END OF   ty_task_list
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TY_T_TASK_LIST" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="26 " SRCCOLUMN1="4 " SRCROW2="27 " SRCCOLUMN2="75 " TYPESRC_LENG="0 " TYPESRC="ty_t_task_list TYPE SORTED TABLE OF ty_task_list
                              WITH UNIQUE KEY primary_key COMPONENTS task_id
"/>
  <friends CLSNAME="ZCL_TASK_MANAGER" REFCLSNAME="ZCL_TASK_HANDLER" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <events CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MANAGER_END_OF_TASK" VERSION="1" LANGU="F" DESCRIPT="Evènement fin d&apos;une Tâche" EXPOSURE="0" STATE="1" EDITORDER="1 " EVTDECLTYP="0" BCEVTCAT="00">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MANAGER_END_OF_TASK" SCONAME="IV_FUNCTION_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom de fonction" CMPTYPE="2" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="RS38L_FNAM" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MANAGER_END_OF_TASK" SCONAME="IT_RESULT" VERSION="1" LANGU="F" DESCRIPT="Table de retour" CMPTYPE="2" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TY_T_FUNCTION_PARAMETERS" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MANAGER_END_OF_TASK" SCONAME="IT_ATTACHED_DATA" VERSION="1" LANGU="F" DESCRIPT="Données liées à la Tâche" CMPTYPE="2" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TY_T_TASK_ATTACHED_DATA" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MANAGER_END_OF_TASK" SCONAME="IV_ERROR" VERSION="1" LANGU="F" DESCRIPT="Une erreur est survenue ?" CMPTYPE="2" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
  </events>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>*&quot;* use this source file for your ABAP unit test classes</localTestClasses>
  <attribute CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MS_TASK_MANAGER_DATA" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TASK_MANAGER_DATA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MT_RZLLITAB" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_TASK_MANAGER=&gt;TY_T_RZLLITAB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MT_TFDIR" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_TASK_MANAGER=&gt;TY_T_TFDIR" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="AT_END_OF_TASK" VERSION="1" LANGU="F" DESCRIPT="Traitement lors de la fin d&apos;une Tâche" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="AT_END_OF_TASK" SCONAME="IO_TASK" VERSION="1" LANGU="F" DESCRIPT="Instance Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_TASK"/>
   <source>METHOD at_end_of_task.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : AT_END_OF_TASK                                    *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Traitement lors de la fin d&apos;une Tâche             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  IF me-&gt;ms_task_manager_data-shm_management   EQ abap_true
  OR io_task-&gt;ms_task_data-shm_manage_by_local EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Stockage des types enregistré dans la SHM
    &quot; -----------------------------------------------------------

    IF NOT io_task-&gt;ms_task_data-task_process-t_definition_type_in_shm[] IS INITIAL.
      &quot; Récupération Liste des Types stockées dans la SHM par la Tâche
      LOOP AT io_task-&gt;ms_task_data-task_process-t_definition_type_in_shm ASSIGNING FIELD-SYMBOL(&lt;lfs_s_definition_type&gt;).

        &quot; Ajout des types utilisés par la Tâche
        READ TABLE me-&gt;ms_task_manager_data-t_definition_type_in_shm WITH KEY table_line = &lt;lfs_s_definition_type&gt;
                                                                 TRANSPORTING NO FIELDS BINARY SEARCH.
        IF sy-subrc NE 0.
          &quot; Type pas encore récupéré
          &quot;&quot;  --&gt; Ajout du Type
          INSERT &lt;lfs_s_definition_type&gt; INTO me-&gt;ms_task_manager_data-t_definition_type_in_shm INDEX sy-tabix.

        ENDIF.

      ENDLOOP.

    ENDIF.

  ENDIF.

  IF NOT io_task-&gt;ms_task_data-task_trace_id IS INITIAL.
    &quot; -----------------------------------------------------------
    &quot; Fin de la Trace d&apos;exécution
    &quot; -----------------------------------------------------------

    &quot; Arrêt de la Trace d&apos;exécution
    me-&gt;task_trace_stop(
      iv_task_trace_id = io_task-&gt;ms_task_data-task_trace_id
      iv_log_immediate = abap_true
    ).

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Libère la Tâche
  &quot; -----------------------------------------------------------

  &quot; Libère la Tâche et réinitialise ses données
  io_task-&gt;task_free( ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CHECK" VERSION="1" LANGU="F" DESCRIPT="Contrôle des paramétres" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CHECK" SCONAME="IV_GRFC" VERSION="1" LANGU="F" DESCRIPT="Groupe de serveurs RFC pour traitement paralléle" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="RFCGR"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CHECK" SCONAME="IV_USE_DEFAULT_GROUP" VERSION="1" LANGU="F" DESCRIPT="Utilisation groupe RFC par défaut" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CHECK" SCONAME="IV_FUNCTION_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom du module fonction" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="RS38L_FNAM" PAROPTIONL="X"/>
   <exception CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CHECK" SCONAME="ZCX_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Manager Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD check.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CHECK                                             *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Contrôle paramètère //                            *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_tfdir    TYPE ty_tfdir,
    ls_textid   TYPE scx_t100key,
    ls_rzllitab TYPE ty_rzllitab.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  IF iv_use_default_group EQ abap_false.
    &quot; -----------------------------------------------------------
    &quot; Contrôle Groupe de Serveur
    &quot; -----------------------------------------------------------

    &quot; Récupération entrée sur Groupe de Serveur
    READ TABLE zcl_task_manager=&gt;mt_rzllitab WITH TABLE KEY classname = iv_grfc
                                                  ASSIGNING FIELD-SYMBOL(&lt;lfs_s_rzllitab&gt;).
    IF sy-subrc NE 0.
      &quot; Entrée non encore référencé
      &quot;&quot;  --&gt; Recherche le Groupe de Serveur
      SELECT classname FROM rzllitab UP TO 1 ROWS
                       INTO ls_rzllitab-classname
                      WHERE classname EQ iv_grfc.
      ENDSELECT.
      IF sy-subrc NE 0.
        &quot; Le Groupe de Serveur n&apos;existe pas
        &quot;&quot;  --&gt; Initialisation structure
        ls_rzllitab-classname = iv_grfc.
        ls_rzllitab-not_found = abap_true.

      ENDIF.

      &quot; Ajout de l&apos;entrée
      INSERT ls_rzllitab INTO TABLE zcl_task_manager=&gt;mt_rzllitab ASSIGNING &lt;lfs_s_rzllitab&gt;.

    ENDIF.

    IF &lt;lfs_s_rzllitab&gt; IS ASSIGNED AND &lt;lfs_s_rzllitab&gt;-not_found EQ abap_true.
      &quot; Le Groupe de Serveur n&apos;existe pas
      &quot;&quot;  --&gt; Lève une Exception
      ls_textid-msgid = zif_task_constant=&gt;mc_message_class_id.
      ls_textid-msgno = 105.
      ls_textid-attr1 = iv_grfc.
      RAISE EXCEPTION TYPE zcx_task_manager
        EXPORTING
          textid = ls_textid.

    ENDIF.

    &quot; Contrôle Initialisation Groupe de Serveur
    CALL FUNCTION &apos;SPBT_INITIALIZE&apos;
      EXPORTING
        group_name                     = iv_grfc
      EXCEPTIONS
        invalid_group_name             = 3
        internal_error                 = 2
        pbt_env_already_initialized    = 1
        currently_no_resources_avail   = 1
        no_pbt_resources_found         = 4
        cant_init_different_pbt_groups = 6
        OTHERS                         = 7.
    IF sy-subrc GT 1.
      &quot; Erreur création Groupe de //
      &quot;&quot;  --&gt; Lève une Exception
      ls_textid-msgid = sy-msgid.
      ls_textid-msgno = sy-msgty.
      ls_textid-msgno = sy-msgno.
      ls_textid-attr1 = sy-msgv1.
      ls_textid-attr2 = sy-msgv2.
      ls_textid-attr3 = sy-msgv3.
      ls_textid-attr4 = sy-msgv4.
      RAISE EXCEPTION TYPE zcx_task_manager
        EXPORTING
          textid = ls_textid.

    ENDIF.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Contrôle Module Fonction
  &quot; -----------------------------------------------------------

  IF NOT iv_function_name IS INITIAL.
    &quot; Récupération entrée sur MF
    READ TABLE zcl_task_manager=&gt;mt_tfdir WITH TABLE KEY funcname = iv_function_name
                                               ASSIGNING FIELD-SYMBOL(&lt;lfs_s_tfdir&gt;).
    IF sy-subrc NE 0.
      &quot;&quot;  --&gt; Recherche l&apos;existence du MF
      SELECT SINGLE funcname FROM tfdir
                             INTO ls_tfdir-funcname
                            WHERE funcname EQ iv_function_name.
      IF sy-subrc NE 0.
        &quot; Le MF n&apos;existe pas
        &quot;&quot;  --&gt; Initialisation structure
        ls_tfdir-funcname  = iv_function_name.
        ls_tfdir-not_found = abap_true.

      ENDIF.

      &quot; Ajout de l&apos;entrée
      INSERT ls_tfdir INTO TABLE zcl_task_manager=&gt;mt_tfdir ASSIGNING &lt;lfs_s_tfdir&gt;.

    ENDIF.

    IF &lt;lfs_s_tfdir&gt; IS ASSIGNED AND &lt;lfs_s_tfdir&gt;-not_found EQ abap_true.
      &quot; Le MF n&apos;existe pas
      &quot;&quot;  --&gt; Lève une exception
      ls_textid-msgid = zif_task_constant=&gt;mc_message_class_id.
      ls_textid-msgno = 104.
      ls_textid-attr1 = iv_function_name.
      RAISE EXCEPTION TYPE zcx_task_manager
        EXPORTING
          textid = ls_textid.

    ENDIF.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CONSTRUCTOR" SCONAME="IV_GRFC" VERSION="1" LANGU="F" DESCRIPT="Groupe de serveurs RFC pour traitement paralléle" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="RFCGR" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CONSTRUCTOR" SCONAME="IV_TASK_MAX" VERSION="1" LANGU="F" DESCRIPT="Nombre de Tâche maximum" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="NUMERIC"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CONSTRUCTOR" SCONAME="IV_MANAGE_SHM" VERSION="1" LANGU="F" DESCRIPT="SHM - Gestion de la SHM" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="ZSHM_MANAGEMENT" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CONSTRUCTOR" SCONAME="IV_FUNCTION_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom du module fonction" CMPTYPE="1" MTDTYPE="2" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="RS38L_FNAM" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CONSTRUCTOR" SCONAME="IS_PROCESS_BY_FORM" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement par Routine" CMPTYPE="1" MTDTYPE="2" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_PROCESS_BY_FORM" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CONSTRUCTOR" SCONAME="IS_PROCESS_BY_METHOD" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement par Méthode" CMPTYPE="1" MTDTYPE="2" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_PROCESS_BY_METHOD" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CONSTRUCTOR" SCONAME="IS_TASK_TRACE_PARAM" VERSION="1" LANGU="F" DESCRIPT="Tâche - Paramètre de Trace" CMPTYPE="1" MTDTYPE="2" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_TRACE_PARAM" PAROPTIONL="X"/>
   <exception CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CONSTRUCTOR" SCONAME="ZCX_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Manager Tâche" MTDTYPE="2" EDITORDER="1 "/>
   <source>METHOD constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Constructeur instance                             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_textid    TYPE scx_t100key,
    ls_task_list TYPE zcl_task_manager=&gt;ty_task_list.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception TYPE REF TO cx_root.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Note d&apos;utilisation :
  &quot;   Si le nom de fonction est renseigné, il est transmis
  &quot;     aux Tâches. Par conséquent, ces Tâches ne pourront
  &quot;     exécuter que ce MF.
  &quot;   Dans le cas contraire, chaque Tâche peut lancer
  &quot;     un MF différent mais le code MF devient alors
  &quot;     obligatoire lors de l&apos;appel de &quot;TASK_START_NEW&quot;
  &quot; -----------------------------------------------------------

  IF iv_task_max IS INITIAL.
    &quot; Aucune Tâche à  créer
    &quot;&quot;  --&gt; Lève une Exception
    ls_textid-msgid = zif_task_constant=&gt;mc_message_class_id.
    ls_textid-msgno = 102.
    RAISE EXCEPTION TYPE zcx_task_manager
      EXPORTING
        textid = ls_textid.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Contrôle des données
      &quot; -----------------------------------------------------------
      me-&gt;check(
        iv_grfc              = iv_grfc
        iv_use_default_group = boolc( iv_grfc IS INITIAL )  &quot;Vrai si pas de groupe de serveur valorisé
        iv_function_name     = iv_function_name
      ).

    CATCH zcx_task_manager INTO lo_cx_exception.
      &quot; Les données ne sont pas cohérentes
      &quot;&quot;  --&gt; Lève une Exception
      RAISE EXCEPTION TYPE zcx_task_manager
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Génération ID Manager
      &quot; -----------------------------------------------------------

      &quot; Génération GUID Manager
      me-&gt;ms_task_manager_data-task_manager_id = cl_system_uuid=&gt;create_uuid_c32_static( ).

    CATCH cx_uuid_error.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; GUID aléatoire
      me-&gt;ms_task_manager_data-task_manager_id = cl_abap_random=&gt;seed( ).

  ENDTRY.

  &quot; -----------------------------------------------------------
  &quot; Création des Tâches
  &quot; -----------------------------------------------------------

  &quot; Création d&apos;autant de Tâche que nécessaire
  DO iv_task_max TIMES.

    FREE : ls_task_list.

    TRY.
        &quot;&quot;  --&gt; Création d&apos;une instance de Tâche
        CREATE OBJECT ls_task_list-task_instance
          EXPORTING
            iv_grfc            = iv_grfc
            iv_function_name   = iv_function_name
            iv_manage_shm      = iv_manage_shm
            iv_task_manager_id = me-&gt;ms_task_manager_data-task_manager_id.

      CATCH zcx_task INTO lo_cx_exception.
        &quot; Erreur création Tâche
        &quot;&quot;  --&gt; Passe à l&apos;itération suivante
        CONTINUE.

    ENDTRY.

    &quot;&quot;  --&gt; Initialisation ID de la Tâche
    ls_task_list-task_id = ls_task_list-task_instance-&gt;ms_task_data-task_id.

    &quot;&quot;  --&gt; Initialisation &quot;pointeur&quot; sur l&apos;indicateur de traitement de la Tâche
    ls_task_list-task_running = REF #( ls_task_list-task_instance-&gt;ms_task_data-task_running ).

    &quot;&quot;  --&gt; Ajout de la Tâche
    INSERT ls_task_list INTO TABLE me-&gt;ms_task_manager_data-t_task_list.

    &quot;&quot;  --&gt; Souscription aux évènements de :
    SET HANDLER me-&gt;handler_task_end          FOR ls_task_list-task_instance.  &quot;Fin de Tâche
    SET HANDLER me-&gt;handler_task_error_result FOR ls_task_list-task_instance.  &quot;Tâche en erreur

  ENDDO.

  &quot; -----------------------------------------------------------
  &quot; Création de l&apos;Handler
  &quot; -----------------------------------------------------------

  TRY.
      &quot; Création de l&apos;instance Handler de la Tâche
      me-&gt;ms_task_manager_data-o_task_handler = zcl_task_handler=&gt;handler_factory(
          io_task_manager      = me
          is_process_by_form   = is_process_by_form
          is_process_by_method = is_process_by_method
      ).

    CATCH cx_root INTO lo_cx_exception. &quot;#EC CATCH_ALL
      &quot; Une erreur est survenue
      RAISE EXCEPTION TYPE zcx_task_manager
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

  &quot; -----------------------------------------------------------
  &quot; Initialisation autres attributs
  &quot; -----------------------------------------------------------

  IF is_task_trace_param IS SUPPLIED.
    &quot; Initialisation Paramètre de Trace
    me-&gt;ms_task_manager_data-task_trace_param = is_task_trace_param.

  ENDIF.

  &quot; Initialisation Programme Appelant
*  me-&gt;ms_task_manager_data-caller = . &quot;ToDo

  IF me-&gt;ms_task_manager_data-task_trace_param-trace_active EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Création instance pour tracer exécution Tâche
    &quot; -----------------------------------------------------------

    &quot; Création instance Trace
    CREATE OBJECT me-&gt;ms_task_manager_data-o_task_trace.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Traitement de fin
  &quot; -----------------------------------------------------------

  IF me-&gt;ms_task_manager_data-t_task_list[] IS INITIAL.
    &quot; Aucune Tâche n&apos;a été créée
    &quot;&quot;  --&gt; Lève une Exception
    ls_textid-msgid = zif_task_constant=&gt;mc_message_class_id.
    ls_textid-msgno = 103.
    RAISE EXCEPTION TYPE zcx_task_manager
      EXPORTING
        textid = ls_textid.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="HANDLER_TASK_END" VERSION="1" LANGU="F" DESCRIPT="Handler - Fin d&apos;une Tâche" EXPOSURE="0" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="1" MTDDECLTYP="0" REFCLSNAME="ZCL_TASK" REFCMPNAME="TASK_END" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="HANDLER_TASK_END" SCONAME="IO_TASK" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="1" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="0"/>
   <source>METHOD handler_task_end.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : HANDLER_TASK_END                                  *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Handler sur évènement ZCL_TASK=&gt;TASK_END          *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Retourne les données
  &quot; -----------------------------------------------------------

  &quot; Lève évènement pour exporter les données
  RAISE EVENT manager_end_of_task
    EXPORTING
      iv_error         = abap_false
      iv_function_name = io_task-&gt;ms_task_data-task_process-function_name
      it_result        = io_task-&gt;ms_task_data-task_process-task_container-&gt;mt_function_parameters_output
      it_attached_data = io_task-&gt;ms_task_data-task_process-task_container-&gt;mt_attached_data.

  &quot; -----------------------------------------------------------
  &quot; Traitement fin d&apos;une Tâche
  &quot; -----------------------------------------------------------

  &quot; Traitement fin d&apos;une Tâche
  me-&gt;at_end_of_task( io_task ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="HANDLER_TASK_ERROR_RESULT" VERSION="1" LANGU="F" DESCRIPT="Handler - Erreur Tâche" EXPOSURE="0" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="1" MTDDECLTYP="0" REFCLSNAME="ZCL_TASK" REFCMPNAME="TASK_ERROR_RECEIVE_RESULT" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="HANDLER_TASK_ERROR_RESULT" SCONAME="IO_TASK" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="1" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="0"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="HANDLER_TASK_ERROR_RESULT" SCONAME="IS_TEXTID" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="1" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="0"/>
   <source>METHOD handler_task_error_result.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : HANDLER_TASK_ERROR                                *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Handler sur évènement ZCL_TASK=&gt;TASK_ERROR        *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_result TYPE zif_task_constant=&gt;ty_t_function_parameters.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_result TYPE zif_task_constant=&gt;ty_function_parameters.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Retourne les données
  &quot; -----------------------------------------------------------

  &quot; Ajout de l&apos;erreur dans la table des résultats
  ls_result-parameter_name = zif_task_constant=&gt;mc_parameter_name_error.
  ls_result-parameter_data = REF #( is_textid ).
  APPEND ls_result TO lt_result.

  &quot; Lève évènement pour exporter les données
  RAISE EVENT manager_end_of_task             &quot;A destination de ZCL_TASK_HANDLER
    EXPORTING
      iv_error         = abap_true
      iv_function_name = io_task-&gt;ms_task_data-task_process-function_name
      it_result        = lt_result
      it_attached_data = io_task-&gt;ms_task_data-task_process-task_container-&gt;mt_attached_data.

  &quot; -----------------------------------------------------------
  &quot; Traitement fin d&apos;une Tâche
  &quot; -----------------------------------------------------------

  &quot; Traitement fin d&apos;une Tâche
  me-&gt;at_end_of_task( io_task ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_CONTAINER_CREATE" VERSION="1" LANGU="F" DESCRIPT="Création nouveau Container" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_CONTAINER_CREATE" SCONAME="RO_TASK_CONTAINER" VERSION="1" LANGU="F" DESCRIPT="Container paramètres d&apos;appel" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK_CONTAINER"/>
   <source>METHOD task_container_create.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Création nouveau Container d&apos;appel
  &quot; -----------------------------------------------------------

  CREATE OBJECT ro_task_container.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_FINISH_RUNNING" VERSION="1" LANGU="F" DESCRIPT="Fin de toutes les Tâches lancées" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD task_finish_running.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_FINISH_RUNNING                               *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Permet de clôre toutes les Tâches                 *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_task TYPE REF TO zcl_task.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Attente de la fin de toutes les Tâches en cours
  &quot; -----------------------------------------------------------

  DO.
    &quot; Recherche si au moins une Tâche occupée
    LOOP AT me-&gt;ms_task_manager_data-t_task_list TRANSPORTING NO FIELDS
                                                        WHERE task_running-&gt;* = abap_true         &quot;Tâche en cours de traitement
                                                           OR task_running-&gt;* = abap_undefined.   &quot;Tâche en cours de préparation
      &quot;&quot;  --&gt; Au moins une Tâche occupé
      EXIT.
    ENDLOOP.
    IF sy-subrc NE 0.
      &quot; Aucune Tâche en cours de traitement
      &quot;&quot;  --&gt; Arrêt du traitement
      EXIT.

    ENDIF.

    &quot; Attente de fin de traitement d&apos;une Tâche
    WAIT FOR ASYNCHRONOUS TASKS UNTIL lo_task IS BOUND UP TO 1 SECONDS.   &quot;La condition est volontairement fausse afin de traiter tous les appels asynchrone
    IF sy-subrc EQ 0.   &quot;#EC NEEDED
      &quot; Condition vraie

    ENDIF.

  ENDDO.

  &quot; -----------------------------------------------------------
  &quot; Libération de la SHM
  &quot; -----------------------------------------------------------

  IF NOT me-&gt;ms_task_manager_data-t_definition_type_in_shm[] IS INITIAL. &quot;Alimenté uniquement si Gestion de la SHM activée
    &quot; Récupération Liste des Types stockées dans la SHM par la Tâche
    LOOP AT ms_task_manager_data-t_definition_type_in_shm ASSIGNING FIELD-SYMBOL(&lt;lfs_s_definition_type&gt;).

      TRY.
          &quot; Désenregistrement de la Tâche
          zcl_task_shm=&gt;get_instance( &lt;lfs_s_definition_type&gt; )-&gt;task_manager_deregister( me-&gt;ms_task_manager_data-task_manager_id ).

        CATCH zcx_task_shm.
          &quot; Erreur lors de la libération de la SHM
          &quot;&quot;  --&gt; Tant pis...
          CONTINUE.

      ENDTRY.

    ENDLOOP.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_GET_FREE" VERSION="1" LANGU="F" DESCRIPT="Récupération Tâche disponible" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_GET_FREE" SCONAME="RO_TASK" VERSION="1" LANGU="F" DESCRIPT="Instance Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK"/>
   <source>METHOD task_get_free.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_GET_FREE                                     *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Récupération d&apos;une Tâche disponible               *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération d&apos;une Tâche finie
  &quot; -----------------------------------------------------------

  TRY.
      &quot; Récupération instance de la Tâche
      ro_task = me-&gt;ms_task_manager_data-t_task_list[ task_running-&gt;* = abap_false ]-task_instance.

    CATCH cx_sy_itab_line_not_found.
      &quot; Aucune Tâche finie
      FREE : ro_task.

    CATCH cx_root.                                      &quot;&quot;#EC CATCH_ALL #EC NO_HANDLER
      &quot; Autre erreur

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_START_NEW" VERSION="1" LANGU="F" DESCRIPT="Lancement nouvelle Tâche" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_START_NEW" SCONAME="IV_FUNCTION_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom du module fonction" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="RS38L_FNAM" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_START_NEW" SCONAME="IS_TASK_TRACE_PARAM" VERSION="1" LANGU="F" DESCRIPT="Tâche - Paramètre de Trace" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_TRACE_PARAM" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_START_NEW" SCONAME="IT_FUNCTION_PARAMETERS" VERSION="1" LANGU="F" DESCRIPT="Paramètres d&apos;appel" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TY_T_FUNCTION_PARAMETERS" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_START_NEW" SCONAME="IT_ATTACHED_DATA" VERSION="1" LANGU="F" DESCRIPT="Données liées à la Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TY_T_TASK_ATTACHED_DATA" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_START_NEW" SCONAME="IO_TASK_CONTAINER" VERSION="1" LANGU="F" DESCRIPT="Container paramètres d&apos;appel" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_TASK_CONTAINER" PAROPTIONL="X"/>
   <exception CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_START_NEW" SCONAME="ZCX_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD task_start_new.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_START_NEW                                    *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Début d&apos;une nouvelle Tâche                        *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
        ls_task_trace_param TYPE ztec_s_task_trace_param.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_task           TYPE REF TO zcl_task,
    lo_cx_task        TYPE REF TO zcx_task,
    lo_task_container TYPE REF TO zcl_task_container.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_function_name TYPE rs38l_fnam.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Initialisation variable locale
  &quot; -----------------------------------------------------------

  IF io_task_container IS BOUND.
    &quot; Utilisation Container Tâche
    &quot;&quot;  --&gt; Initialiation instance local
    lo_task_container = io_task_container.

  ELSE.
    &quot; Utilisation paramètres liste
    &quot;&quot;  --&gt; Création Container avec ces données
    CREATE OBJECT lo_task_container
      EXPORTING
        it_attached_data       = it_attached_data
        it_function_parameters = it_function_parameters.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Récupération d&apos;une Tâche disponible
  &quot; -----------------------------------------------------------

  &quot; Récupération d&apos;une Tâche libre
  lo_task = me-&gt;task_get_free( ).
  IF NOT lo_task IS BOUND.
    &quot; Aucune Tâche disponible
    &quot;&quot;  --&gt; Attente fin de traitement d&apos;une Tâche
    WHILE NOT lo_task IS BOUND.   &quot;Tant qu&apos;aucune Tâche n&apos;est disponible
      &quot; Attente de fin de traitement d&apos;une Tâche
      WAIT FOR ASYNCHRONOUS TASKS UNTIL lo_task IS BOUND UP TO 1 SECONDS.
      IF sy-subrc NE 0.
        &quot; ID non renseigné
        &quot;&quot;  --&gt; Récupération instance Tâche Libre
        lo_task = me-&gt;task_get_free( ).

      ELSE.
        &quot; ID renseigné
        &quot;&quot;  --&gt; Passe à l&apos;étape suivante
        EXIT.

      ENDIF.

    ENDWHILE.                   &quot;Fin d&apos;attente disponibilité d&apos;une Tâche

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Détermination Nom du MF
  &quot; -----------------------------------------------------------

  IF lo_task-&gt;ms_task_data-task_dedicated EQ abap_true.
    &quot; Tâche dédiée
    &quot;&quot;  --&gt; Initialisation Nom du MF
    lv_function_name = lo_task-&gt;ms_task_data-task_process-function_name.

  ELSE.
    &quot; Tâche non dédiée
    &quot;&quot;  --&gt; Utilisation Nom du MF transmis
    lv_function_name = iv_function_name.

  ENDIF.

  IF is_task_trace_param-trace_active                         EQ abap_true
  OR me-&gt;ms_task_manager_data-task_trace_param-trace_active   EQ abap_true
  OR zcl_task_trace=&gt;task_trace_is_active( lv_function_name ) EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Activation Trace de la Tâche
    &quot; -----------------------------------------------------------

    &quot; Initialisation Paramètre de Trace
    IF zcl_task_trace=&gt;task_trace_is_active( lv_function_name ) EQ abap_true.
      &quot; Utilisation paramètre &quot;customisé&quot;
      ls_task_trace_param = zcl_task_trace=&gt;task_trace_get_param( lv_function_name ).

    ELSEIF me-&gt;ms_task_manager_data-task_trace_param-trace_active EQ abap_true.
      &quot; Utilisation paramètre local
      ls_task_trace_param = me-&gt;ms_task_manager_data-task_trace_param.

    ELSEIF is_task_trace_param-trace_active EQ abap_true.
      &quot; Utilisation paramètre d&apos;import
      ls_task_trace_param = is_task_trace_param.

    ENDIF.

    &quot; Enregistrement de la Trace d&apos;exécution
    me-&gt;task_trace_start(
        iv_function_name = lv_function_name
        io_task          = lo_task
        is_trace_param   = ls_task_trace_param
    ).

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Lancement de la Tâche
  &quot; -----------------------------------------------------------

  TRY.
      &quot; Lancement de la Tâche avec les paramètres fournis
      lo_task-&gt;task_start(
        iv_function_name  = iv_function_name
        io_task_container = lo_task_container
      ).

      &quot; Réinitialisation du Container
      lo_task_container-&gt;reset( ).

    CATCH zcx_task INTO lo_cx_task.
      &quot; Erreur lors de l&apos;appel
      &quot;&quot;  --&gt; Lève une Exception
      RAISE EXCEPTION TYPE zcx_task_manager
        EXPORTING
          previous = lo_cx_task.

  ENDTRY.

  &quot; -----------------------------------------------------------
  &quot; Réinitialisation Containeer
  &quot; -----------------------------------------------------------

  IF io_task_container IS BOUND.
    &quot; Réinitialisation Container d&apos;entrée
    io_task_container-&gt;reset( ).

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_TRACE_START" VERSION="1" LANGU="F" DESCRIPT="Trace - Début de la Trace d&apos;exécution" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_TRACE_START" SCONAME="IV_FUNCTION_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom du module fonction" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="RS38L_FNAM"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_TRACE_START" SCONAME="IO_TASK" VERSION="1" LANGU="F" DESCRIPT="Instance Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_TASK"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_TRACE_START" SCONAME="IS_TRACE_PARAM" VERSION="1" LANGU="F" DESCRIPT="Tâche - Paramètre de Trace" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTEC_S_TASK_TRACE_PARAM"/>
   <source>METHOD task_trace_start.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_TRACE_START                                  *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Début Trace d&apos;exécution de la Tâche               *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Début enregistrement de l&apos;exécution d&apos;une Tâche
  &quot; -----------------------------------------------------------

  IF NOT me-&gt;ms_task_manager_data-o_task_trace IS BOUND.
    &quot; Création Instance Trace
    CREATE OBJECT me-&gt;ms_task_manager_data-o_task_trace
      EXPORTING
        iv_trace_memory = is_trace_param-trace_memory.

  ENDIF.

  &quot; Enregistrement début Trace
  io_task-&gt;ms_task_data-task_trace_id = me-&gt;ms_task_manager_data-o_task_trace-&gt;task_trace_start(
      iv_task_manager_id = me-&gt;ms_task_manager_data-task_manager_id
      iv_task_id         = io_task-&gt;ms_task_data-task_id
      iv_function_name   = iv_function_name
      iv_trace_memory    = is_trace_param-trace_memory
  ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_TRACE_STOP" VERSION="1" LANGU="F" DESCRIPT="Trace - Fin de la Trace d&apos;exécution" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_TRACE_STOP" SCONAME="IV_TASK_TRACE_ID" VERSION="1" LANGU="F" DESCRIPT="Tâche - ID Trace" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTASK_TRACE_ID"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_TRACE_STOP" SCONAME="IV_LOG_IMMEDIATE" VERSION="1" LANGU="F" DESCRIPT="Trace - Enregistrement immédiat" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <source>METHOD task_trace_stop.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_TRACE_STOP                                   *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Fin Trace d&apos;exécution de la Tâche                 *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Fin enregistrement Trace d&apos;exécution de la Tâche
  &quot; -----------------------------------------------------------

  &quot; Fin de la Trace
  me-&gt;ms_task_manager_data-o_task_trace-&gt;task_trace_stop(
    iv_task_trace_id = iv_task_trace_id
    iv_log_immediate = iv_log_immediate
  ).

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_HANDLER" VERSION="1" LANGU="F" DESCRIPT="Handler Fin d&apos;une Tâche" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZTASK" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <friends CLSNAME="ZCL_TASK_HANDLER" REFCLSNAME="ZCL_TASK_MANAGER" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_TASK_HANDLER" CMPNAME="MS_PROCESS_BY_FORM" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement par Routine" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZTEC_S_TASK_PROCESS_BY_FORM" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_HANDLER" CMPNAME="MS_PROCESS_BY_METHOD" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement par Méthode" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZTEC_S_TASK_PROCESS_BY_METHOD" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TASK_HANDLER" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CONSTRUCTOR" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="CONSTRUCTOR" SCONAME="IO_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Gestion Processus //" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_TASK_MANAGER"/>
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="CONSTRUCTOR" SCONAME="IS_PROCESS_BY_FORM" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement par Routine" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_PROCESS_BY_FORM" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="CONSTRUCTOR" SCONAME="IS_PROCESS_BY_METHOD" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement par Méthode" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_PROCESS_BY_METHOD" PAROPTIONL="X"/>
   <source>METHOD constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_TASK_HANDLER                                  *
*&amp; Description     : Constructeur classe Handler TASK_MANAGER          *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Souscription à l&apos;évènement de Fin d&apos;une Tâche sur le Manager
  &quot; -----------------------------------------------------------

  &quot; Souscription à  l&apos;événement
  SET HANDLER me-&gt;handler_manager_end_of_task FOR io_task_manager.

  &quot; -----------------------------------------------------------
  &quot; Initialisation des attributs
  &quot; -----------------------------------------------------------

  IF NOT is_process_by_form IS INITIAL.
    &quot; Traitement par Routine
    me-&gt;ms_process_by_form   = is_process_by_form.

  ELSEIF NOT is_process_by_method IS INITIAL.
    &quot; Traitement par Méthode
    me-&gt;ms_process_by_method = is_process_by_method.

  ELSE.  ##NEEDED
    &quot; Aucun attribut
    &quot;&quot;  --&gt; Pas de traitement ?

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_FACTORY" VERSION="1" LANGU="F" DESCRIPT="Création Handler" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_FACTORY" SCONAME="IO_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Gestion Processus //" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_TASK_MANAGER"/>
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_FACTORY" SCONAME="IS_PROCESS_BY_FORM" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement par Routine" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_PROCESS_BY_FORM" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_FACTORY" SCONAME="IS_PROCESS_BY_METHOD" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement par Méthode" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_PROCESS_BY_METHOD" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_FACTORY" SCONAME="RO_HANDLER" VERSION="1" LANGU="F" DESCRIPT="Handler Fin d&apos;une Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK_HANDLER"/>
   <source>METHOD handler_factory.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Création de l&apos;instance Handler
  &quot; -----------------------------------------------------------

  &quot; Création de l&apos;instance
  CREATE OBJECT ro_handler
    EXPORTING
      io_task_manager      = io_task_manager
      is_process_by_form   = is_process_by_form
      is_process_by_method = is_process_by_method.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_MANAGER_END_OF_TASK" VERSION="1" LANGU="F" DESCRIPT="Handler Enement fin d&apos;une Tâche (TASK_MANAGER)" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="1" MTDDECLTYP="0" REFCLSNAME="ZCL_TASK_MANAGER" REFCMPNAME="MANAGER_END_OF_TASK" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_MANAGER_END_OF_TASK" SCONAME="IV_FUNCTION_NAME" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="1" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="0"/>
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_MANAGER_END_OF_TASK" SCONAME="IT_RESULT" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="1" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="0"/>
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_MANAGER_END_OF_TASK" SCONAME="IT_ATTACHED_DATA" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="1" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="0"/>
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_MANAGER_END_OF_TASK" SCONAME="IV_ERROR" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="1" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="0"/>
   <source>METHOD HANDLER_MANAGER_END_OF_TASK.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : HANDLER_END_OF_TASK                               *
*&amp; Classe          : ZCL_TASK_HANDLER                                  *
*&amp; Description     : Handler sur event ZCL_TASK_MANAGER=&gt;END_OF_TASK   *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception TYPE REF TO cx_root.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      IF NOT me-&gt;ms_process_by_form IS INITIAL.
        &quot; -----------------------------------------------------------
        &quot; Traitement par Routine
        &quot; -----------------------------------------------------------

        &quot; Appel de la routine
        PERFORM (me-&gt;ms_process_by_form-form)
             IN PROGRAM (me-&gt;ms_process_by_form-repid)
                  USING iv_function_name
                        it_result
                        it_attached_data
                        iv_error
                     IF FOUND.

      ELSEIF NOT me-&gt;ms_process_by_method IS INITIAL.
        &quot; -----------------------------------------------------------
        &quot; Traitement par appel de méthode
        &quot; -----------------------------------------------------------

        &quot; Appel de la méthode
        CALL METHOD me-&gt;ms_process_by_method-instance-&gt;(me-&gt;ms_process_by_method-method)
          EXPORTING
            iv_error         = iv_error
            iv_function_name = iv_function_name
            it_result        = it_result
            it_attached_data = it_attached_data.

      ENDIF.

*-- Ensemble des Exceptions relatives aux appels dynamiques
      &quot; Ces cas ne peuvent se produire que dans le cas d&apos;une mauvaise utilisation du développeur
    CATCH cx_sy_program_not_found cx_sy_dyn_call_error INTO lo_cx_exception.
*-- Ensemble des Exceptions relatives aux appels dynamiques
    CATCH cx_root                 INTO lo_cx_exception.   ##CATCH_ALL
      &quot; Tout autre cas d&apos;erreur
      &quot;&quot;  --&gt; Force la provocation d&apos;un DUMP &quot;spécifique&quot;
      WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
      lo_cx_exception-&gt;get_text( ).
      MESSAGE ID sy-msgid TYPE &apos;X&apos; NUMBER sy-msgno
                                     WITH sy-msgv1
                                          sy-msgv2
                                          sy-msgv3
                                          sy-msgv4.

  ENDTRY.

  IF lo_cx_exception IS BOUND.
    &quot; Ce code est exécuté que dans le cas où une Exception d&apos;une mauvaise utilisation
    &quot;&quot;  --&gt; Lève l&apos;Exception qui ne sera pas catché (DUMP)
    WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
    RAISE EXCEPTION lo_cx_exception.

  ENDIF.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_CONTAINER" VERSION="1" LANGU="F" DESCRIPT="Container paramètres d&apos;appel" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <friends CLSNAME="ZCL_TASK_CONTAINER" REFCLSNAME="ZCL_TASK" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <friends CLSNAME="ZCL_TASK_CONTAINER" REFCLSNAME="ZCL_TASK_MANAGER" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_TASK_CONTAINER" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <attribute CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="MT_ATTACHED_DATA" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TY_T_TASK_ATTACHED_DATA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="MT_FUNCTION_PARAMETERS" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TY_T_FUNCTION_PARAMETERS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="MT_FUNCTION_PARAMETERS_OUTPUT" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TY_T_FUNCTION_PARAMETERS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="ATTACHED_DATA_ADD" VERSION="1" LANGU="F" DESCRIPT="Ajout données contextuelle" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="ATTACHED_DATA_ADD" SCONAME="IV_NAME" VERSION="1" LANGU="F" DESCRIPT="Donnée contextuelle - Nom" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="ATTACHED_DATA_ADD" SCONAME="IX_DATA" VERSION="1" LANGU="F" DESCRIPT="Donnée contextuelle - Valeur" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <source>METHOD attached_data_add.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : ATTACHED_DATA_ADD                                 *
*&amp; Classe          : ZCL_TASK_CONTAINER                                *
*&amp; Description     : Ajout de données contextuelles                    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_attached_data TYPE zif_task_constant=&gt;ty_task_attached_data.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Ajout données contextuelle
  &quot; -----------------------------------------------------------

  ls_attached_data-name = iv_name.
  IF ix_data IS SUPPLIED.
    ls_attached_data-data = REF #( ix_data ).

  ENDIF.
  INSERT ls_attached_data INTO TABLE me-&gt;mt_attached_data.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CONSTRUCTOR" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="CONSTRUCTOR" SCONAME="IT_FUNCTION_PARAMETERS" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TY_T_FUNCTION_PARAMETERS" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="CONSTRUCTOR" SCONAME="IT_ATTACHED_DATA" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TY_T_TASK_ATTACHED_DATA" PAROPTIONL="X"/>
   <source>METHOD constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_TASK_CONTAINER                                *
*&amp; Description     : Création du Container                             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Initialisation des attributs
  &quot; -----------------------------------------------------------

  IF it_function_parameters IS SUPPLIED.
    &quot; Initialisation des paramètres d&apos;appel
    me-&gt;mt_function_parameters[] = it_function_parameters[].

  ENDIF.

  IF it_attached_data IS SUPPLIED.
    &quot; Initialisation des données contextuelles
    me-&gt;mt_attached_data[] = it_attached_data[].

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="COPY_GET" VERSION="1" LANGU="F" DESCRIPT="Retourne une copie de l&apos;instance" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="COPY_GET" SCONAME="RO_TASK_CONTAINER" VERSION="1" LANGU="F" DESCRIPT="Container paramètres d&apos;appel" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK_CONTAINER"/>
   <source>METHOD copy_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : COPY_GET                                          *
*&amp; Classe          : ZCL_TASK_CONTAINER                                *
*&amp; Description     : Création Copie du Container                       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Création nouvelle instance avec les mêmes paramètres
  &quot; -----------------------------------------------------------

  CREATE OBJECT ro_task_container
    EXPORTING
      it_attached_data       = me-&gt;mt_attached_data
      it_function_parameters = me-&gt;mt_function_parameters.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="FUNCTION_PARAMETER_ADD" VERSION="1" LANGU="F" DESCRIPT="Ajout paramètres d&apos;appel MF" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="FUNCTION_PARAMETER_ADD" SCONAME="IV_PARAMETER_NAME" VERSION="1" LANGU="F" DESCRIPT="Paramètre d&apos;appel - Nom" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="FUNCTION_PARAMETER_ADD" SCONAME="IX_PARAMETER_DATA" VERSION="1" LANGU="F" DESCRIPT="Paramètre d&apos;appel - Valeur" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="FUNCTION_PARAMETER_ADD" SCONAME="IV_TYPE_FOR_NONE_DDIC_PARAM" VERSION="1" LANGU="F" DESCRIPT="Type paramètre d&apos;appel (type local / générique uniquement)" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE" PAROPTIONL="X"/>
   <source>METHOD function_parameter_add.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : FUNCTION_PARAMETER_ADD                            *
*&amp; Classe          : ZCL_TASK_CONTAINER                                *
*&amp; Description     : Ajout de paramètres d&apos;appel                       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *


***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_function_parameters TYPE zif_task_constant=&gt;ty_function_parameters.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Ajout paramètre d&apos;appel
  &quot; -----------------------------------------------------------

  ls_function_parameters-parameter_name   = iv_parameter_name.
  IF ix_parameter_data IS SUPPLIED.
    ls_function_parameters-parameter_data = REF #( ix_parameter_data ).

  ENDIF.
  ls_function_parameters-type_for_none_ddic_parameter = iv_type_for_none_ddic_param.
  INSERT ls_function_parameters INTO TABLE me-&gt;mt_function_parameters.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="RESET" VERSION="1" LANGU="F" DESCRIPT="Réinitialisation" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="RESET" SCONAME="IV_ALL" VERSION="1" LANGU="F" DESCRIPT="Réinitialisation de tous les attributs" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="RESET" SCONAME="IV_FUNCTION_PARAMETER" VERSION="1" LANGU="F" DESCRIPT="Réinitialisation paramètre d&apos;appel" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="RESET" SCONAME="IV_ATTACHED_DATA" VERSION="1" LANGU="F" DESCRIPT="Réintiialisation données contextuelles" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <source>METHOD reset.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : RESET                                             *
*&amp; Classe          : ZCL_TASK_CONTAINER                                *
*&amp; Description     : Réinitialisation du Container                     *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *


***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Réinitialisation des attributs
  &quot; -----------------------------------------------------------

  IF iv_all           EQ abap_true
  OR iv_attached_data EQ abap_true.
    &quot; Réinitialisation données contextuelles
    FREE : me-&gt;mt_attached_data.

  ENDIF.

  IF iv_all                EQ abap_true
  OR iv_function_parameter EQ abap_true.
    &quot; Réinitialisation données d&apos;appel
    FREE : me-&gt;mt_function_parameters.

  ENDIF.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK" VERSION="1" LANGU="F" DESCRIPT="Instance Tâche" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZTASK" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_TASK" CMPNAME="TY_FUPARAREF" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="9 " SRCCOLUMN2="24 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_fupararef,
      funcname  TYPE fupararef-funcname,
      parameter TYPE fupararef-parameter,
      paramtype TYPE fupararef-paramtype,
      structure TYPE fupararef-structure,
    END OF   ty_fupararef
"/>
  <types CLSNAME="ZCL_TASK" CMPNAME="TY_T_FUPARAREF" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="11 " SRCCOLUMN1="4 " SRCROW2="12 " SRCCOLUMN2="80 " TYPESRC_LENG="0 " TYPESRC="ty_t_fupararef TYPE SORTED TABLE OF ty_fupararef
                        WITH UNIQUE KEY primary_key COMPONENTS funcname parameter
"/>
  <types CLSNAME="ZCL_TASK" CMPNAME="TY_TASK_PROCESS" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="11 " SRCCOLUMN1="4 " SRCROW2="15 " SRCCOLUMN2="29 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_task_process,
        function_name            TYPE        rs38l_fnam,
        task_container           TYPE REF TO zcl_task_container,
        t_definition_type_in_shm TYPE        stringtab,
      END OF   ty_task_process
"/>
  <types CLSNAME="ZCL_TASK" CMPNAME="TY_TASK" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="17 " SRCCOLUMN1="4 " SRCROW2="28 " SRCCOLUMN2="21 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_task,
        task_id               TYPE ztask_id,
        task_manager_id       TYPE ztask_manager_id,
        task_trace_id         TYPE ztask_trace_id,
        shm_manage_by_manager TYPE flag,
        shm_manage_by_local   TYPE flag,
        task_running          TYPE flag,
        task_grfc             TYPE rfcgr,
        task_dedicated        TYPE flag,
        task_process          TYPE ty_task_process,
        use_default_group     TYPE flag,
      END OF   ty_task
"/>
  <friends CLSNAME="ZCL_TASK" REFCLSNAME="ZCL_TASK_MANAGER" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <events CLSNAME="ZCL_TASK" CMPNAME="TASK_END" VERSION="1" LANGU="F" DESCRIPT="Evènement Fin de la Tâche" EXPOSURE="0" STATE="1" EDITORDER="1 " EVTDECLTYP="0" BCEVTCAT="00">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="TASK_END" SCONAME="IO_TASK" VERSION="1" LANGU="F" CMPTYPE="2" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK"/>
  </events>
  <events CLSNAME="ZCL_TASK" CMPNAME="TASK_ERROR_RECEIVE_RESULT" VERSION="1" LANGU="F" DESCRIPT="Evènement erreur réception résultalt Tâche" EXPOSURE="0" STATE="1" EDITORDER="2 " EVTDECLTYP="0" BCEVTCAT="00">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="TASK_ERROR_RECEIVE_RESULT" SCONAME="IO_TASK" VERSION="1" LANGU="F" DESCRIPT="Instance Tâche" CMPTYPE="2" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="TASK_ERROR_RECEIVE_RESULT" SCONAME="IS_TEXTID" VERSION="1" LANGU="F" DESCRIPT="Clé T100 avec mappage des paramètres pour attributs de nom" CMPTYPE="2" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="SCX_T100KEY" PAROPTIONL="X"/>
  </events>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_TASK" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_TASK" TYPEGROUP="SANA" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <forwardDeclaration>SANA</forwardDeclaration>
  <attribute CLSNAME="ZCL_TASK" CMPNAME="MS_TASK_DATA" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_TASK" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK" CMPNAME="MT_FUPARAREF" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_T_FUPARAREF" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK" CMPNAME="MT_GENERIC_TYPE_LIST" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SANA_TYPE_LIST" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TASK" CMPNAME="AT_END_OF_TASK" VERSION="1" LANGU="F" DESCRIPT="Traitement : At End Of Task (fin Tâche arrière-plan)" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="AT_END_OF_TASK" SCONAME="P_TASK" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE"/>
   <exception CLSNAME="ZCL_TASK" CMPNAME="AT_END_OF_TASK" SCONAME="ZCX_TASK" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD at_end_of_task.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : AT_END_OF_TASK                                    *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Méthode appelé lorsque le traitement // est finis *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_result TYPE ztec_t_function_parameters.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_textid TYPE scx_t100key.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_message TYPE c LENGTH 255.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération des données
  &quot; -----------------------------------------------------------

  &quot; Récupération des données issues du MF
  RECEIVE RESULTS FROM FUNCTION &apos;Z_TASK_CALL_PROCESS&apos;
    IMPORTING
      et_result             = lt_result
    EXCEPTIONS
      system_failure        = 1 MESSAGE lv_message
      communication_failure = 2 MESSAGE lv_message
      resource_failure      = 3
      OTHERS                = 4.
  IF sy-subrc EQ 0.
    &quot; Données correctement récupérée
    &quot;&quot;  --&gt; Appel méthode fin de traitement
    me-&gt;__at_end_of_task( lt_result ).

  ELSE.
    &quot; Une erreur est survenue
    &quot;&quot;  --&gt; Lève une Exception
    ls_textid-msgid = sy-msgid.
    ls_textid-msgno = sy-msgno.
    ls_textid-attr1 = sy-msgv1.
    ls_textid-attr2 = sy-msgv2.
    ls_textid-attr3 = sy-msgv3.
    ls_textid-attr4 = sy-msgv4.
    RAISE EVENT task_error_receive_result &quot;(à destination de ZCL_TASK_MANAGER)
      EXPORTING
        io_task   = me
        is_textid = ls_textid.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CONSTRUCTOR" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONSTRUCTOR" SCONAME="IV_GRFC" VERSION="1" LANGU="F" DESCRIPT="Groupe de serveurs RFC pour traitement paralléle" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="RFCGR" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONSTRUCTOR" SCONAME="IV_FUNCTION_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom de fonction" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONSTRUCTOR" SCONAME="IV_MANAGE_SHM" VERSION="1" LANGU="F" DESCRIPT="SHM - Gestion SHM" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONSTRUCTOR" SCONAME="IV_TASK_MANAGER_ID" VERSION="1" LANGU="F" DESCRIPT="Tâche - ID Manager Tâche" CMPTYPE="1" MTDTYPE="2" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTASK_MANAGER_ID"/>
   <exception CLSNAME="ZCL_TASK" CMPNAME="CONSTRUCTOR" SCONAME="ZCX_TASK" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" MTDTYPE="2" EDITORDER="1 "/>
   <source>METHOD constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Constructeur instance                             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_task TYPE REF TO zcx_task.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Note d&apos;utilisation :
  &quot;   Si le MF est transmis, la Tâche sera dédié à  ce MF, dans
  &quot;     ce cas le paramètre d&apos;appel &quot;IV_FUNCTION_NAME&quot;
  &quot;     de la méthode &quot;TASK_START&quot; n&apos;est pas utilisé
  &quot;   Dans le cas contraire, il est obligatoire !
  &quot; -----------------------------------------------------------

  &quot; -----------------------------------------------------------
  &quot; Détermination des types prédéfinis
  &quot; -----------------------------------------------------------

  IF zcl_task=&gt;mt_generic_type_list[] IS INITIAL.
    &quot; Récupération Type ABAP prédéfini
    CALL FUNCTION &apos;RS_GET_PREDEFINED_TYPES&apos;
      IMPORTING
        type_list      = zcl_task=&gt;mt_generic_type_list
      EXCEPTIONS
        internal_error = 1
        OTHERS         = 2.
    IF sy-subrc EQ 0.

      &quot; Suppression types non génériques
      DELETE zcl_task=&gt;mt_generic_type_list WHERE is_generic NE abap_true.

      &quot; Mise en correspondance des données
      LOOP AT zcl_task=&gt;mt_generic_type_list ASSIGNING FIELD-SYMBOL(&lt;lfs_s_type_list&gt;).

        IF &lt;lfs_s_type_list&gt;-name CS &apos;%_&apos;.                  &quot;#EC NOTEXT
          &quot; Suppression caractère indésirable
          REPLACE ALL OCCURRENCES OF &apos;%_&apos; IN &lt;lfs_s_type_list&gt;-name WITH space. &quot;#EC NOTEXT
          TRANSLATE &lt;lfs_s_type_list&gt;-name USING &apos;_ &apos;.      &quot;#EC NOTEXT

        ENDIF.

      ENDLOOP.

      &quot; Tri
      SORT zcl_task=&gt;mt_generic_type_list BY name.

    ENDIF.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Création instance de Tâche
  &quot; -----------------------------------------------------------

  TRY.
      &quot; Génération ID de Tâche Unique
      me-&gt;ms_task_data-task_id = cl_system_uuid=&gt;create_uuid_c32_static( ).

    CATCH cx_uuid_error.
      &quot; Erreur génération GUID unique
      &quot;&quot;  --&gt; Génération ID aléatoire
      me-&gt;ms_task_data-task_id = |{ sy-datum }{ sy-uzeit }|.

  ENDTRY.

  &quot; -----------------------------------------------------------
  &quot; Initialisation autres attributs
  &quot; -----------------------------------------------------------

  &quot; Initialisation Groupe de Serveur
  IF NOT iv_grfc IS INITIAL.
    &quot; Groupe de Serveur spécifié
    me-&gt;ms_task_data-task_grfc = iv_grfc.

  ELSE.
    &quot; Utilisation Groupe de Serveur par défaut
    me-&gt;ms_task_data-use_default_group = abap_true.

  ENDIF.

  &quot; Initialisation ID Manager
  me-&gt;ms_task_data-task_manager_id = iv_task_manager_id.

  &quot; Initialisation Indicateur Gestion SHM
  me-&gt;ms_task_data-shm_manage_by_manager = iv_manage_shm.

  IF      iv_function_name IS SUPPLIED
  AND NOT iv_function_name IS INITIAL.
    &quot; Restriction sur un MF
    &quot;&quot;  --&gt; Initialisation Nom Module Fonction
    me-&gt;ms_task_data-task_process-function_name = iv_function_name.

    &quot;&quot;  --&gt; Initialisation indicateur Tâche dédiée
    me-&gt;ms_task_data-task_dedicated = abap_true.

    TRY.
        &quot;&quot;  --&gt; Récupération des paramètres du MF
        me-&gt;function_get_call_parameters( iv_function_name ).

      CATCH zcx_task INTO lo_cx_task.
        &quot; Erreur lors de la récupération des paramètres d&apos;appel
        RAISE EXCEPTION TYPE zcx_task
          EXPORTING
            previous = lo_cx_task.

    ENDTRY.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="CONVERT_DYNAMIC_PARAMETERS" VERSION="1" LANGU="F" DESCRIPT="Conversion données paramètres dynamique en statique" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONVERT_DYNAMIC_PARAMETERS" SCONAME="IT_FUNCTION_PARAMETERS_DYNAMIC" VERSION="1" LANGU="F" DESCRIPT="Table des paramètres Dynamique" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TY_T_FUNCTION_PARAMETERS"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONVERT_DYNAMIC_PARAMETERS" SCONAME="RT_FUNCTION_PARAMETERS_STATIC" VERSION="1" LANGU="F" DESCRIPT="Type de table paramètre d&apos;appel Statique" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTEC_T_FUNCTION_PARAMETERS"/>
   <exception CLSNAME="ZCL_TASK" CMPNAME="CONVERT_DYNAMIC_PARAMETERS" SCONAME="ZCX_TASK" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD convert_dynamic_parameters.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONVERT_DYNAMIC_PARAMETERS                        *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Convertis les données des paramètres &quot;dynamique&quot;  *
*                    en données &quot;statiques&quot;                            *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lot_table TYPE REF TO data.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_function_parameters_static TYPE ztec_s_function_parameters.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_type_descr      TYPE REF TO cl_abap_typedescr,
    lo_cx_exception    TYPE REF TO cx_root,
    lo_type_definition TYPE REF TO zcl_type_definition.

  DATA :
    lo_datadescr  TYPE REF TO cl_abap_datadescr,
    lo_tabledescr TYPE REF TO cl_abap_tabledescr.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_parameter_data&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : rt_function_parameters_static.

  IF it_function_parameters_dynamic[] IS INITIAL.
    &quot; Rien à  traiter
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; Parcours l&apos;ensemble des paramètres &quot;dynamiques&quot;
  LOOP AT it_function_parameters_dynamic ASSIGNING FIELD-SYMBOL(&lt;lfs_s_function_parameters&gt;).

    CLEAR    : ls_function_parameters_static, lo_type_descr.
    UNASSIGN : &lt;lfs_parameter_data&gt;.

    &quot; Initialisation Nom du Paramètre
    ls_function_parameters_static-parameter_name = &lt;lfs_s_function_parameters&gt;-parameter_name.

    &quot; Récupération données du paramètre
    READ TABLE me-&gt;mt_fupararef WITH TABLE KEY funcname  = me-&gt;ms_task_data-task_process-function_name
                                               parameter = CONV fupararef-parameter( &lt;lfs_s_function_parameters&gt;-parameter_name )
                                     ASSIGNING FIELD-SYMBOL(&lt;lfs_s_fupararef&gt;).
    IF sy-subrc NE 0.
      &quot; Paramètre inexistant
      &quot;&quot;  --&gt; Passe à l&apos;itération suivante
      CONTINUE.

    ENDIF.

    TRY.
        &quot; Initialisation type du paramètre
        ls_function_parameters_static-parameter_kind = SWITCH string( &lt;lfs_s_fupararef&gt;-paramtype
                                                                        WHEN &apos;I&apos; THEN zif_task_constant=&gt;mc_parameter_kind_exporting &quot;#EC NOTEXT
                                                                        WHEN &apos;E&apos; THEN zif_task_constant=&gt;mc_parameter_kind_importing &quot;#EC NOTEXT
                                                                        WHEN &apos;T&apos; THEN zif_task_constant=&gt;mc_parameter_kind_tables &quot;#EC NOTEXT
                                                                        WHEN &apos;C&apos; THEN zif_task_constant=&gt;mc_parameter_kind_changing &quot;#EC NOTEXT
                                                                        ELSE THROW cx_sy_arg_out_of_domain( )
                                                                    ).
      CATCH cx_sy_arg_out_of_domain.
        &quot; Autre valeur
        IF &lt;lfs_s_fupararef&gt;-paramtype EQ &apos;X&apos;.
          &quot; Cas d&apos;une Exception
          ls_function_parameters_static-parameter_kind = zif_task_constant=&gt;mc_parameter_kind_exception.
          INSERT ls_function_parameters_static INTO TABLE rt_function_parameters_static.

        ENDIF.

        &quot;&quot;  --&gt; Passe à  l&apos;itération suivante
        CONTINUE.

    ENDTRY.

    &quot; Récupération définition type du paramètre
    cl_abap_typedescr=&gt;describe_by_name(
      EXPORTING
        p_name         = &lt;lfs_s_fupararef&gt;-structure
      RECEIVING
        p_descr_ref    = lo_type_descr
      EXCEPTIONS
        type_not_found = 1
        OTHERS         = 2
    ).
    IF sy-subrc NE 0.
      &quot; Une erreur est survenue (cas du &quot;ANY TABLE&quot; par exemple)
      CLEAR : lo_type_descr.

    ENDIF.

    IF &lt;lfs_s_function_parameters&gt;-parameter_data IS BOUND.
      &quot; Initialisation pointeur sur les données
      ASSIGN &lt;lfs_s_function_parameters&gt;-parameter_data-&gt;* TO &lt;lfs_parameter_data&gt;.

    ELSEIF &lt;lfs_s_fupararef&gt;-paramtype EQ &apos;T&apos;.              &quot;#EC NOTEXT
      &quot; Paramètre Type Table et non transmis
      &quot;&quot;  --&gt; Création du Type de table
      TRY.
          &quot; Création Type de Table
          lo_datadescr ?= lo_type_descr.
          lo_tabledescr = cl_abap_tabledescr=&gt;create( p_line_type = lo_datadescr ).

          &quot; Initialisation Pointeur sur les données
          CREATE DATA lot_table TYPE HANDLE lo_tabledescr.
          ASSIGN lot_table-&gt;* TO &lt;lfs_parameter_data&gt;.

        CATCH cx_sy_table_creation.
          &quot; Erreur lors de la création du Type
          &quot;&quot;  --&gt; Force la provocation d&apos;un DUMP
          MESSAGE x005(ztask) WITH me-&gt;ms_task_data-task_id &lt;lfs_s_function_parameters&gt;-parameter_name.

      ENDTRY.

    ENDIF.

    &quot; Traitement cas particulier des types génériques
    READ TABLE zcl_task=&gt;mt_generic_type_list WITH KEY name = &lt;lfs_s_fupararef&gt;-structure
                                          TRANSPORTING NO FIELDS BINARY SEARCH.
    IF sy-subrc EQ 0 OR NOT lo_type_descr IS BOUND OR lo_type_descr-&gt;is_ddic_type( ) EQ abap_false.
      &quot; Type générique ou pas du dictionnaire
      &quot;&quot;  --&gt; Contrôle supplémentaire
      IF  NOT &lt;lfs_parameter_data&gt; IS ASSIGNED
      AND &lt;lfs_s_function_parameters&gt;-type_for_none_ddic_parameter IS INITIAL.
        &quot; Aucun moyen de déterminer le type
        &quot;&quot;  --&gt; Force la provocation d&apos;un DUMP
        MESSAGE x005(ztask) WITH me-&gt;ms_task_data-task_id &lt;lfs_s_function_parameters&gt;-parameter_name.

      ELSEIF NOT &lt;lfs_s_function_parameters&gt;-type_for_none_ddic_parameter IS INITIAL.
        &quot; Type transmis
        &quot;&quot;  --&gt; Récupération descriptino du Type
        cl_abap_typedescr=&gt;describe_by_name(
          EXPORTING
            p_name         = &lt;lfs_s_function_parameters&gt;-type_for_none_ddic_parameter
          RECEIVING
            p_descr_ref    = lo_type_descr
          EXCEPTIONS
            type_not_found = 1
            OTHERS         = 2
        ).
        IF sy-subrc NE 0.
          &quot; Type non défini dans le RTTS
          &quot;&quot;  --&gt; Aucun moyen de déterminer le type // Force la provocation d&apos;un DUMP
          MESSAGE x005(ztask) WITH me-&gt;ms_task_data-task_id &lt;lfs_s_function_parameters&gt;-parameter_name.

        ENDIF.

      ELSEIF &lt;lfs_parameter_data&gt; IS ASSIGNED.
        &quot; Données transmises
        &quot;&quot;  --&gt; Récupération description des données
        lo_type_descr = cl_abap_typedescr=&gt;describe_by_data( &lt;lfs_parameter_data&gt; ).

      ELSE.
        &quot; Nous n&apos;irons jamais ici, mais au moins il est présent
        &quot;&quot;  --&gt; Force la provocation d&apos;un DUMP
        MESSAGE x005(ztask) WITH me-&gt;ms_task_data-task_id &lt;lfs_s_function_parameters&gt;-parameter_name.

      ENDIF.

      IF lo_type_descr-&gt;is_ddic_type( ) EQ abap_false.
        &quot; Type non présent dans le dictionnaire
        &quot;&quot;  --&gt; Utilisation SHM pour stockage du Type
        TRY.
            IF NOT lo_type_definition IS BOUND.
              &quot; Récupération de l&apos;instance courante
              lo_type_definition = zcl_type_definition=&gt;get_instance( ).

            ENDIF.

            IF lo_type_definition IS BOUND.
              &quot; Ajout de la définition
              lo_type_definition-&gt;definition_type_add( io_definition = lo_type_descr ).

              IF me-&gt;ms_task_data-shm_manage_by_manager EQ abap_true
              OR zcl_task_param=&gt;task_param_get( me-&gt;ms_task_data-task_process-function_name )-shm_management EQ abap_true.
                TRY.
                    &quot; -----------------------------------------------------------
                    &quot; Enregistre l&apos;ID Manager de Tâche dans la SHM
                    &quot; -----------------------------------------------------------

                    &quot; Ajout de l&apos;ID du Manager de Tâche
                    zcl_task_shm=&gt;get_instance( lo_type_descr-&gt;absolute_name )-&gt;task_manager_register( me-&gt;ms_task_data-task_manager_id ).

                    &quot; Ajout du Type dans la Liste stocké en SHM
                    APPEND lo_type_descr-&gt;absolute_name TO me-&gt;ms_task_data-task_process-t_definition_type_in_shm.

                  CATCH cx_root.          &quot;#EC CATCH_ALL #EC NO_HANDLER
                    &quot; Erreur lors de l&apos;ajout dans la SHM

                ENDTRY.

                &quot; Initialisation Indicateur Gestion Local de la SHM
                me-&gt;ms_task_data-shm_manage_by_local = abap_true.

              ENDIF.

            ENDIF.

          CATCH cx_root.                  &quot;#EC CATCH_ALL #EC NO_HANDLER
            &quot; Une erreur est survenue lors de l&apos;utilisation de la mémoire partagée

        ENDTRY.

      ENDIF.        &quot;Fin test Type DDIC

    ENDIF.          &quot;Fin test type générique

    &quot; Initialisation type (ABAP) de données
    IF &lt;lfs_s_fupararef&gt;-paramtype EQ &apos;T&apos;.                  &quot;#EC NOTEXT
      &quot; Paramètre d&apos;appel de type &quot;Table&quot;
      &quot;&quot;  --&gt; Force le type en Type de table
      ls_function_parameters_static-value_kind = cl_abap_typedescr=&gt;kind_table.

    ELSE.
      &quot; Paramètre d&apos;appel d&apos;autre type
      &quot;&quot;  --&gt; Utilisation type tel que fourni par le standard
      ls_function_parameters_static-value_kind = lo_type_descr-&gt;kind.

    ENDIF.

    &quot; Initialisation Type
    ls_function_parameters_static-value_type = lo_type_descr-&gt;absolute_name.

    IF ls_function_parameters_static-parameter_kind NE zif_task_constant=&gt;mc_parameter_kind_importing.
      &quot; Suivant son type (Table / Structure / Référence / Autres ...)
      CASE lo_type_descr-&gt;kind.

        WHEN cl_abap_typedescr=&gt;kind_elem.
          &quot; Elementaire
          &quot;&quot;  --&gt; Initialisation de la données
          ls_function_parameters_static-value_data = &lt;lfs_parameter_data&gt;.

        WHEN OTHERS.
          &quot; Cas structure complexe
          TRY.
              &quot;&quot;  --&gt; Initialisation des données sous format XML
              CALL TRANSFORMATION id
                           SOURCE data = &lt;lfs_parameter_data&gt;
                       RESULT XML ls_function_parameters_static-value_data_xml.

            CATCH cx_root INTO lo_cx_exception.          &quot;#EC CATCH_ALL
              &quot; Erreur conversion en XML
              &quot;&quot;  --&gt; Lève une exception
              RAISE EXCEPTION TYPE zcx_task
                EXPORTING
                  previous = lo_cx_exception.

          ENDTRY.

      ENDCASE.

    ENDIF.

    &quot; Ajout du paramètre
    INSERT ls_function_parameters_static INTO TABLE rt_function_parameters_static.

  ENDLOOP.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="CONVERT_STATIC_PARAMETERS" VERSION="1" LANGU="F" DESCRIPT="Conversion données paramètres statique en dynamique" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONVERT_STATIC_PARAMETERS" SCONAME="IT_FUNCTION_PARAMETERS_STATIC" VERSION="1" LANGU="F" DESCRIPT="Type de table paramètre d&apos;appel Statique" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_T_FUNCTION_PARAMETERS"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONVERT_STATIC_PARAMETERS" SCONAME="RT_FUNCTION_PARAMETERS_DYNAMIC" VERSION="1" LANGU="F" DESCRIPT="Table des paramètres dynamique" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TY_T_FUNCTION_PARAMETERS"/>
   <source>METHOD convert_static_parameters.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONVERT_STATIC_PARAMETERS                         *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Convertis les données des paramètres &quot;statiques&quot;  *
*                    en données &quot;dynamiques&quot;                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_function_parameters_dynamic TYPE zif_task_constant=&gt;ty_function_parameters.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_value&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : rt_function_parameters_dynamic.

  IF it_function_parameters_static[] IS INITIAL.
    &quot; Rien à  traiter
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Conversion des données statiques en dynamique
  &quot; -----------------------------------------------------------

  LOOP AT it_function_parameters_static ASSIGNING FIELD-SYMBOL(&lt;lfs_s_function_parameters&gt;).

    CLEAR : ls_function_parameters_dynamic.

    &quot; Initialisation du Nom du paramètre
    ls_function_parameters_dynamic-parameter_name = &lt;lfs_s_function_parameters&gt;-parameter_name.

    &quot; Initialisation des données typées
    IF &lt;lfs_s_function_parameters&gt;-parameter_kind NE zif_task_constant=&gt;mc_parameter_kind_tables.
      &quot; Paramètre &lt;&gt; Table
      CREATE DATA ls_function_parameters_dynamic-parameter_data TYPE (&lt;lfs_s_function_parameters&gt;-value_type).

    ELSE.
      &quot; Paramètre type table
      CREATE DATA ls_function_parameters_dynamic-parameter_data TYPE STANDARD TABLE OF (&lt;lfs_s_function_parameters&gt;-value_type).

    ENDIF.

    &quot; Initialisation pointeur sur les données
    ASSIGN ls_function_parameters_dynamic-parameter_data-&gt;* TO &lt;lfs_value&gt;.

    &quot; Suivant le type (ABAP) de données
    IF NOT &lt;lfs_s_function_parameters&gt;-value_data_xml IS INITIAL.
      &quot; Données &quot;complexe&quot; stockées sous forme XML
      CALL TRANSFORMATION id
               SOURCE XML &lt;lfs_s_function_parameters&gt;-value_data_xml
                   RESULT data = &lt;lfs_value&gt;.

    ELSEIF NOT &lt;lfs_s_function_parameters&gt;-value_data IS INITIAL.
      &quot; Type Elémentaire
      &quot;&quot;  --&gt; Initialisation des données
      &lt;lfs_value&gt; = &lt;lfs_s_function_parameters&gt;-value_data.

    ELSE. &quot;#EC NEEDED
      &quot; Autre cas
      &quot;&quot;  --&gt; ToDo : Ajouter ici les autres cas

    ENDIF.

    &quot; Ajout de l&apos;entrée
    INSERT ls_function_parameters_dynamic INTO TABLE rt_function_parameters_dynamic.

  ENDLOOP.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="FUNCTION_GET_CALL_PARAMETERS" VERSION="1" LANGU="F" DESCRIPT="Récupération paramétre d&apos;appel du MF" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="FUNCTION_GET_CALL_PARAMETERS" SCONAME="IV_FUNCTION_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom du module fonction" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="RS38L_FNAM"/>
   <exception CLSNAME="ZCL_TASK" CMPNAME="FUNCTION_GET_CALL_PARAMETERS" SCONAME="ZCX_TASK" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD function_get_call_parameters.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : FUNCTION_GET_CALL_PARAMETERS                      *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Récupération des paramètres d&apos;appel du MF         *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_fupararef TYPE ty_t_fupararef.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_textid    TYPE scx_t100key,
    ls_fupararef TYPE zcl_task=&gt;ty_fupararef.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrà´le sur le Nom du MF
  &quot; -----------------------------------------------------------

  SELECT SINGLE funcname FROM tfdir
                         INTO ls_fupararef-funcname
                        WHERE funcname EQ iv_function_name.
  IF sy-subrc NE 0.
    &quot; Le MF n&apos;existe pas
    &quot;&quot;  --&gt; Lève une exception
    ls_textid-msgid = zif_task_constant=&gt;mc_message_class_id.
    ls_textid-msgno = 002.
    ls_textid-attr1 = me-&gt;ms_task_data-task_id.
    ls_textid-attr2 = iv_function_name.
    RAISE EXCEPTION TYPE zcx_task
      EXPORTING
        textid = ls_textid.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Récupération de la liste des paramètres du MF
  &quot; -----------------------------------------------------------

  &quot; Liste paramètres déjà  récupérée ?
  READ TABLE zcl_task=&gt;mt_fupararef WITH KEY funcname = iv_function_name
                                TRANSPORTING NO FIELDS BINARY SEARCH.
  IF sy-subrc NE 0.
    &quot;&quot;  --&gt; Récupération données des paramètres du MF
    SELECT funcname  parameter
           paramtype structure FROM fupararef
                         INTO TABLE lt_fupararef
                              WHERE funcname EQ iv_function_name.
    IF sy-subrc NE 0.
      &quot; Aucun paramètre existant pour ce MF
      &quot;&quot;  --&gt; Création d&apos;une nouvelle entrée afin d&apos;éviter de rechercher à  nouveau
      ls_fupararef-funcname = iv_function_name.
      INSERT ls_fupararef INTO TABLE zcl_task=&gt;mt_fupararef.

    ELSE.
      &quot; Paramètres existant
      &quot;&quot;  --&gt; Ajout de la liste des Paramètres
      INSERT LINES OF lt_fupararef INTO TABLE zcl_task=&gt;mt_fupararef.

    ENDIF.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="TASK_FREE" VERSION="1" LANGU="F" DESCRIPT="Réintialisation de la Tâche" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD task_free.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_FREE                                         *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Réinitialisation de la Tâche                      *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; Réinitialisation des données relatives à la Tâche
  FREE : me-&gt;ms_task_data-task_running,
         me-&gt;ms_task_data-task_trace_id,
         me-&gt;ms_task_data-task_process-task_container,
         me-&gt;ms_task_data-task_process-t_definition_type_in_shm.

  IF me-&gt;ms_task_data-task_dedicated NE abap_true.
    &quot; Dans le cas d&apos;une Tâche non dédiée
    &quot;&quot;  --&gt; Réinitialisation Nom du MF
    CLEAR : me-&gt;ms_task_data-task_process-function_name.

    &quot;&quot;  --&gt; Réinitialisation Indicateur de Gestion de la SHM
    CLEAR : me-&gt;ms_task_data-shm_manage_by_local.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="TASK_START" VERSION="1" LANGU="F" DESCRIPT="Lancement du traitement de la Tâche" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="TASK_START" SCONAME="IV_FUNCTION_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom du module fonction" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="RS38L_FNAM" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="TASK_START" SCONAME="IO_TASK_CONTAINER" VERSION="1" LANGU="F" DESCRIPT="Container paramètres d&apos;appel" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_TASK_CONTAINER" PAROPTIONL="X"/>
   <exception CLSNAME="ZCL_TASK" CMPNAME="TASK_START" SCONAME="ZCX_TASK" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD task_start.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_START                                        *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Permet de démarrer le processus de la Tâche       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_result              TYPE ztec_t_function_parameters,
    lt_function_parameters TYPE ztec_t_function_parameters.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_textid TYPE scx_t100key.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception TYPE REF TO cx_root.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : me-&gt;ms_task_data-task_process-t_definition_type_in_shm, me-&gt;ms_task_data-task_process-task_container.

  &quot; -----------------------------------------------------------
  &quot; Initialisation Indicateur Tâche en cours de préparation
  &quot; -----------------------------------------------------------

  &quot; Initialisation Indicateur Tâche en cours de préparation
  me-&gt;ms_task_data-task_running = abap_undefined.

  &quot; -----------------------------------------------------------
  &quot; Traitement pour Tâche non dédié à  un MF
  &quot; -----------------------------------------------------------

  IF me-&gt;ms_task_data-task_dedicated NE abap_true.
    &quot; La Tâche n&apos;est pas dédié à  un MF unique
    IF iv_function_name IS INITIAL.
      &quot;Le nom du MF devient alors obligatoire et ce dernier n&apos;a pas été transmis
      &quot;&quot;  --&gt; Arrêt du traitement // Lève une exception
      me-&gt;ms_task_data-task_running = abap_false.
      ls_textid-msgid = zif_task_constant=&gt;mc_message_class_id.
      ls_textid-msgno = 003.
      ls_textid-attr1 = me-&gt;ms_task_data-task_id.
      RAISE EXCEPTION TYPE zcx_task
        EXPORTING
          textid = ls_textid.

    ELSE.
      &quot; Nom MF transmis
      TRY.
          &quot;&quot;  --&gt; Récupération des paramètres du MF
          me-&gt;function_get_call_parameters( iv_function_name ).

        CATCH zcx_task INTO lo_cx_exception.
          &quot; Erreur lors de la récupération des paramètres d&apos;appel
          me-&gt;ms_task_data-task_running = abap_false.
          RAISE EXCEPTION TYPE zcx_task
            EXPORTING
              previous = lo_cx_exception.

      ENDTRY.

      &quot;&quot;  --&gt; Initialisation du nom du MF pour poursuite du traitement
      me-&gt;ms_task_data-task_process-function_name = iv_function_name.

    ENDIF.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Initialisation paramètres d&apos;appel
  &quot; -----------------------------------------------------------

  IF io_task_container IS BOUND.
    &quot; Utilisation des paramètres d&apos;appel transmis
    me-&gt;ms_task_data-task_process-task_container = io_task_container-&gt;copy_get( ).

  ELSE.
    &quot; Création nouvelle instance Container
    CREATE OBJECT me-&gt;ms_task_data-task_process-task_container.

  ENDIF.

  IF NOT me-&gt;ms_task_data-task_process-task_container-&gt;mt_function_parameters[] IS INITIAL.
    &quot; -----------------------------------------------------------
    &quot; Initialisation table de paramètre statique pour appel Asynchrone
    &quot; -----------------------------------------------------------

    TRY.
        &quot; Conversion des paramètres dynamique en statique (pour appel MF de lancement)
        lt_function_parameters = me-&gt;convert_dynamic_parameters( me-&gt;ms_task_data-task_process-task_container-&gt;mt_function_parameters ).

      CATCH zcx_task INTO lo_cx_exception.
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Lève une Exception
        me-&gt;ms_task_data-task_running = abap_false.
        RAISE EXCEPTION TYPE zcx_task
          EXPORTING
            textid = ls_textid.

    ENDTRY.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Initialisation Indicateur Tâche en cours de traitement
  &quot; -----------------------------------------------------------

  &quot; Initialisation Indicateur Tâche occupée
  me-&gt;ms_task_data-task_running = abap_true.

  &quot; -----------------------------------------------------------
  &quot; Appel du Traitement en //
  &quot; -----------------------------------------------------------

  IF me-&gt;ms_task_data-use_default_group EQ abap_true.
    &quot; Appel fonction générique (avec paramètre statique) qui appelle le MF souhaité
    CALL FUNCTION &apos;Z_TASK_CALL_PROCESS&apos;
      STARTING NEW TASK me-&gt;ms_task_data-task_id DESTINATION IN GROUP DEFAULT
      CALLING at_end_of_task ON END OF TASK
      EXPORTING
        iv_function_name       = me-&gt;ms_task_data-task_process-function_name
        it_function_parameters = lt_function_parameters
      EXCEPTIONS
        system_failure         = 1
        communication_failure  = 2
        resource_failure       = 3
        OTHERS                 = 4.

  ELSE.
    &quot; Appel fonction générique (avec paramètre statique) qui appelle le MF souhaité
    CALL FUNCTION &apos;Z_TASK_CALL_PROCESS&apos;
      STARTING NEW TASK me-&gt;ms_task_data-task_id DESTINATION IN GROUP me-&gt;ms_task_data-task_grfc
      CALLING at_end_of_task ON END OF TASK
      EXPORTING
        iv_function_name       = me-&gt;ms_task_data-task_process-function_name
        it_function_parameters = lt_function_parameters
      EXCEPTIONS
        system_failure         = 1
        communication_failure  = 2
        resource_failure       = 3
        OTHERS                 = 4.

  ENDIF.
  IF sy-subrc EQ 0.
    &quot; Aucune erreur

  ELSEIF sy-subrc EQ 1
      OR sy-subrc EQ 2
      OR sy-subrc EQ 3.
    &quot; Erreur lors de l&apos;appel RFC asynchrone
    &quot;&quot;  --&gt; Appel du Traitement en Synchrone
    CALL FUNCTION &apos;Z_TASK_CALL_PROCESS&apos;
      EXPORTING
        iv_function_name       = me-&gt;ms_task_data-task_process-function_name
        it_function_parameters = lt_function_parameters
      IMPORTING
        et_result              = lt_result.

    &quot;&quot;  --&gt; Appel traitement de fin d&apos;une Tâche
    me-&gt;__at_end_of_task( lt_result ).

  ELSE.
    &quot; Erreur &quot;fonctionnelle&quot; // Si implémentée au niveau du MF &quot;Z_TASK_CALL_PROCESS&quot;
    &quot;&quot;  --&gt; Initialisation code en erreur
    ls_textid-msgid = sy-msgid.
    ls_textid-msgno = sy-msgno.
    ls_textid-attr1 = sy-msgv1.
    ls_textid-attr2 = sy-msgv2.
    ls_textid-attr3 = sy-msgv3.
    ls_textid-attr4 = sy-msgv4.
    RAISE EXCEPTION TYPE zcx_task
      EXPORTING
        textid = ls_textid.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="TASK_STOP" VERSION="1" LANGU="F" DESCRIPT="Fin du taitement de la Tâche" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD task_stop.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_STOP                                         *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Termine la Tâche                                  *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Note d&apos;utilisation :
  &quot;  On ne libère pas la Tâche (réinitialisation de l&apos;indicateur
  &quot;  en cours de traitement) dans cette classe !
  &quot;  Seule la classe ZCL_TASK_MANAGER se réserve le droit
  &quot;  de modifier cet indicateur afin de maitriser
  &quot;  parfaitement les débuts et fin de Tâche.
  &quot; -----------------------------------------------------------

  &quot; -----------------------------------------------------------
  &quot; Traitement lors du fin de la Tâche
  &quot; -----------------------------------------------------------

  &quot;&quot;  --&gt; Lève évènement fin de Tâche (à destination de ZCL_TASK_MANAGER)
  RAISE EVENT task_end
    EXPORTING
      io_task = me.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="__AT_END_OF_TASK" VERSION="1" LANGU="F" DESCRIPT="Traitement fin d&apos;une Tâche" EXPOSURE="0" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="__AT_END_OF_TASK" SCONAME="IT_RESULT" VERSION="1" LANGU="F" DESCRIPT="Type de table paramètre d&apos;appel Statique" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_T_FUNCTION_PARAMETERS" PAROPTIONL="X"/>
   <source>METHOD __at_end_of_task.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __AT_END_OF_TASK                                  *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Traitement fin d&apos;une Tâche                        *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  IF NOT it_result[] IS INITIAL.
    &quot; -----------------------------------------------------------
    &quot; Conversion des paramètres statiques en dynamiques
    &quot; -----------------------------------------------------------

    &quot; Initialisation des paramètres de retour du MF
    me-&gt;ms_task_data-task_process-task_container-&gt;mt_function_parameters_output = me-&gt;convert_static_parameters( it_result ).

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Fin de la Tâche
  &quot; -----------------------------------------------------------

  me-&gt;task_stop( ).

ENDMETHOD.</source>
  </method>
 </CLAS>
 <INTF CLSNAME="ZIF_TASK_CONSTANT" VERSION="1" LANGU="F" DESCRIPT="Interface Tâche" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <types CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="TY_FUNCTION_PARAMETERS" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="10 " SRCCOLUMN2="34 " TYPESRC_LENG="232 " TYPESRC="BEGIN OF ty_function_parameters,
      parameter_name               TYPE        string,
      parameter_data               TYPE REF TO data,
      type_for_none_ddic_parameter TYPE        string,
    END OF   ty_function_parameters
"/>
  <types CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="TY_T_FUNCTION_PARAMETERS" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="12 " SRCCOLUMN1="4 " SRCROW2="13 " SRCCOLUMN2="106 " TYPESRC_LENG="177 " TYPESRC="ty_t_function_parameters TYPE SORTED TABLE OF ty_function_parameters
                                                  WITH NON-UNIQUE KEY primary_key COMPONENTS parameter_name
"/>
  <types CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="TY_TASK_ATTACHED_DATA" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="15 " SRCCOLUMN1="4 " SRCROW2="18 " SRCCOLUMN2="33 " TYPESRC_LENG="127 " TYPESRC="BEGIN OF ty_task_attached_data,
      name TYPE        string,
      data TYPE REF TO data,
    END OF   ty_task_attached_data
"/>
  <types CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="TY_T_TASK_ATTACHED_DATA" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="20 " SRCCOLUMN1="4 " SRCROW2="21 " SRCCOLUMN2="81 " TYPESRC_LENG="150 " TYPESRC="ty_t_task_attached_data TYPE SORTED TABLE OF ty_task_attached_data
                                       WITH UNIQUE KEY primary_key COMPONENTS name
"/>
  <typeUsage CLSNAME="ZIF_TASK_CONSTANT" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_MESSAGE_CLASS_ID" VERSION="1" LANGU="F" DESCRIPT="Domaine fonctionnel" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="2" ATTVALUE="&apos;ZTASK&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ARBGB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_PARAMETER_KIND_CHANGING" VERSION="1" LANGU="F" DESCRIPT="Changing" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="2" ATTVALUE="ABAP_FUNC_CHANGING" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_FUNC_PARMBIND-KIND" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_PARAMETER_KIND_EXCEPTION" VERSION="1" LANGU="F" DESCRIPT="Exception" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="&apos;99&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_FUNC_PARMBIND-KIND" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_PARAMETER_KIND_EXPORTING" VERSION="1" LANGU="F" DESCRIPT="Exporting" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="2" ATTVALUE="ABAP_FUNC_EXPORTING" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_FUNC_PARMBIND-KIND" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_PARAMETER_KIND_IMPORTING" VERSION="1" LANGU="F" DESCRIPT="Importing" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="2" ATTVALUE="ABAP_FUNC_IMPORTING" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_FUNC_PARMBIND-KIND" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_PARAMETER_KIND_TABLES" VERSION="1" LANGU="F" DESCRIPT="Tables" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="2" ATTVALUE="ABAP_FUNC_TABLES" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_FUNC_PARMBIND-KIND" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_PARAMETER_NAME_ERROR" VERSION="1" LANGU="F" DESCRIPT="Erreur" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="2" ATTVALUE="&apos;ERROR&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 </INTF>
 <MSAG ARBGB="ZTASK" MASTERLANG="F" RESPUSER="OVEHIER" STEXT="Tâche - Classe de message">
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="000" TEXT="[ Tâche ]"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="002" TEXT="[Tâche &amp;] : Le MF &amp; n&apos;existe pas"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="003" TEXT="[Tâche &amp;] : Le MF est obligatoire en cas de non utilisation du mode dedié"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="005" TEXT="[Tâche &amp;] : Impossible de traiter le paramètre &amp;"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="006" TEXT="[Tâche &amp;] : Une erreur est survenue lors du traitement des paramètres"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="100" TEXT="[ Manager Tâche ]"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="105" TEXT="Le groupe de serveur &amp; n&apos;existe pas."/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="104" TEXT="Le MF &amp; n&apos;existe pas"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="102" TEXT="Le nombre de Tâche doit être un entier positif"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="103" TEXT="Aucune Tâche n&apos;a pu être créé."/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="200" TEXT="[ Handler Tâche ]"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="300" TEXT="[ Container Tâche ]"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="400" TEXT="[ Trace Tâche ]"/>
  <t100t SPRSL="F" ARBGB="ZTASK" STEXT="Tâche - Classe de message"/>
 </MSAG>
 <PROG NAME="Z_TASK_INCLUDE" VARCL="X" SUBC="I" RSTAT="S" RMAND="400" RLOAD="F" UCCHECK="X">
  <textPool>
   <language SPRAS="F">
    <textElement ID="R" ENTRY="Tâche - Include utilisation générique" LENGTH="37 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           Z_TASK_INCLUDE
*&amp;---------------------------------------------------------------------*
*&amp; Include déclaration paramètre de sélection pour utilisation Tâche   *
*&amp;---------------------------------------------------------------------*

***==================================================================***
**                         SELECTION-SCREEN                           **
***==================================================================***

  SELECTION-SCREEN BEGIN OF BLOCK ta WITH FRAME TITLE text-ta1.

  &quot; Activation //
  PARAMETERS : p_pact AS CHECKBOX USER-COMMAND tu1.

  SELECTION-SCREEN BEGIN OF BLOCK tc WITH FRAME TITLE text-tc1.

  &quot; Groupe de Serveur
  PARAMETERS : p_grfc TYPE bdfields-rfcgr MODIF ID tas.

  &quot; Utilisation Groupe par défaut
  PARAMETERS : p_dgrfc AS CHECKBOX MODIF ID tas USER-COMMAND tu3.

  SELECTION-SCREEN END OF BLOCK tc.

  SELECTION-SCREEN SKIP 1.

  &quot; Nombre de Tâche
  PARAMETERS : p_ntask TYPE int4 MODIF ID tas.

  SELECTION-SCREEN SKIP 1.

  SELECTION-SCREEN BEGIN OF BLOCK tb WITH FRAME TITLE text-tb1.

  &quot; Trace
  PARAMETERS : p_ttrac AS CHECKBOX MODIF ID tas USER-COMMAND tu4.

  &quot; Purge de la SHM
  PARAMETERS : p_tshm AS CHECKBOX DEFAULT &apos;X&apos; MODIF ID tas USER-COMMAND tu2.

  SELECTION-SCREEN END OF BLOCK tb.

  SELECTION-SCREEN END OF BLOCK ta.

***------------------------------------------------------------------***
**                             CLASSES                                **
***------------------------------------------------------------------***

*----------------------------------------------------------------------*
*       CLASS LCL_task_include DEFINIION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
  CLASS lcl_task_include DEFINITION FINAL CREATE PRIVATE.

*-- Publique
    PUBLIC SECTION.

***------------------------------------------------------------------***
**                           MÉTHODES                                 **
***------------------------------------------------------------------***

*	Déclaration de méthodes

      &quot; Création instance
      CLASS-METHODS task_manager_factory
        IMPORTING
                  iv_function_name       TYPE rs38l_fnam OPTIONAL
                  is_process_by_form     TYPE ztec_s_task_process_by_form OPTIONAL
                  is_process_by_method   TYPE ztec_s_task_process_by_method OPTIONAL
                    PREFERRED PARAMETER is_process_by_method
        RETURNING VALUE(ro_task_manager) TYPE REF TO zcl_task_manager
        RAISING   zcx_task_manager.

      &quot; Modification Affichage Ecran de sélection
      CLASS-METHODS at_selection_screen_output.

  ENDCLASS.             &quot;lcl_task_include DEFINITION

*----------------------------------------------------------------------*
*       CLASS LCL_task_include IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
  CLASS lcl_task_include IMPLEMENTATION.

    METHOD task_manager_factory.
***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
      DATA :
        lo_cx_exception TYPE REF TO zcx_task_manager.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

      TRY.
          &quot; -----------------------------------------------------------
          &quot; Création de l&apos;instance
          &quot; -----------------------------------------------------------

          &quot; Création de l&apos;instance
          CREATE OBJECT ro_task_manager
            EXPORTING
              iv_grfc              = p_grfc
              iv_task_max          = p_ntask
              iv_task_trace        = p_ttrac
              iv_manage_shm        = p_tshm
              is_process_by_form   = is_process_by_form
              is_process_by_method = is_process_by_method.

        CATCH zcx_task_manager INTO lo_cx_exception.
          &quot; Une erreur est survenue
          &quot;&quot;  --&gt; Récupération de l&apos;erreur
          WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception ?= lo_cx_exception-&gt;previous. ENDWHILE.

          &quot;&quot;  --&gt; Lève l&apos;Exception
          RAISE EXCEPTION TYPE zcx_task_manager
            EXPORTING
              previous = lo_cx_exception.

      ENDTRY.

    ENDMETHOD.

    METHOD at_selection_screen_output.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

      LOOP AT SCREEN.

        &quot; Suivant le groupe
        CASE screen-group1.

          WHEN &apos;TAS&apos;.                                       &quot;#EC NOTEXT
            &quot; Groupe //
            IF p_pact EQ abap_true.
              &quot;&quot;  --&gt; Activation de la //
              screen-input     = 1.
              screen-active    = 1.
              screen-invisible = 0.

            ELSE.
              &quot;&quot;  --&gt; Désactivation de la //
              screen-input     = 0.
              screen-active    = 0.
              screen-invisible = 1.

              &quot;&quot;  --&gt; Réinitialisation paramètre
              CLEAR : p_grfc, p_ntask.

            ENDIF.

            CASE screen-name.

              WHEN &apos;P_GRFC&apos;.
                &quot; Groupe de Serveur
                IF p_dgrfc EQ abap_true.
                  &quot; Utiilisation Groupe de Serveur par défaut
                  &quot;&quot;  --&gt; Grise la zone de saisie
                  screen-input = 0.

                  &quot;&quot;  --&gt; Réinitialisation de sa valeur
                  CLEAR : p_grfc.

                ELSE.
                  &quot; Utilisation Groupe de Serveur spécifique
                  &quot;&quot;  --&gt; Activation zone de saisie
                  screen-input = 1.

                ENDIF.

              WHEN OTHERS.
                &quot; Autre

            ENDCASE.


          WHEN OTHERS.
            &quot; Autres
            &quot;&quot;  --&gt; Passe à l&apos;itération suivante
            CONTINUE.

        ENDCASE.

        &quot; Application des modifications
        MODIFY SCREEN.

      ENDLOOP.

    ENDMETHOD.

  ENDCLASS.


***==================================================================***
**                            MODELES                                 **
***==================================================================***


*  METHODS at_eot IMPORTING iv_function_name TYPE funcname
*                           it_result        TYPE zif_task_constant=&gt;ty_t_function_parameters
*                           it_attached_data TYPE zif_task_constant=&gt;ty_t_task_attached_data
*                           iv_error         TYPE flag.
*
*  METHOD at_eot.
*
****------------------------------------------------------------------***
***                          FIELD-SYMBOLS                             **
****------------------------------------------------------------------***
*    FIELD-SYMBOLS :
*      &lt;lfs_s_result&gt; TYPE zif_task_constant=&gt;ty_function_parameters.
*
****==================================================================***
***                           TRAITEMENT                               **
****==================================================================***
*
*    &quot; -----------------------------------------------------------
*    &quot; Contrôle présence d&apos;erreur
*    &quot; -----------------------------------------------------------
*
*    IF iv_error EQ abap_true.
*      &quot; Une erreur est survenue
*      &quot;&quot;  --&gt; Récupération de l&apos;erreur
*      READ TABLE it_result WITH TABLE KEY parameter_name = zif_task_constant=&gt;mc_parameter_name_error
*                                ASSIGNING &lt;lfs_s_result&gt;.
*      IF sy-subrc EQ 0.
*        &quot; Exploitation de l&apos;erreur
**        WRITE : &lt;lfs_s_result&gt;-parameter_data-&gt;*.
*
*      ENDIF.
*
*    ENDIF.
*
*    &quot; -----------------------------------------------------------
*    &quot; Récupération données traitement
*    &quot; -----------------------------------------------------------
*
*    &quot; Suivant le MF
*    CASE iv_function_name.
*
*      WHEN &apos;MF&apos;.
*
*      WHEN OTHERS.
*        &quot; Autres // Non exploité
*        &quot;&quot;  --&gt; Arrêt du traitement
*        RETURN.
*
*    ENDCASE.
*
*  ENDMETHOD.
*
**&amp;---------------------------------------------------------------------*
**&amp;       FORM AT_EOT                                                   *
**&amp;---------------------------------------------------------------------*
**       Routine réception fin d&apos;une Tâche                              *
**----------------------------------------------------------------------*
**  --&gt;  IV_FUNCTION_NAME      Nom de fonction
**  --&gt;  IT_RESULT             Table résultat traitement
**  --&gt;  IT_ATTACHED_DATA      Table données contextuelles
**  --&gt;  IV_ERROR              Erreur survenue ?
**----------------------------------------------------------------------*
*  FORM at_eot
*  USING iv_function_name TYPE funcname
*        it_result        TYPE zif_task_constant=&gt;ty_t_function_parameters
*        it_attached_data TYPE zif_task_constant=&gt;ty_t_task_attached_data
*        iv_error         TYPE flag.
*
****------------------------------------------------------------------***
***                          FIELD-SYMBOLS                             **
****------------------------------------------------------------------***
*    FIELD-SYMBOLS :
*      &lt;lfs_s_result&gt; TYPE zif_task_constant=&gt;ty_function_parameters.
*
****==================================================================***
***                           TRAITEMENT                               **
****==================================================================***
*
*    &quot; -----------------------------------------------------------
*    &quot; Contrôle présence d&apos;erreur
*    &quot; -----------------------------------------------------------
*
*    IF iv_error EQ abap_true.
*      &quot; Une erreur est survenue
*      &quot;&quot;  --&gt; Récupération de l&apos;erreur
*      READ TABLE it_result WITH TABLE KEY parameter_name = zif_task_constant=&gt;mc_parameter_name_error
*                                ASSIGNING &lt;lfs_s_result&gt;.
*      IF sy-subrc EQ 0.
*        &quot; Exploitation de l&apos;erreur
**        WRITE : &lt;lfs_s_result&gt;-parameter_data-&gt;*.
*
*      ENDIF.
*
*    ENDIF.
*
*    &quot; -----------------------------------------------------------
*    &quot; Récupération données traitement
*    &quot; -----------------------------------------------------------
*
*    &quot; Suivant le MF
*    CASE iv_function_name.
*
*      WHEN &apos;MF&apos;.
*
*      WHEN OTHERS.
*        &quot; Autres // Non exploité
*        &quot;&quot;  --&gt; Arrêt du traitement
*        RETURN.
*
*    ENDCASE.
*
*  ENDFORM.</source>
 </PROG>
 <TABL TABNAME="ZTEC_S_TASK_TRACE_PARAM" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Tâche - Paramètre de Trace" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_TASK_TRACE_PARAM" FIELDNAME="TRACE_ACTIVE" DDLANGUAGE="F" POSITION="0001" ROLLNAME="ZTRACE_XFELD" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="12" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Trace - Activation de trace" REPTEXT="Trace active" SCRTEXT_S="Trace" SCRTEXT_M="Trace active" SCRTEXT_L="Trace active" DOMNAME3L="XFELD" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_TRACE_PARAM" FIELDNAME="TRACE_MEMORY" DDLANGUAGE="F" POSITION="0002" ROLLNAME="ZTRACE_MEM_XFELD" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="20" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Trace - Activation Trace mémoire" REPTEXT="Trace mémoire active" SCRTEXT_S="Trace mém" SCRTEXT_M="Trace mémoire active" SCRTEXT_L="Trace mémoire active" DOMNAME3L="XFELD" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
</nugget>
