<?xml version="1.0" encoding="utf-8"?>
<nugget name="NUGG_TASK_V10.1">
 <CLAS CLSNAME="ZCL_IM_WB_OBJ_CTMENU" VERSION="1" LANGU="F" DESCRIPT="Classe d&apos;implémentation pour implémentation de Business Add-" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <implementing CLSNAME="ZCL_IM_WB_OBJ_CTMENU" REFCLSNAME="IF_EX_WB_OBJ_CTMENU" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <textPool>
   <language SPRAS="F">
    <textElement ID="I" KEY="A01" ENTRY="Assistant" LENGTH="19 "/>
    <textElement ID="I" KEY="N01" ENTRY="Cadriciel Tâche" LENGTH="15 "/>
   </language>
  </textPool>
  <attribute CLSNAME="ZCL_IM_WB_OBJ_CTMENU" CMPNAME="MC_FC_TASK_WZ" VERSION="1" LANGU="F" DESCRIPT="Code de fonction" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="1" ATTVALUE="&apos;Z_WZ_TASK&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="UI_FUNC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_IM_WB_OBJ_CTMENU" CMPNAME="MO_TASK_CONTEXT_MENU" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="3" TYPE="CL_CTMENU" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_IM_WB_OBJ_CTMENU" CPDNAME="IF_EX_WB_OBJ_CTMENU~UPDATE_CONTEXT_MENU">
   <source>METHOD if_ex_wb_obj_ctmenu~update_context_menu.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Ajout Menu Contextuelle personnalisé
  &quot; -----------------------------------------------------------

  &quot; Suivant le Noeud séléctionné
  CASE flt_val.

    WHEN &apos;P&apos;.                                               &quot;#EC NOTEXT
      &quot; Programme
      &quot;&quot;  --&gt; Ajout Elèment Menu Contextuelle lié aux Tâches
      me-&gt;task_ctxt_menu_add( p_context_menu ).

    WHEN OTHERS.
      &quot; Autres

  ENDCASE.

ENDMETHOD.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_IM_WB_OBJ_CTMENU" CMPNAME="CLASS_CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CLASS_CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD class_constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CLASS_CONSTRUCTOR                                 *
*&amp; Classe          : ZCL_IM_WB_OBJ_CTMENU                              *
*&amp; Description     : Constructeur Statique - Menu Contextuel           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Initialisation Attributs
  &quot; -----------------------------------------------------------

  IF NOT zcl_im_wb_obj_ctmenu=&gt;mo_task_context_menu IS BOUND.
    &quot; Menu Contextuel Tâche non créé
    &quot;&quot;  --&gt; Création du Menu Contextuel
    zcl_im_wb_obj_ctmenu=&gt;task_ctxt_menu_set( ).

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_IM_WB_OBJ_CTMENU" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_IM_WB_OBJ_CTMENU                              *
*&amp; Description     : Constructeur BADI Modif. Menu Contextuel          *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Initialisation Attributs
  &quot; -----------------------------------------------------------

  IF NOT zcl_im_wb_obj_ctmenu=&gt;mo_task_context_menu IS BOUND.
    &quot; Menu Contextuel Tâche non créé
    &quot;&quot;  --&gt; Création du Menu Contextuel
    zcl_im_wb_obj_ctmenu=&gt;task_ctxt_menu_set( ).

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_IM_WB_OBJ_CTMENU" CMPNAME="TASK_CTXT_MENU_ADD" VERSION="1" LANGU="F" DESCRIPT="Tâche - Menu Contextuel - Ajout" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_IM_WB_OBJ_CTMENU" CMPNAME="TASK_CTXT_MENU_ADD" SCONAME="IO_CONTEXT_MENU" VERSION="1" LANGU="F" DESCRIPT="Context Menu" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_CTMENU"/>
   <source>METHOD task_ctxt_menu_add.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_CTXT_MENU_ADD                                *
*&amp; Classe          : ZCL_IM_WB_OBJ_CTMENU                              *
*&amp; Description     : Tâche - Menu Contextuel - Ajout au Standard       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Ajout du Groupe Tâche dans le Menu Contextuel
  &quot; -----------------------------------------------------------

  IF NOT zcl_im_wb_obj_ctmenu=&gt;mo_task_context_menu IS BOUND.
    &quot; Menu Contextuel Tâche non créé
    &quot;&quot;  --&gt; Création du Menu Contextuel
    zcl_im_wb_obj_ctmenu=&gt;task_ctxt_menu_set( ).

  ENDIF.

  &quot; Ajout Sous-Menu Tâche
  io_context_menu-&gt;add_separator( ).
  io_context_menu-&gt;add_submenu(
      menu = zcl_im_wb_obj_ctmenu=&gt;mo_task_context_menu
      text = text-n01
  ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_IM_WB_OBJ_CTMENU" CMPNAME="TASK_CTXT_MENU_SET" VERSION="1" LANGU="F" DESCRIPT="Tâche - Menu Contextuel - Initialisation" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD task_ctxt_menu_set.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_CTXT_MENU_SET                                *
*&amp; Classe          : ZCL_IM_WB_OBJ_CTMENU                              *
*&amp; Description     : Tâche - Menu Contextuel - Initialisation          *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Tâche - Création du Menu Contextuel
  &quot; -----------------------------------------------------------

  IF zcl_im_wb_obj_ctmenu=&gt;mo_task_context_menu IS BOUND.
    &quot; Menu Contextuel déjà initialisé
    &quot;&quot;  --&gt; Arrêt du traitemetn
    RETURN.

  ENDIF.

  &quot; Création instance du Menu Contextuel
  zcl_im_wb_obj_ctmenu=&gt;mo_task_context_menu = NEW cl_ctmenu( ).

  &quot; -----------------------------------------------------------
  &quot; Ajout des Fonctions
  &quot; -----------------------------------------------------------

  &quot; Ajout Fonction - Assistant
  zcl_im_wb_obj_ctmenu=&gt;mo_task_context_menu-&gt;add_function(
      fcode             = mc_fc_task_wz
      text              = text-a01
  ).

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" VERSION="1" LANGU="F" DESCRIPT="Manager de Tâche Simplifié - Instance" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="TS_CONFIGURATION" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="4 " SRCROW2="14 " SRCCOLUMN2="28 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_configuration.
            INCLUDE TYPE zcl_task_manager=&gt;ts_task_process_configuration.
    TYPES :
      shm_management    TYPE zshm_management,
      task_call_process TYPE ztec_s_task_call_process,
      END OF ts_configuration
"/>
  <types CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="TS_TASK_MANAGER_CONF_SIMPLIFY" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="16 " SRCCOLUMN1="4 " SRCROW2="19 " SRCCOLUMN2="43 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_task_manager_conf_simplify,
        server TYPE zcl_task_manager=&gt;ts_task_server_configuration,
        configuration TYPE zcl_task_manager_simplify=&gt;ts_configuration,
      END OF   ts_task_manager_conf_simplify
"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <typeClasDef CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" TYPEGROUP="ZCL_TASK_MANAGER" VERSION="1" TPUTYPE="1" IMPLICIT="X"/>
  <typeClasDef CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" TYPEGROUP="ZCL_TASK_MANAGER_SIMPLIFY" VERSION="1" TPUTYPE="1" IMPLICIT="X"/>
  <typeIntfDef CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" TYPEGROUP="ZIF_TASK_CONSTANT" VERSION="1" TPUTYPE="2" IMPLICIT="X"/>
  <attribute CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="MO_TASK_MANAGER" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_TASK_MANAGER" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="MT_RESULT" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_FUNCTION_PARAMETERS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="AT_EOT" VERSION="1" LANGU="F" DESCRIPT="Handler : Fin d&apos;une Tâche" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="AT_EOT" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement à lancer" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_CALL_PROCESS"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="AT_EOT" SCONAME="IT_RESULT" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_FUNCTION_PARAMETERS" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="AT_EOT" SCONAME="IT_ATTACHED_DATA" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_TASK_ATTACHED_DATA" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="AT_EOT" SCONAME="IV_ERROR" VERSION="1" LANGU="F" DESCRIPT="Valeur de vérité XSD : vrai/faux [ext.]" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <source>METHOD at_eot.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Ajout des données de retour
  &quot; -----------------------------------------------------------

  IF NOT it_result[] IS INITIAL.
    &quot; Ajout des données de retour
    INSERT LINES OF it_result INTO TABLE me-&gt;mt_result.

  ENDIF.

*  &quot; -----------------------------------------------------------
*  &quot; Traitement Présence d&apos;Erreur
*  &quot; -----------------------------------------------------------
*
*  IF iv_error EQ abap_true.
*    &quot; Une erreur est survenue
*    &quot;&quot;  --&gt; Récupération de l&apos;erreur
*    ASSIGN it_result[ parameter_name = zif_task_constant=&gt;mc_parameter_name_error ]
*        TO &lt;lfs_s_result&gt;.                                  &quot;#EC NOTEXT
*
*  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CONSTRUCTOR" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="CONSTRUCTOR" SCONAME="IS_TASK_MANAGER_CONFIGURATION" VERSION="1" LANGU="F" DESCRIPT="Configuration du Manager de Tâche Simplifié" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZCL_TASK_MANAGER_SIMPLIFY=&gt;TS_TASK_MANAGER_CONF_SIMPLIFY"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="CONSTRUCTOR" SCONAME="IV_OVERLOAD_COMPRESS_CONF" VERSION="1" LANGU="F" DESCRIPT="Ne pas utiliser la configuration de compression par défaut" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="CONSTRUCTOR" SCONAME="IV_OVERLOAD_SHM_MANAGEMENT" VERSION="1" LANGU="F" DESCRIPT="Ne pas utiliser la conf de gestion de la SHM par défaut" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <exception CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="CONSTRUCTOR" SCONAME="ZCX_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Manager Tâche" MTDTYPE="2" EDITORDER="1 "/>
   <source>METHOD constructor.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
        ls_task_manager_configuration TYPE zcl_task_manager=&gt;ts_task_manager_configuration.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Génération instance Manager de Tâche
      &quot; -----------------------------------------------------------

      &quot; Initialisation Configuration Manager
      ls_task_manager_configuration = VALUE #(
        grfc = is_task_manager_configuration-server-grfc
        task_max = is_task_manager_configuration-server-task_max
        use_server_default = is_task_manager_configuration-server-use_server_default
        global_configuration = VALUE #(
          dedicated_mode      = abap_true
          shm_management      = is_task_manager_configuration-configuration-shm_management
          task_call_process   = is_task_manager_configuration-configuration-task_call_process
          task_trace_param    = is_task_manager_configuration-configuration-task_trace_param
          task_compress_activ = is_task_manager_configuration-configuration-task_call_process
          task_compress_param = is_task_manager_configuration-configuration-task_compress_param
        )
      ).

      &quot; Initialisation traitement de fin
      ls_task_manager_configuration-global_configuration-process_by_method = VALUE #(
        after = VALUE #(
          method   = &apos;AT_EOT&apos; &quot;#EC NOTEXT
          instance = me
        )
      ).

      &quot; Génération instance Manager de Tâche
      me-&gt;mo_task_manager = NEW zcl_task_manager(
        is_task_manager_configuration = ls_task_manager_configuration
        iv_overload_compress_conf     = iv_overload_compress_conf
        iv_overload_shm_management    = iv_overload_shm_management
      ).

    CATCH zcx_task_manager INTO DATA(lo_cx_task_manager).
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Retourne l&apos;Exception
      RAISE EXCEPTION TYPE zcx_task_manager
        EXPORTING
          previous = lo_cx_task_manager.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="EXECUTE" VERSION="1" LANGU="F" DESCRIPT="Exécution" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="EXECUTE" SCONAME="IS_TASK_MANAGER_CONFIGURATION" VERSION="1" LANGU="F" DESCRIPT="Configuration du Manager de Tâche Simplifié" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZCL_TASK_MANAGER_SIMPLIFY=&gt;TS_TASK_MANAGER_CONF_SIMPLIFY"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="EXECUTE" SCONAME="IV_OVERLOAD_COMPRESS_CONF" VERSION="1" LANGU="F" DESCRIPT="Ne pas utiliser la configuration de compression par défaut" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="EXECUTE" SCONAME="IV_OVERLOAD_SHM_MANAGEMENT" VERSION="1" LANGU="F" DESCRIPT="Ne pas utiliser la conf de gestion de la SHM par défaut" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="EXECUTE" SCONAME="IT_PROCESS_PARAMETERS" VERSION="1" LANGU="F" DESCRIPT="Table des paramètres des traitements" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STANDARD TABLE"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="EXECUTE" SCONAME="IV_PROCESS_HAS_RESULT" VERSION="1" LANGU="F" DESCRIPT="Le traitement à un retour ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="EXECUTE" SCONAME="RT_RESULT" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_FUNCTION_PARAMETERS"/>
   <exception CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="EXECUTE" SCONAME="ZCX_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Manager Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD execute.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Principe de fonctionnement :
  &quot; -----------------------------------------------------------
  &quot;   Permet de lancer des traitements en paralléle
  &quot;   portant sur la même fonction (Méthode / Programme / MF)
  &quot; -----------------------------------------------------------
  &quot;     o IS_TASK_MANAGER_CONFIGURATION : Voir fonctionnnement
  &quot;       dans ZCL_TASK_MANAGER
  &quot;     o IV_OVERLOAD_COMPRESS_CONF     : Force l&apos;usage de
  &quot;       la configuration transmise
  &quot;     o IV_OVERLOAD_SHM_MANAGEMENT    : Force l&apos;usage de
  &quot;       la configuration transmise
  &quot; -----------------------------------------------------------
  &quot;     o IT_PROCESS_PARAMETERS         : Table des paramètres
  &quot;       Cette table, doit être construite de la manière
  &quot;       suivante :
  &quot;         - le nom des champs doit correspondre
  &quot;           aux noms des paramètres d&apos;appel du traitement
  &quot;         - 1 ligne = 1 appel au traitemment
  &quot; -----------------------------------------------------------
  &quot;     o IV_PROCESS_HAS_RESULT        : Les traitements
  &quot;       lancées ont-il un résultat ?
  &quot;       Si ce champ est valorisé et que la table de retour
  &quot;       est demandé, alors on attend la fin des traitements
  &quot;       Sinon, on laisse se finir les Tâches tranquillement
  &quot; -----------------------------------------------------------

  &quot; -----------------------------------------------------------
  &quot; Contrôle
  &quot; -----------------------------------------------------------

  IF is_task_manager_configuration-configuration-task_call_process IS INITIAL.
    &quot; En mode simplifié le traitement à appeler est obligatoire (Mode dédié)
    RAISE EXCEPTION TYPE zcx_task_manager
      EXPORTING
        textid = VALUE #( msgid = zif_task_constant=&gt;mc_message_class_id msgno = 106 ).

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Génération instance Manager simplifié
      &quot; -----------------------------------------------------------

      &quot; Génération
      DATA(lo_task_manager_simplify) = NEW zcl_task_manager_simplify(
        iv_overload_compress_conf     = iv_overload_compress_conf
        iv_overload_shm_management    = iv_overload_shm_management
        is_task_manager_configuration = is_task_manager_configuration
      ).

      &quot; -----------------------------------------------------------
      &quot; Exécution du Traitement
      &quot; -----------------------------------------------------------

      &quot; Exécute le traitement
      lo_task_manager_simplify-&gt;process_run( it_process_parameters ).

      IF rt_result IS SUPPLIED AND iv_process_has_result EQ abap_true.
        &quot; -----------------------------------------------------------
        &quot; Récupération des données
        &quot; -----------------------------------------------------------

        &quot; Récupération des données
        rt_result = lo_task_manager_simplify-&gt;process_result_get( ).

      ENDIF.

    CATCH zcx_task_manager INTO DATA(lo_cx_task_manager).
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Lève l&apos;Exception
      RAISE EXCEPTION TYPE zcx_task_manager
        EXPORTING
          previous = lo_cx_task_manager.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="PROCESS_RESULT_GET" VERSION="1" LANGU="F" DESCRIPT="Récupération données issues des traitements" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="PROCESS_RESULT_GET" SCONAME="RT_RESULT" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_FUNCTION_PARAMETERS"/>
   <source>METHOD process_result_get.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Retourne les paramètres de retour
  &quot; -----------------------------------------------------------

  &quot; Attente fin des Tâches encore en cours de traitement
  me-&gt;mo_task_manager-&gt;task_finish_running( ).

  &quot; Retourne les paramètres de retour
  rt_result[] = me-&gt;mt_result[].

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="PROCESS_RUN" VERSION="1" LANGU="F" DESCRIPT="Lancement du traitement" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER_SIMPLIFY" CMPNAME="PROCESS_RUN" SCONAME="IT_PROCESS_PARAMETERS" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STANDARD TABLE"/>
   <source>METHOD process_run.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_table_descr  TYPE REF TO cl_abap_tabledescr,
    lo_struct_descr TYPE REF TO cl_abap_structdescr.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_component&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération composition des paramètres
  &quot; -----------------------------------------------------------

  &quot; Récupération définition de la table
  lo_table_descr ?= cl_abap_tabledescr=&gt;describe_by_data( it_process_parameters ).

  &quot; Récupération définition de la structure
  lo_struct_descr ?= lo_table_descr-&gt;get_table_line_type( ).

  &quot; Récupération Container
  DATA(lo_task_container) = me-&gt;mo_task_manager-&gt;container_task_create( ).

  &quot; -----------------------------------------------------------
  &quot; Lancement des Traitements
  &quot; -----------------------------------------------------------

  &quot; Chaque ligne correspond à un appel différent
  LOOP AT it_process_parameters ASSIGNING FIELD-SYMBOL(&lt;lfs_s_process_parameters&gt;).

    &quot; Récupération de chaque paramètre d&apos;appel
    LOOP AT lo_struct_descr-&gt;components ASSIGNING FIELD-SYMBOL(&lt;lfs_s_components&gt;).

      &quot; Initialisation pointeur sur la valeur du champ correspondant
      ASSIGN COMPONENT &lt;lfs_s_components&gt;-name OF STRUCTURE &lt;lfs_s_process_parameters&gt;
                                                         TO &lt;lfs_component&gt;.
      IF sy-subrc NE 0.
        &quot; Aucune correspondance
        &quot;&quot;  --&gt; Passe à l&apos;itération suivante
        CONTINUE.

      ENDIF.

      &quot; Ajout du paramètre
      lo_task_container-&gt;function_parameter_add(
        iv_parameter_name = &lt;lfs_s_components&gt;-name
        ix_parameter_data = &lt;lfs_component&gt;
      ).

    ENDLOOP.

    TRY.
        &quot; Lance la Tâche
        me-&gt;mo_task_manager-&gt;task_start_new( lo_task_container ).

      CATCH zcx_task_manager.
        &quot; Une erreur est survenue

    ENDTRY.

    &quot; Réinitialisation Container
    lo_task_container-&gt;reset( ).

  ENDLOOP.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Manager de Tâche - Gestion de la //" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZTASK" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TS_TASK_LIST" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="8 " SRCCOLUMN2="26 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_task_list,
        task_id       TYPE        zcl_task=&gt;ts_task-task_id,
        task_running  TYPE REF TO zcl_task=&gt;ts_task-task_running,
        task_instance TYPE REF TO zcl_task,
      END OF   ts_task_list
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TT_TASK_LIST" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="10 " SRCCOLUMN1="4 " SRCROW2="11 " SRCCOLUMN2="77 " TYPESRC_LENG="0 " TYPESRC="tt_task_list TYPE SORTED TABLE OF ts_task_list
                                WITH UNIQUE KEY primary_key COMPONENTS task_id
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TS_TFDIR" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="4 " SRCROW2="16 " SRCCOLUMN2="20 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_tfdir,
      funcname  TYPE tfdir-funcname,
      not_found TYPE xsdboolean,
    END OF   ts_tfdir
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TT_TFDIR" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="18 " SRCCOLUMN1="4 " SRCROW2="19 " SRCCOLUMN2="72 " TYPESRC_LENG="0 " TYPESRC="tt_tfdir TYPE SORTED TABLE OF ts_tfdir
                          WITH UNIQUE KEY primary_key COMPONENTS funcname
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TS_SEOCOMPODF" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="5 " TYPTYPE="4" SRCROW1="21 " SRCCOLUMN1="4 " SRCROW2="25 " SRCCOLUMN2="25 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_seocompodf,
      clsname   TYPE seocompodf-clsname,
      cmpname   TYPE seocompodf-cmpname,
      not_found TYPE xsdboolean,
    END OF   ts_seocompodf
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TT_SEOCOMPODF" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="6 " TYPTYPE="4" SRCROW1="27 " SRCCOLUMN1="4 " SRCROW2="28 " SRCCOLUMN2="67 " TYPESRC_LENG="0 " TYPESRC="tt_seocompodf TYPE SORTED TABLE OF ts_seocompodf
          WITH NON-UNIQUE KEY primary_key COMPONENTS clsname cmpname
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TS_SEOSUBCODF" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="7 " TYPTYPE="4" SRCROW1="30 " SRCCOLUMN1="4 " SRCROW2="34 " SRCCOLUMN2="29 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_seosubcodf,
          clsname TYPE seosubcodf-clsname,
          cmpname TYPE seosubcodf-clsname,
          count   TYPE sy-dbcnt,
        END OF   ts_seosubcodf
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TT_SEOSUBCODF" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="8 " TYPTYPE="4" SRCROW1="36 " SRCCOLUMN1="4 " SRCROW2="37 " SRCCOLUMN2="69 " TYPESRC_LENG="0 " TYPESRC="tt_seosubcodf TYPE SORTED TABLE OF ts_seosubcodf
            WITH NON-UNIQUE KEY primary_key COMPONENTS clsname cmpname
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TS_TRDIR" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="9 " TYPTYPE="4" SRCROW1="39 " SRCCOLUMN1="4 " SRCROW2="43 " SRCCOLUMN2="20 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_trdir,
      name TYPE trdir-name,
      subc TYPE trdir-subc,
      not_found TYPE xsdboolean,
    END OF   ts_trdir
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TT_TRDIR" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="10 " TYPTYPE="4" SRCROW1="45 " SRCCOLUMN1="4 " SRCROW2="46 " SRCCOLUMN2="50 " TYPESRC_LENG="0 " TYPESRC="tt_trdir TYPE SORTED TABLE OF ts_trdir
        WITH UNIQUE KEY primary_key COMPONENTS name
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TS_RZLLITAB" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="11 " TYPTYPE="4" SRCROW1="48 " SRCCOLUMN1="4 " SRCROW2="51 " SRCCOLUMN2="23 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_rzllitab,
      classname TYPE rzllitab-classname,
      not_found TYPE xsdboolean,
    END OF   ts_rzllitab
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TT_RZLLITAB" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="12 " TYPTYPE="4" SRCROW1="53 " SRCCOLUMN1="4 " SRCROW2="54 " SRCCOLUMN2="76 " TYPESRC_LENG="0 " TYPESRC="tt_rzllitab TYPE SORTED TABLE OF ts_rzllitab
                             WITH UNIQUE KEY primary_key COMPONENTS classname
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TS_TASK_MANAGER_DATA" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="13 " TYPTYPE="4" SRCROW1="56 " SRCCOLUMN1="4 " SRCROW2="65 " SRCCOLUMN2="32 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_task_manager_data,
      task_manager_id          TYPE        ztask_manager_id,
      shm_management  TYPE zshm_management,
      dedicated_mode TYPE xsdboolean,
      t_task_list              TYPE        zcl_task_manager=&gt;tt_task_list,
      t_definition_type_in_shm TYPE        stringtab,
      o_task_trace             TYPE REF TO zcl_task_trace,
      o_task_handler           TYPE REF TO zcl_task_handler,
      task_process_configuration TYPE ZCL_TASK_MANAGER=&gt;ts_task_process_configuration,
    END OF   ts_task_manager_data
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TS_PERSISTENT_DATA" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="14 " TYPTYPE="4" SRCROW1="67 " SRCCOLUMN1="4 " SRCROW2="73 " SRCCOLUMN2="34 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_persistent_data,
          T_TRDIR type ZCL_TASK_MANAGER=&gt;TT_TRDIR,
          T_TFDIR type ZCL_TASK_MANAGER=&gt;TT_TFDIR,
          T_RZLLITAB type ZCL_TASK_MANAGER=&gt;TT_RZLLITAB,
      T_SEOCOMPODF TYPE zcl_task_manager=&gt;tt_seocompodf,
      T_SEOSUBCODF TYPE zcl_task_manager=&gt;tt_seosubcodf,
        END OF   ts_persistent_data
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TS_PROCESS_BY_METHOD" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="11 " SRCCOLUMN1="4 " SRCROW2="14 " SRCCOLUMN2="34 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF   ts_process_by_method,
        before TYPE ztec_s_task_process_by_method,
        after  TYPE ztec_s_task_process_by_method,
      END OF   ts_process_by_method
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TS_PROCESS_BY_FORM" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="16 " SRCCOLUMN1="4 " SRCROW2="19 " SRCCOLUMN2="32 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_process_by_form,
        before TYPE ztec_s_task_process_by_form,
        after  TYPE ztec_s_task_process_by_form,
      END OF   ts_process_by_form
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TS_TASK_PROCESS_CONFIGURATION" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="21 " SRCCOLUMN1="4 " SRCROW2="25 " SRCCOLUMN2="43 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_task_process_configuration,
        task_trace_param    TYPE ztec_s_task_trace_param,
        task_compress_activ TYPE xsdboolean,
        task_compress_param TYPE ztec_s_task_compress_param,
      END OF   ts_task_process_configuration
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TS_TASK_MANAGER_GLOBAL_CONF" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="27 " SRCCOLUMN1="4 " SRCROW2="35 " SRCCOLUMN2="41 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_task_manager_global_conf.
            INCLUDE TYPE ts_task_process_configuration.
    TYPES :
      task_call_process TYPE ztec_s_task_call_process,
      shm_management    TYPE zshm_management,
      dedicated_mode    TYPE xsdboolean,
      process_by_form   TYPE zcl_task_manager=&gt;ts_process_by_form,
      process_by_method TYPE zcl_task_manager=&gt;ts_process_by_method,
      END OF   ts_task_manager_global_conf
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TS_TASK_SERVER_CONFIGURATION" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="5 " TYPTYPE="4" SRCROW1="37 " SRCCOLUMN1="4 " SRCROW2="41 " SRCCOLUMN2="42 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_task_server_configuration,
        grfc               TYPE rfcgr,
        use_server_default TYPE xsdboolean,
        task_max           TYPE i,
      END OF   ts_task_server_configuration
"/>
  <types CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TS_TASK_MANAGER_CONFIGURATION" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="6 " TYPTYPE="4" SRCROW1="43 " SRCCOLUMN1="4 " SRCROW2="47 " SRCCOLUMN2="43 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_task_manager_configuration.
            INCLUDE TYPE zcl_task_manager=&gt;ts_task_server_configuration.
    TYPES :
      global_configuration TYPE zcl_task_manager=&gt;ts_task_manager_global_conf,
      END OF   ts_task_manager_configuration
"/>
  <friends CLSNAME="ZCL_TASK_MANAGER" REFCLSNAME="ZCL_TASK_HANDLER" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <events CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MANAGER_END_OF_TASK" VERSION="1" LANGU="F" DESCRIPT="Evènement fin d&apos;une Tâche" EXPOSURE="0" STATE="1" EDITORDER="1 " EVTDECLTYP="0" BCEVTCAT="00">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MANAGER_END_OF_TASK" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement à lancer" CMPTYPE="2" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTEC_S_TASK_CALL_PROCESS" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MANAGER_END_OF_TASK" SCONAME="IT_RESULT" VERSION="1" LANGU="F" DESCRIPT="Table de retour" CMPTYPE="2" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_FUNCTION_PARAMETERS" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MANAGER_END_OF_TASK" SCONAME="IT_ATTACHED_DATA" VERSION="1" LANGU="F" DESCRIPT="Données liées à la Tâche" CMPTYPE="2" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_TASK_ATTACHED_DATA" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MANAGER_END_OF_TASK" SCONAME="IV_ERROR" VERSION="1" LANGU="F" DESCRIPT="Une erreur est survenue ?" CMPTYPE="2" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
  </events>
  <events CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MANAGER_BEFORE_TASK" VERSION="1" LANGU="F" DESCRIPT="Evènement début d&apos;une Tâche" EXPOSURE="0" STATE="1" EDITORDER="2 " EVTDECLTYP="0" BCEVTCAT="00">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MANAGER_BEFORE_TASK" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement à lancer" CMPTYPE="2" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTEC_S_TASK_CALL_PROCESS"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MANAGER_BEFORE_TASK" SCONAME="IO_TASK_CONTAINER" VERSION="1" LANGU="F" DESCRIPT="Container paramètres d&apos;appel" CMPTYPE="2" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK_CONTAINER"/>
  </events>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>*&quot;* use this source file for your ABAP unit test classes</localTestClasses>
  <typeUsage CLSNAME="ZCL_TASK_MANAGER" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <typeClasDef CLSNAME="ZCL_TASK_MANAGER" TYPEGROUP="ZCL_TASK_MANAGER" VERSION="1" TPUTYPE="1" IMPLICIT="X"/>
  <typeIntfDef CLSNAME="ZCL_TASK_MANAGER" TYPEGROUP="ZIF_TASK_CONSTANT" VERSION="1" TPUTYPE="2" IMPLICIT="X"/>
  <attribute CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MS_PERSISTENT_DATA" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_TASK_MANAGER=&gt;TS_PERSISTENT_DATA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_MANAGER" CMPNAME="MS_TASK_MANAGER_DATA" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_TASK_MANAGER=&gt;TS_TASK_MANAGER_DATA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="AT_END_OF_TASK" VERSION="1" LANGU="F" DESCRIPT="Traitement lors de la fin d&apos;une Tâche" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="AT_END_OF_TASK" SCONAME="IO_TASK" VERSION="1" LANGU="F" DESCRIPT="Instance Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_TASK"/>
   <source>METHOD at_end_of_task.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : AT_END_OF_TASK                                    *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Traitement lors de la fin d&apos;une Tâche             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  IF me-&gt;ms_task_manager_data-shm_management   EQ abap_true
  OR io_task-&gt;ms_task_data-shm_manage_by_local EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Stockage des types enregistré dans la SHM
    &quot; -----------------------------------------------------------

    IF NOT io_task-&gt;ms_task_data-task_process-t_definition_type_in_shm[] IS INITIAL.
      &quot; Récupération Liste des Types stockées dans la SHM par la Tâche
      LOOP AT io_task-&gt;ms_task_data-task_process-t_definition_type_in_shm ASSIGNING FIELD-SYMBOL(&lt;lfs_s_definition_type&gt;).

        &quot; Ajout des types utilisés par la Tâche
        READ TABLE me-&gt;ms_task_manager_data-t_definition_type_in_shm WITH KEY table_line = &lt;lfs_s_definition_type&gt;
                                                                 TRANSPORTING NO FIELDS BINARY SEARCH.
        IF sy-subrc NE 0.
          &quot; Type pas encore récupéré
          &quot;&quot;  --&gt; Ajout du Type
          INSERT &lt;lfs_s_definition_type&gt; INTO me-&gt;ms_task_manager_data-t_definition_type_in_shm INDEX sy-tabix.

        ENDIF.

      ENDLOOP.

    ENDIF.

  ENDIF.

  IF NOT io_task-&gt;ms_task_data-task_trace_id IS INITIAL.
    &quot; -----------------------------------------------------------
    &quot; Fin de la Trace d&apos;exécution
    &quot; -----------------------------------------------------------

    &quot; Arrêt de la Trace d&apos;exécution
    me-&gt;trace_task_stop(
      iv_task_trace_id = io_task-&gt;ms_task_data-task_trace_id
      iv_log_immediate = abap_true
    ).

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Libère la Tâche
  &quot; -----------------------------------------------------------

  &quot; Libère la Tâche et réinitialise ses données
  io_task-&gt;task_free( ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="AVAILABLE_PROCESS_GET" VERSION="1" LANGU="F" DESCRIPT="Récupération traitement disponible" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="AVAILABLE_PROCESS_GET" SCONAME="EV_WAIT" VERSION="1" LANGU="F" DESCRIPT="??" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="AVAILABLE_PROCESS_GET" SCONAME="EV_REASON" VERSION="1" LANGU="F" DESCRIPT="??" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="CSEQUENCE"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="AVAILABLE_PROCESS_GET" SCONAME="EV_MAXRES" VERSION="1" LANGU="F" DESCRIPT="Nombre max de tâches" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="AVAILABLE_PROCESS_GET" SCONAME="EV_IREASON" VERSION="1" LANGU="F" DESCRIPT="??" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="AVAILABLE_PROCESS_GET" SCONAME="RV_NORES" VERSION="1" LANGU="F" DESCRIPT="Nombre de tâche disponible" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
   <source>METHOD available_process_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : AVAILABLE_PROCESS_GET                             *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Récupération ressource disponible                 *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR : ev_ireason, ev_reason, ev_maxres, rv_nores, ev_wait.

  &quot; -----------------------------------------------------------
  &quot; Récupération des Ressources disponibles
  &quot; -----------------------------------------------------------

  &quot; Récupération ressource disponible Local
  CALL FUNCTION &apos;TH_ARFC_LOCAL_RESOURCES&apos;
    IMPORTING
      nores   = rv_nores
      wait    = ev_wait
      reason  = ev_reason
      maxres  = ev_maxres
      ireason = ev_ireason.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="COMPRESS_PARAM_EXIST" VERSION="1" LANGU="F" DESCRIPT="Compression - Configuration existe ?" EXPOSURE="0" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="COMPRESS_PARAM_EXIST" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement à lancer" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_CALL_PROCESS"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="COMPRESS_PARAM_EXIST" SCONAME="RV_EXIST" VERSION="1" LANGU="F" DESCRIPT="Entrée existe ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN"/>
   <source>METHOD COMPRESS_PARAM_EXIST.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_COMPRESS_PARAM_EXIST                         *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Configuration compression existe ?                *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération Configuration
  &quot; -----------------------------------------------------------

  zcl_task_param=&gt;task_param_get(
    EXPORTING
      is_task_call_process = is_task_call_process
    IMPORTING
      ev_not_found         = rv_exist
  ).
  rv_exist = boolc( rv_exist IS INITIAL ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="COMPRESS_PARAM_GET" VERSION="1" LANGU="F" DESCRIPT="Compression - Récupération configuration" EXPOSURE="0" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="COMPRESS_PARAM_GET" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement à lancer" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_CALL_PROCESS"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="COMPRESS_PARAM_GET" SCONAME="RS_TASK_COMPRESS_PARAM" VERSION="1" LANGU="F" DESCRIPT="Tâche - Paramètres de compression" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTEC_S_TASK_COMPRESS_PARAM"/>
   <source>METHOD COMPRESS_PARAM_GET.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_COMPRESS_PARAM_GET                           *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Récupération Configuration compression            *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération Configuration
  &quot; -----------------------------------------------------------

  &quot; Récupération configuration de compression
  MOVE-CORRESPONDING zcl_task_param=&gt;task_param_get( is_task_call_process ) TO rs_task_compress_param.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CONSTRUCTOR" SCONAME="IS_TASK_MANAGER_CONFIGURATION" VERSION="1" LANGU="F" DESCRIPT="Configuration du Manager de Tâche" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZCL_TASK_MANAGER=&gt;TS_TASK_MANAGER_CONFIGURATION"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CONSTRUCTOR" SCONAME="IV_OVERLOAD_COMPRESS_CONF" VERSION="1" LANGU="F" DESCRIPT="Ne pas utiliser la configuration de compression par défaut" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CONSTRUCTOR" SCONAME="IV_OVERLOAD_SHM_MANAGEMENT" VERSION="1" LANGU="F" DESCRIPT="Ne pas utiliser la conf de gestion de la SHM par défaut" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <exception CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CONSTRUCTOR" SCONAME="ZCX_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Manager Tâche" MTDTYPE="2" EDITORDER="1 "/>
   <source>METHOD constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Constructeur instance                             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_task_list TYPE zcl_task_manager=&gt;ts_task_list.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception TYPE REF TO cx_root.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_task_max TYPE i.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Note d&apos;utilisation :
  &quot;  - Si le Groupe de Serveur n&apos;est pas renseigné :
  &quot;     Les Tâches vont se lancer sur le serveur par défaut
  &quot;  - Si un traitement à appeler est valorisé, il est transmis
  &quot;     aux Tâches. Par conséquent, ces Tâches ne pourront
  &quot;     exécuter que ce traitement. (Mode dédié)
  &quot;     Dans le cas contraire, chaque Tâche peut lancer
  &quot;     un traitement différent mais le nom du traitement devient
  &quot;     obligatoire lors de l&apos;appel de &quot;TASK_START_NEW&quot;
  &quot;  - Les paramètres renseignées dans &quot;GLOBAL_CONFIGURATION&quot;
  &quot;     seront appliquées à toutes les Tâches sauf si,
  &quot;     lors de l&apos;appel de &quot;TASK_START_NEW&quot; le développeur
  &quot;     précise d&apos;autre paramètres.
  &quot;  - Les paramètres d&apos;appel :
  &quot;     o IV_OVERLOAD_COMPRESS_CONF : Désactive la compression
  &quot;     o IV_OVERLOAD_SHM_MANAGEMENT : Désactive la gestion de la SHM
  &quot; ------------------------------------------------------------
  &quot;  Explication paramètre de configuration globale :
  &quot;  - SHM_MANAGEMENT :
  &quot;     Afin de gérer les types locaux, il peut être
  &quot;     nécessaire de les stocker dans la SHM afin de
  &quot;     pouvoir construire les données dynamiques.
  &quot;     Ainsi, chaque Tâche peut être amener à créer
  &quot;     des entrées dans la SHM. Ainsi, si ce paramètre
  &quot;     est activé (par défaut) la SHM sera purgé automatiquement
  &quot; - TASK_TRACE_PARAM  :
  &quot;     Permet de trace l&apos;exécution des Tâches (table ZTASK_TRACE_H)
  &quot; - TASK_COMPRESS_PARAM :
  &quot;     Permet de configurer la compression des données
  &quot;     Trois options sont disponibles :
  &quot;       o Désactiver :
  &quot;         Coché le paramètre &quot;IV_OVERLOAD_COMPRESS_CONF&quot;
  &quot;       o LIGNE / LIGNE :
  &quot;         Chaque données - liées à un type complexe -
  &quot;         est compressé dans un dossier séparée
  &quot;       o GLOBAL :
  &quot;         Toutes les données - liées à un type complexe -
  &quot;         sont comrpessées dans un même dossier
  &quot; -----------------------------------------------------------
  &quot;  Note d&apos;utilisation sur la compression :
  &quot;   - La compression permet de :
  &quot;       o Réduire la bande passante lors des appels RFC (gain d&apos;environ 325%)
  &quot;       o Réduire le temps de traitement (gain d&apos;environ 34%)
  &quot;   - Suivant la volumétrie des appels il faut utiliser la
  &quot;   configuration ligne / ligne ou globale.
  &quot;   Ainsi, plus la volumétrie est forte plus il est recommandé
  &quot;   d&apos;activer la compression globale.
  &quot; ==================================================================***
  &quot; Résultat d&apos;essai méthode de compression
  &quot;   - Compression off    = Mem allocated : 26,874 + Runtime : 782 079
  &quot;   - Compression off    = Mem allocated : 26,898 + Runtime : 979 196
  &quot;   - Compression off    = Mem allocated : 26,898 + Runtime : 832 852
  &quot;   - Compression l/l    = Mem allocated : 8,42   + Runtime : 727 480
  &quot;   - Compression l/l    = Mem allocated : 8,39   + Runtime : 567 420
  &quot;   - Compression l/l    = Mem allocated : 8,38   + Runtime : 581 081
  &quot;   - Compression global = Mem allocated : 8,14   + Runtime : 562 613
  &quot;   - Compression global = Mem allocated : 8,10   + Runtime : 563 668
  &quot;   - Compression global = Mem allocated : 8,10   + Runtime : 560 351
  &quot; ==================================================================***
  &quot; -----------------------------------------------------------

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Contrôle des données
      &quot; -----------------------------------------------------------
      lv_task_max = me-&gt;_constructor_check(
        iv_grfc              = is_task_manager_configuration-grfc
        iv_use_default_group = is_task_manager_configuration-use_server_default
        iv_dedicated_mode    = is_task_manager_configuration-global_configuration-dedicated_mode
        is_task_call_process = is_task_manager_configuration-global_configuration-task_call_process
      ).

    CATCH zcx_task_manager INTO lo_cx_exception.
      &quot; Les données ne sont pas cohérentes
      &quot;&quot;  --&gt; Lève une Exception
      RAISE EXCEPTION TYPE zcx_task_manager
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

  &quot; -----------------------------------------------------------
  &quot; Détermination nombre de Tâche
  &quot; -----------------------------------------------------------

  IF is_task_manager_configuration-task_max IS INITIAL.
    &quot; Aucune Tâche à  créer
    &quot;&quot;  --&gt; Utilisation Tâche Max. dispo sur le Serveur (initialisé via &quot;CHECK&quot;)

  ELSE.
    &quot; Nombre de Tâche à utiliser transmis
    &quot;&quot;  --&gt; Utilisation de ce nombre de Tâche
    lv_task_max = is_task_manager_configuration-task_max.

  ENDIF.
  IF lv_task_max IS INITIAL.
    &quot; Aucune Tâche à  créer
    &quot;&quot;  --&gt; Lève une Exception
    RAISE EXCEPTION TYPE zcx_task_manager
      EXPORTING
        textid = VALUE #(
          msgid = zif_task_constant=&gt;mc_message_class_id
          msgno = 102
        ).

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Détermination Mode dédiée
  &quot; -----------------------------------------------------------

  me-&gt;ms_task_manager_data-dedicated_mode = boolc(
    NOT is_task_manager_configuration-global_configuration-task_call_process IS INITIAL
  ).

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Génération ID Manager
      &quot; -----------------------------------------------------------

      &quot; Génération GUID Manager
      me-&gt;ms_task_manager_data-task_manager_id = cl_system_uuid=&gt;create_uuid_c32_static( ).

    CATCH cx_uuid_error.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; GUID aléatoire
      me-&gt;ms_task_manager_data-task_manager_id = cl_abap_random=&gt;seed( ).

  ENDTRY.

  &quot; -----------------------------------------------------------
  &quot; Création des Tâches
  &quot; -----------------------------------------------------------

  &quot; Création d&apos;autant de Tâche que nécessaire
  DO lv_task_max TIMES.

    FREE : ls_task_list.

    TRY.
        &quot;&quot;  --&gt; Création d&apos;une instance de Tâche
        CREATE OBJECT ls_task_list-task_instance
          EXPORTING
            iv_grfc              = is_task_manager_configuration-grfc
            iv_manage_shm        = boolc( is_task_manager_configuration-global_configuration-shm_management EQ abap_true OR
                                          is_task_manager_configuration-global_configuration-shm_management EQ iv_overload_shm_management )
            is_task_call_process = is_task_manager_configuration-global_configuration-task_call_process
            iv_task_manager_id   = me-&gt;ms_task_manager_data-task_manager_id.

      CATCH zcx_task INTO lo_cx_exception.
        &quot; Erreur création Tâche
        &quot;&quot;  --&gt; Passe à l&apos;itération suivante
        CONTINUE.

    ENDTRY.

    &quot;&quot;  --&gt; Initialisation ID de la Tâche
    ls_task_list-task_id = ls_task_list-task_instance-&gt;ms_task_data-task_id.

    &quot;&quot;  --&gt; Initialisation &quot;pointeur&quot; sur l&apos;indicateur de traitement de la Tâche
    ls_task_list-task_running = REF #( ls_task_list-task_instance-&gt;ms_task_data-task_running ).

    &quot;&quot;  --&gt; Ajout de la Tâche
    INSERT ls_task_list INTO TABLE me-&gt;ms_task_manager_data-t_task_list.

    &quot;&quot;  --&gt; Souscription aux évènements de :
    SET HANDLER me-&gt;handler_task_end          FOR ls_task_list-task_instance.  &quot;Fin de Tâche
    SET HANDLER me-&gt;handler_task_before       FOR ls_task_list-task_instance.  &quot;Début de Tâche
    SET HANDLER me-&gt;handler_task_error_result FOR ls_task_list-task_instance.  &quot;Tâche en erreur

  ENDDO.

  &quot; -----------------------------------------------------------
  &quot; Création de l&apos;Handler
  &quot; -----------------------------------------------------------

  TRY.
      &quot; Création de l&apos;instance Handler de la Tâche
      me-&gt;ms_task_manager_data-o_task_handler = zcl_task_handler=&gt;handler_factory(
          io_task_manager      = me
          is_process_by_form   = is_task_manager_configuration-global_configuration-process_by_form
          is_process_by_method = is_task_manager_configuration-global_configuration-process_by_method
      ).

    CATCH cx_root INTO lo_cx_exception.                  &quot;#EC CATCH_ALL
      &quot; Une erreur est survenue
      RAISE EXCEPTION TYPE zcx_task_manager
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

  &quot; -----------------------------------------------------------
  &quot; Initialisation autres attributs
  &quot; -----------------------------------------------------------

  &quot; Initialisation Paramètre de Trace
  me-&gt;ms_task_manager_data-task_process_configuration-task_trace_param = is_task_manager_configuration-global_configuration-task_trace_param.

  IF iv_overload_compress_conf EQ abap_true.
    &quot; Surcharge des paramètres de compression par défaut
    &quot;&quot;  --&gt; Utilisation de la Configuration transmise
    me-&gt;ms_task_manager_data-task_process_configuration-task_compress_activ = is_task_manager_configuration-global_configuration-task_compress_activ.
    me-&gt;ms_task_manager_data-task_process_configuration-task_compress_param = is_task_manager_configuration-global_configuration-task_compress_param.

  ELSE.
    &quot; Paramètrage de la compression transmises
    &quot;&quot;  --&gt; Utilisation la Configuration par défaut
    me-&gt;ms_task_manager_data-task_process_configuration-task_compress_activ = abap_true.
    me-&gt;ms_task_manager_data-task_process_configuration-task_compress_param-data_compress_line_by_line = abap_true.

  ENDIF.

  IF me-&gt;ms_task_manager_data-task_process_configuration-task_trace_param-trace_active EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Création instance pour tracer exécution Tâche
    &quot; -----------------------------------------------------------

    &quot; Création instance Trace
    CREATE OBJECT me-&gt;ms_task_manager_data-o_task_trace.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Traitement de fin
  &quot; -----------------------------------------------------------

  IF me-&gt;ms_task_manager_data-t_task_list[] IS INITIAL.
    &quot; Aucune Tâche n&apos;a été créée
    &quot;&quot;  --&gt; Lève une Exception
    RAISE EXCEPTION TYPE zcx_task_manager
      EXPORTING
        textid = VALUE #(
          msgid = zif_task_constant=&gt;mc_message_class_id
          msgno = 103
        ).

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CONTAINER_TASK_CREATE" VERSION="1" LANGU="F" DESCRIPT="Container - Création" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="CONTAINER_TASK_CREATE" SCONAME="RO_TASK_CONTAINER" VERSION="1" LANGU="F" DESCRIPT="Container paramètres d&apos;appel" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK_CONTAINER"/>
   <source>METHOD CONTAINER_TASK_CREATE.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Création nouveau Container d&apos;appel
  &quot; -----------------------------------------------------------

  CREATE OBJECT ro_task_container.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="HANDLER_TASK_BEFORE" VERSION="1" LANGU="F" DESCRIPT="Handler - Début d&apos;une Tâche" EXPOSURE="0" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="1" MTDDECLTYP="0" REFCLSNAME="ZCL_TASK" REFCMPNAME="TASK_BEFORE" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="HANDLER_TASK_BEFORE" SCONAME="IO_TASK" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="1" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="0"/>
   <source>METHOD handler_task_before.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : HANDLER_TASK_BEFORE                               *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Handler sur évènement ZCL_TASK=&gt;TASK_BEFORE       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Retourne les données
  &quot; -----------------------------------------------------------

  &quot; Lève évènement pour exporter les données  // &quot;A déstination ZCL_TASK_HANDLER
  RAISE EVENT manager_before_task
    EXPORTING
      is_task_call_process  = io_task-&gt;ms_task_data-task_process-task_call_process
      io_task_container     = io_task-&gt;ms_task_data-task_process-task_container.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="HANDLER_TASK_END" VERSION="1" LANGU="F" DESCRIPT="Handler - Fin d&apos;une Tâche" EXPOSURE="0" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="1" MTDDECLTYP="0" REFCLSNAME="ZCL_TASK" REFCMPNAME="TASK_END" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="HANDLER_TASK_END" SCONAME="IO_TASK" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="1" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="0"/>
   <source>METHOD handler_task_end.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : HANDLER_TASK_END                                  *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Handler sur évènement ZCL_TASK=&gt;TASK_END          *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Retourne les données
  &quot; -----------------------------------------------------------

  &quot; Lève évènement pour exporter les données
  RAISE EVENT manager_end_of_task
    EXPORTING
      iv_error              = abap_false
      is_task_call_process  = io_task-&gt;ms_task_data-task_process-task_call_process
      it_result             = io_task-&gt;ms_task_data-task_process-task_container-&gt;mt_function_parameters_output
      it_attached_data      = io_task-&gt;ms_task_data-task_process-task_container-&gt;mt_attached_data.

  &quot; -----------------------------------------------------------
  &quot; Traitement fin d&apos;une Tâche
  &quot; -----------------------------------------------------------

  &quot; Traitement fin d&apos;une Tâche
  me-&gt;at_end_of_task( io_task ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="HANDLER_TASK_ERROR_RESULT" VERSION="1" LANGU="F" DESCRIPT="Handler - Erreur Tâche" EXPOSURE="0" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="1" MTDDECLTYP="0" REFCLSNAME="ZCL_TASK" REFCMPNAME="TASK_ERROR_RECEIVE_RESULT" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="HANDLER_TASK_ERROR_RESULT" SCONAME="IO_TASK" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="1" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="0"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="HANDLER_TASK_ERROR_RESULT" SCONAME="IS_TEXTID" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="1" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="0"/>
   <source>METHOD handler_task_error_result.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : HANDLER_TASK_ERROR                                *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Handler sur évènement ZCL_TASK=&gt;TASK_ERROR        *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_result TYPE zif_task_constant=&gt;tt_function_parameters.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_result TYPE zif_task_constant=&gt;ts_function_parameters.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Retourne les données
  &quot; -----------------------------------------------------------

  &quot; Ajout de l&apos;erreur dans la table des résultats
  ls_result-parameter_name = zif_task_constant=&gt;mc_parameter_name_error.
  ls_result-parameter_data = REF #( is_textid ).
  INSERT ls_result INTO TABLE lt_result.

  &quot; Lève évènement pour exporter les données
  RAISE EVENT manager_end_of_task             &quot;A destination de ZCL_TASK_HANDLER
    EXPORTING
      iv_error             = abap_true
      is_task_call_process = io_task-&gt;ms_task_data-task_process-task_call_process
      it_result            = lt_result
      it_attached_data     = io_task-&gt;ms_task_data-task_process-task_container-&gt;mt_attached_data.

  &quot; -----------------------------------------------------------
  &quot; Traitement fin d&apos;une Tâche
  &quot; -----------------------------------------------------------

  &quot; Traitement fin d&apos;une Tâche
  me-&gt;at_end_of_task( io_task ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_FINISH_RUNNING" VERSION="1" LANGU="F" DESCRIPT="Tâche - Fin de toutes les Tâches" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD task_finish_running.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_FINISH_RUNNING                               *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Permet de clôre toutes les Tâches                 *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_task TYPE REF TO zcl_task.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Attente de la fin de toutes les Tâches en cours
  &quot; -----------------------------------------------------------

  DO.
    &quot; Recherche si au moins une Tâche occupée
    LOOP AT me-&gt;ms_task_manager_data-t_task_list TRANSPORTING NO FIELDS
                                                        WHERE task_running-&gt;* = abap_true         &quot;Tâche en cours de traitement
                                                           OR task_running-&gt;* = abap_undefined.   &quot;Tâche en cours de préparation
      &quot;&quot;  --&gt; Au moins une Tâche occupé
      EXIT.
    ENDLOOP.
    IF sy-subrc NE 0.
      &quot; Aucune Tâche en cours de traitement
      &quot;&quot;  --&gt; Arrêt du traitement
      EXIT.

    ENDIF.

    &quot; Attente de fin de traitement d&apos;une Tâche
    WAIT FOR ASYNCHRONOUS TASKS UNTIL lo_task IS BOUND.   &quot;La condition est volontairement fausse afin de traiter tous les appels asynchrone
    IF sy-subrc EQ 0.   &quot;#EC NEEDED
      &quot; Condition vraie

    ENDIF.

  ENDDO.

  &quot; -----------------------------------------------------------
  &quot; Libération de la SHM
  &quot; -----------------------------------------------------------

  IF NOT me-&gt;ms_task_manager_data-t_definition_type_in_shm[] IS INITIAL. &quot;Alimenté uniquement si Gestion de la SHM activée
    &quot; Récupération Liste des Types stockées dans la SHM par la Tâche
    LOOP AT ms_task_manager_data-t_definition_type_in_shm ASSIGNING FIELD-SYMBOL(&lt;lfs_s_definition_type&gt;).

      TRY.
          &quot; Désenregistrement de la Tâche
          zcl_task_shm=&gt;get_instance( &lt;lfs_s_definition_type&gt; )-&gt;task_manager_deregister( me-&gt;ms_task_manager_data-task_manager_id ).

        CATCH zcx_task_shm.
          &quot; Erreur lors de la libération de la SHM
          &quot;&quot;  --&gt; Tant pis...
          CONTINUE.

      ENDTRY.

    ENDLOOP.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_GET_FREE" VERSION="1" LANGU="F" DESCRIPT="Récupération Tâche disponible" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_GET_FREE" SCONAME="RO_TASK" VERSION="1" LANGU="F" DESCRIPT="Instance Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK"/>
   <source>METHOD task_get_free.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_GET_FREE                                     *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Récupération d&apos;une Tâche disponible               *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération d&apos;une Tâche finie
  &quot; -----------------------------------------------------------

  TRY.
      &quot; Récupération instance de la Tâche
      ro_task = me-&gt;ms_task_manager_data-t_task_list[ task_running-&gt;* = abap_false ]-task_instance.

    CATCH cx_sy_itab_line_not_found.
      &quot; Aucune Tâche finie
      FREE : ro_task.

    CATCH cx_root.                                      &quot;&quot;#EC CATCH_ALL #EC NO_HANDLER
      &quot; Autre erreur

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_START_NEW" VERSION="1" LANGU="F" DESCRIPT="Tâche - Lancement" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_START_NEW" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement à lancer" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_CALL_PROCESS" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_START_NEW" SCONAME="IS_TASK_CONFIGURATION" VERSION="1" LANGU="F" DESCRIPT="Configuration de lancement de la Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZCL_TASK_MANAGER=&gt;TS_TASK_PROCESS_CONFIGURATION" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_START_NEW" SCONAME="IO_TASK_CONTAINER" VERSION="1" LANGU="F" DESCRIPT="Container - Paramètre d&apos;appel" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_TASK_CONTAINER" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_START_NEW" SCONAME="IV_OVERLOAD_COMPRESS_CONF" VERSION="1" LANGU="F" DESCRIPT="Ne pas utiliser la configuration de compression par défaut" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <exception CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TASK_START_NEW" SCONAME="ZCX_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD task_start_new.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_START_NEW                                    *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Début d&apos;une nouvelle Tâche                        *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_textid              TYPE scx_t100key,
    ls_task_trace_param    TYPE ztec_s_task_trace_param,
    ls_task_call_process   TYPE ztec_s_task_call_process,
    ls_task_compress_param TYPE ztec_s_task_compress_param.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_task           TYPE REF TO zcl_task,
    lo_cx_task        TYPE REF TO zcx_task,
    lo_task_container TYPE REF TO zcl_task_container.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle
  &quot; -----------------------------------------------------------

  IF  me-&gt;ms_task_manager_data-dedicated_mode EQ abap_false AND
      is_task_call_process-repid_name    IS INITIAL AND
      is_task_call_process-function_name IS INITIAL AND
      is_task_call_process-class_name    IS INITIAL AND is_task_call_process-method_name IS INITIAL.
    &quot; Erreur
    &quot;&quot;  --&gt; Lève une Exception
    ls_textid-msgid = zif_task_constant=&gt;mc_message_class_id.
    ls_textid-msgno = 003.
    RAISE EXCEPTION TYPE zcx_task_manager
      EXPORTING
        textid = ls_textid.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Initialisation variable locale
  &quot; -----------------------------------------------------------

  IF io_task_container IS BOUND.
    &quot; Utilisation Container Tâche
    &quot;&quot;  --&gt; Initialiation instance local
    lo_task_container = io_task_container.

  ELSE.
    &quot;&quot;  --&gt; Création Container vide
    CREATE OBJECT lo_task_container.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Récupération d&apos;une Tâche disponible
  &quot; -----------------------------------------------------------

  &quot; Récupération d&apos;une Tâche libre
  lo_task = me-&gt;task_get_free( ).
  IF NOT lo_task IS BOUND.
    &quot; Aucune Tâche disponible
    &quot;&quot;  --&gt; Attente fin de traitement d&apos;une Tâche
    WHILE NOT lo_task IS BOUND.   &quot;Tant qu&apos;aucune Tâche n&apos;est disponible
      &quot; Attente de fin de traitement d&apos;une Tâche
      WAIT FOR ASYNCHRONOUS TASKS UNTIL lo_task IS BOUND.
      IF sy-subrc NE 0.
        &quot; ID non renseigné
        &quot;&quot;  --&gt; Récupération instance Tâche Libre
        lo_task = me-&gt;task_get_free( ).

      ELSE.
        &quot; ID renseigné
        &quot;&quot;  --&gt; Passe à l&apos;étape suivante
        EXIT.

      ENDIF.

    ENDWHILE.                   &quot;Fin d&apos;attente disponibilité d&apos;une Tâche

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Détermination du Traitement à lancer
  &quot; -----------------------------------------------------------

  IF lo_task-&gt;ms_task_data-task_dedicated EQ abap_true.
    &quot; Tâche dédiée
    &quot;&quot;  --&gt; Initialisation Nom du Traitement
    ls_task_call_process = lo_task-&gt;ms_task_data-task_process-task_call_process.

  ELSE.
    &quot; Tâche non dédiée
    IF NOT is_task_call_process-function_name IS INITIAL.
      &quot;&quot;  --&gt; Utilisation Nom du MF transmis
      ls_task_call_process-function_name = is_task_call_process-function_name.

    ELSEIF NOT is_task_call_process-class_name  IS INITIAL
       AND NOT is_task_call_process-method_name IS INITIAL.
      &quot;&quot;  --&gt; Utilisation Nom Méthode transmis
      ls_task_call_process-class_name  = is_task_call_process-class_name.
      ls_task_call_process-method_name = is_task_call_process-method_name.

    ELSEIF not is_task_call_process-repid_name IS INITIAL.
      &quot;&quot;  --&gt; Utilisation Nom Programme transmis
      ls_task_call_process-repid_name = is_task_call_process-repid_name.

     ELSE.
      &quot; Aucun Traitement d&apos;appel
      &quot;&quot;  --&gt; Lève une Exception
      ls_textid-msgid = zif_task_constant=&gt;mc_message_class_id.
      ls_textid-msgno = 003.
      RAISE EXCEPTION TYPE zcx_task_manager
        EXPORTING
          textid = ls_textid.

    ENDIF.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Détermination des paramètres
  &quot; -----------------------------------------------------------

  IF is_task_configuration-task_trace_param-trace_active                               EQ abap_true
  OR zcl_task_trace=&gt;task_trace_is_active( ls_task_call_process )                      EQ abap_true
  OR me-&gt;ms_task_manager_data-task_process_configuration-task_trace_param-trace_active EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Activation Trace de la Tâche
    &quot; -----------------------------------------------------------

    &quot; Initialisation Paramètre de Trace
    IF zcl_task_trace=&gt;task_trace_is_active( ls_task_call_process ) EQ abap_true.
      &quot; Utilisation paramètre &quot;customisé&quot;
      ls_task_trace_param = zcl_task_trace=&gt;task_trace_get_param( ls_task_call_process ).

    ELSEIF is_task_configuration-task_trace_param-trace_active EQ abap_true.
      &quot; Utilisation paramètre d&apos;import
      ls_task_trace_param = is_task_configuration-task_trace_param.

    ELSEIF me-&gt;ms_task_manager_data-task_process_configuration-task_trace_param-trace_active EQ abap_true.
      &quot; Utilisation paramètre local
      ls_task_trace_param = me-&gt;ms_task_manager_data-task_process_configuration-task_trace_param.

    ENDIF.

    &quot; Enregistrement de la Trace d&apos;exécution
    me-&gt;trace_task_start(
        is_task_call_process = ls_task_call_process
        io_task              = lo_task
        is_trace_param       = ls_task_trace_param
    ).

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Détermination Mode de Compression
  &quot; -----------------------------------------------------------

  IF me-&gt;compress_param_exist( ls_task_call_process ) EQ abap_true AND
     iv_overload_compress_conf                        EQ abap_false.
    &quot; Surchage des paramètres de compression pour cet appel
    &quot;&quot;  --&gt; Récupération de la configuration de compression
    ls_task_compress_param = me-&gt;compress_param_get( ls_task_call_process ).

  ELSE.
    IF iv_overload_compress_conf EQ abap_true.
      &quot; Surchage des paramètres de compression pour cet appel
      &quot;&quot;  --&gt; Utilisation paramètre transmis
      ls_task_compress_param = is_task_configuration-task_compress_param.

    ELSE.
      &quot; Utilisation des paramètres du Manager de Tâche
      &quot;&quot;  --&gt; Utilisation de la configuration du Manager
      ls_task_compress_param = me-&gt;ms_task_manager_data-task_process_configuration-task_compress_param.

    ENDIF.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Lancement de la Tâche
  &quot; -----------------------------------------------------------

  TRY.
      &quot; Lancement de la Tâche avec les paramètres fournis
      lo_task-&gt;task_start(
        is_task_call_process   = ls_task_call_process
        io_task_container      = lo_task_container
        is_task_compress_param = ls_task_compress_param
      ).

    CATCH zcx_task INTO lo_cx_task.
      &quot; Erreur lors de l&apos;appel
      &quot;&quot;  --&gt; Lève une Exception
      RAISE EXCEPTION TYPE zcx_task_manager
        EXPORTING
          previous = lo_cx_task.

  ENDTRY.

  &quot; -----------------------------------------------------------
  &quot; Réinitialisation Containeer
  &quot; -----------------------------------------------------------

  IF io_task_container IS BOUND.
    &quot; Réinitialisation Container d&apos;entrée
    io_task_container-&gt;reset( ).

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TRACE_TASK_START" VERSION="1" LANGU="F" DESCRIPT="Trace - Début de la Trace d&apos;exécution" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TRACE_TASK_START" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement à lancer" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_CALL_PROCESS"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TRACE_TASK_START" SCONAME="IO_TASK" VERSION="1" LANGU="F" DESCRIPT="Instance Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_TASK"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TRACE_TASK_START" SCONAME="IS_TRACE_PARAM" VERSION="1" LANGU="F" DESCRIPT="Tâche - Paramètre de Trace" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTEC_S_TASK_TRACE_PARAM"/>
   <source>METHOD TRACE_TASK_START.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TRACE_TASK_START                                  *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Début Trace d&apos;exécution de la Tâche               *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Début enregistrement de l&apos;exécution d&apos;une Tâche
  &quot; -----------------------------------------------------------

  IF NOT me-&gt;ms_task_manager_data-o_task_trace IS BOUND.
    &quot; Création Instance Trace
    CREATE OBJECT me-&gt;ms_task_manager_data-o_task_trace
      EXPORTING
        iv_trace_memory = is_trace_param-trace_memory.

  ENDIF.

  &quot; Enregistrement début Trace
  io_task-&gt;ms_task_data-task_trace_id = me-&gt;ms_task_manager_data-o_task_trace-&gt;task_trace_start(
      iv_task_manager_id   = me-&gt;ms_task_manager_data-task_manager_id
      iv_task_id           = io_task-&gt;ms_task_data-task_id
      is_task_call_process = is_task_call_process
      iv_trace_memory      = is_trace_param-trace_memory
  ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TRACE_TASK_STOP" VERSION="1" LANGU="F" DESCRIPT="Trace - Fin de la Trace d&apos;exécution" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TRACE_TASK_STOP" SCONAME="IV_TASK_TRACE_ID" VERSION="1" LANGU="F" DESCRIPT="Tâche - ID Trace" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTASK_TRACE_ID"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="TRACE_TASK_STOP" SCONAME="IV_LOG_IMMEDIATE" VERSION="1" LANGU="F" DESCRIPT="Trace - Enregistrement immédiat" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <source>METHOD TRACE_TASK_STOP.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TRACE_TASK_STOP                                   *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Fin Trace d&apos;exécution de la Tâche                 *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Fin enregistrement Trace d&apos;exécution de la Tâche
  &quot; -----------------------------------------------------------

  &quot; Fin de la Trace
  me-&gt;ms_task_manager_data-o_task_trace-&gt;task_trace_stop(
    iv_task_trace_id = iv_task_trace_id
    iv_log_immediate = iv_log_immediate
  ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_CALL_PROCESS_FUNCTION_CHECK" VERSION="1" LANGU="F" DESCRIPT="Traitement MF - Contrôle cohérence" EXPOSURE="0" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_CALL_PROCESS_FUNCTION_CHECK" SCONAME="IV_FUNCTION_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom du module fonction" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="RS38L_FNAM"/>
   <exception CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_CALL_PROCESS_FUNCTION_CHECK" SCONAME="ZCX_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Manager Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD _call_process_function_check.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : _CALL_PROCESS_FUNCTION_CHECK                      *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Traitement MF - Contrôle cohérence                *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_tfdir  TYPE zcl_task_manager=&gt;ts_tfdir,
    ls_textid TYPE scx_t100key.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle Module Fonction
  &quot; -----------------------------------------------------------

  &quot; Récupération entrée sur MF
  READ TABLE zcl_task_manager=&gt;ms_persistent_data-t_tfdir WITH TABLE KEY funcname = iv_function_name
                                                               ASSIGNING FIELD-SYMBOL(&lt;lfs_s_tfdir&gt;).
  IF sy-subrc NE 0.
    &quot;&quot;  --&gt; Recherche l&apos;existence du MF
    SELECT SINGLE funcname FROM tfdir
                           INTO ls_tfdir-funcname
                          WHERE funcname EQ iv_function_name.
    IF sy-subrc NE 0.
      &quot; Le MF n&apos;existe pas
      &quot;&quot;  --&gt; Initialisation structure
      ls_tfdir-funcname  = iv_function_name.
      ls_tfdir-not_found = abap_true.

    ENDIF.

    &quot; Ajout de l&apos;entrée
    INSERT ls_tfdir INTO TABLE zcl_task_manager=&gt;ms_persistent_data-t_tfdir ASSIGNING &lt;lfs_s_tfdir&gt;.

  ENDIF.

  IF &lt;lfs_s_tfdir&gt; IS ASSIGNED AND &lt;lfs_s_tfdir&gt;-not_found EQ abap_true.
    &quot; Le MF n&apos;existe pas
    &quot;&quot;  --&gt; Lève une exception
    ls_textid-msgid = zif_task_constant=&gt;mc_message_class_id.
    ls_textid-msgno = 104.
    ls_textid-attr1 = iv_function_name.
    RAISE EXCEPTION TYPE zcx_task_manager
      EXPORTING
        textid = ls_textid.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_CALL_PROCESS_METHOD_CHECK" VERSION="1" LANGU="F" DESCRIPT="Traitement Méthode - Contrôle cohérence" EXPOSURE="0" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_CALL_PROCESS_METHOD_CHECK" SCONAME="IV_CLASS_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom de type d&apos;objet" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCLSNAME"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_CALL_PROCESS_METHOD_CHECK" SCONAME="IV_METHOD_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom d&apos;une méthode" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOMTDNAME"/>
   <exception CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_CALL_PROCESS_METHOD_CHECK" SCONAME="ZCX_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Manager Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD _call_process_method_check.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : _CALL_PROCESS_METHOD_CHECK                        *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Traitement Méthode - Contrôle cohérence           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***


***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_textid     TYPE scx_t100key,
    ls_seosubcodf TYPE zcl_task_manager=&gt;ts_seosubcodf,
    ls_seocompodf TYPE zcl_task_manager=&gt;ts_seocompodf.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle existence Classe / Méthode
  &quot; -----------------------------------------------------------

  &quot; Récupération entrée de la Méthode en Buffer
  READ TABLE zcl_task_manager=&gt;ms_persistent_data-t_seocompodf
  WITH TABLE KEY clsname = iv_class_name
                 cmpname = iv_method_name
       ASSIGNING FIELD-SYMBOL(&lt;lfs_s_seocompodf&gt;).
  IF sy-subrc NE 0.
    &quot;&quot;  --&gt; Recherche existence Méthode en DB
    SELECT SINGLE clsname, cmpname
             FROM seocompodf
            WHERE clsname    EQ @iv_class_name
              AND cmpname    EQ @iv_method_name
              AND version    EQ &apos;1&apos; &quot;Actif &quot;#EC NOTEXT
              AND exposure   EQ &apos;2&apos; &quot;Publique &quot;#EC NOTEXT
              AND mtddecltyp EQ &apos;1&apos; &quot;Statique &quot;#EC NOTEXT
             INTO @ls_seocompodf.
    IF sy-subrc NE 0.
      &quot; Méthode non éligible
      &quot;&quot;  --&gt; Ajout dans la table Buffer
      ls_seocompodf-clsname   = iv_class_name.
      ls_seocompodf-cmpname   = iv_method_name.
      ls_seocompodf-not_found = abap_true.

    ENDIF.

    &quot;&quot;  --&gt; Ajout de l&apos;entrée
    INSERT ls_seocompodf INTO TABLE zcl_task_manager=&gt;ms_persistent_data-t_seocompodf ASSIGNING &lt;lfs_s_seocompodf&gt;.

  ENDIF.

  IF NOT &lt;lfs_s_seocompodf&gt; IS ASSIGNED OR
         &lt;lfs_s_seocompodf&gt;-not_found EQ abap_true.
    &quot; Non trouvée
    &quot;&quot;  --&gt; Lève une exception
    ls_textid-msgid = &apos;ZTASK&apos;.                              &quot;#EC NOTEXT
    ls_textid-msgno = 601.
    ls_textid-attr1 = iv_class_name.
    ls_textid-attr2 = iv_method_name.
    RAISE EXCEPTION TYPE zcx_task_manager
      EXPORTING
        textid = ls_textid.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Contrôle les paramètres de la Méthode
  &quot; -----------------------------------------------------------

  &quot; Récupération données en Buffer
  READ TABLE zcl_task_manager=&gt;ms_persistent_data-t_seosubcodf
  WITH TABLE KEY clsname = iv_class_name
                 cmpname = iv_method_name
       ASSIGNING FIELD-SYMBOL(&lt;lfs_s_seosubcodf&gt;).
  IF sy-subrc NE 0.
    &quot; Aucune correspondance en Buffer
    &quot;&quot;  --&gt; Récupération données en DB
    SELECT SINGLE clsname, cmpname, COUNT( * )
             FROM seosubcodf
            WHERE clsname EQ @iv_class_name
              AND cmpname EQ @iv_method_name
              AND typtype EQ &apos;3&apos;  &quot;Type REF To &quot;#EC NOTEXT
         GROUP BY clsname, cmpname
             INTO @ls_seosubcodf.
    IF sy-subrc NE 0.
      &quot; Aucune correspondance en DB // Aucun paramètre ?
      &quot;&quot;  --&gt; Force l&apos;Ajout
      ls_seosubcodf-clsname = iv_class_name.
      ls_seosubcodf-cmpname = iv_method_name.

    ENDIF.

    &quot;&quot;  --&gt; Ajout de l&apos;entrée
    INSERT ls_seosubcodf INTO TABLE zcl_task_manager=&gt;ms_persistent_data-t_seosubcodf ASSIGNING &lt;lfs_s_seosubcodf&gt;.

  ENDIF.

  IF &lt;lfs_s_seosubcodf&gt; IS ASSIGNED AND &lt;lfs_s_seosubcodf&gt;-count GT 0.
    &quot; Au moins un paramètre Référence
    &quot;&quot;  --&gt; Lève une exception
    ls_textid-msgid = &apos;UBD_REMOTE&apos;.                         &quot;#EC NOTEXT
    ls_textid-msgno = 003.
    RAISE EXCEPTION TYPE zcx_task_manager
      EXPORTING
        textid = ls_textid.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_CALL_PROCESS_REPID_CHECK" VERSION="1" LANGU="F" DESCRIPT="Traitement Programme - Contrôle cohérence" EXPOSURE="0" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_CALL_PROCESS_REPID_CHECK" SCONAME="IV_REPID_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom du programme ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="REPID"/>
   <exception CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_CALL_PROCESS_REPID_CHECK" SCONAME="ZCX_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Manager Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD _call_process_repid_check.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : _CALL_PROCESS_REPID_CHECK                         *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Traitement Programme - Contrôle cohérence         *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_trdir  TYPE zcl_task_manager=&gt;ts_trdir,
    ls_textid TYPE scx_t100key.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération des données du Programme
  &quot; -----------------------------------------------------------

  &quot; Récupération données en Buffer
  READ TABLE zcl_task_manager=&gt;ms_persistent_data-t_trdir
  WITH TABLE KEY name = iv_repid_name
       ASSIGNING FIELD-SYMBOL(&lt;lfs_s_trdir&gt;).
  IF sy-subrc NE 0.
    &quot; Aucune correpsondance en Bfufer
    &quot;&quot;  --&gt; Récupératino données Programme en DB
    SELECT SINGLE name, subc
      FROM trdir
     WHERE name EQ @iv_repid_name
      INTO @ls_trdir.
    IF sy-subrc NE 0.
      &quot; Aucune correspondance
      &quot;&quot;  --&gt; Force l&apos;Ajout
      ls_trdir-name      = iv_repid_name.
      ls_trdir-not_found = abap_true.

    ENDIF.

    &quot;&quot;  --&gt; Ajout de l&apos;entrée en Buffer
    INSERT ls_trdir INTO TABLE zcl_task_manager=&gt;ms_persistent_data-t_trdir ASSIGNING &lt;lfs_s_trdir&gt;.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Contrôle cohérence du Programme
  &quot; -----------------------------------------------------------

  IF NOT &lt;lfs_s_trdir&gt; IS ASSIGNED OR
     &lt;lfs_s_trdir&gt;-not_found EQ abap_true.
    &quot; Programme inexistant
    &quot;&quot;  --&gt; Initialisation message Exception
    ls_textid-msgid = &apos;00&apos;.                               &quot;#EC NOTEXT
    ls_textid-msgno = 541.
    ls_textid-attr1 = iv_repid_name.

  ELSEIF &lt;lfs_s_trdir&gt;-subc NE &apos;1&apos;.                         &quot;#EC NOTEXT
    &quot; Programme non exécutable
    &quot;&quot;  --&gt; Initialisation message Exception
    ls_textid-msgid = &apos;3G&apos;.                                &quot;#EC NOTEXT
    ls_textid-msgno = 854.
    ls_textid-attr1 = iv_repid_name.

  ELSE.
    &quot; Programme éligible
    CLEAR : ls_textid.

  ENDIF.

  IF NOT ls_textid IS INITIAL.
    &quot; Erreur à généré
    &quot;&quot;  --&gt; Lève l&apos;Exception
    RAISE EXCEPTION TYPE zcx_task_manager
      EXPORTING
        textid = ls_textid.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_CONSTRUCTOR_CHECK" VERSION="1" LANGU="F" DESCRIPT="Contrôle des paramétres" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_CONSTRUCTOR_CHECK" SCONAME="IV_GRFC" VERSION="1" LANGU="F" DESCRIPT="Groupe de serveurs RFC pour traitement paralléle" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="RFCGR"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_CONSTRUCTOR_CHECK" SCONAME="IV_USE_DEFAULT_GROUP" VERSION="1" LANGU="F" DESCRIPT="Utilisation groupe RFC par défaut" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_CONSTRUCTOR_CHECK" SCONAME="IV_DEDICATED_MODE" VERSION="1" LANGU="F" DESCRIPT="Mode dédié ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_CONSTRUCTOR_CHECK" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement à lancer" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_CALL_PROCESS" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_CONSTRUCTOR_CHECK" SCONAME="RV_TASK_MAX" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
   <exception CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_CONSTRUCTOR_CHECK" SCONAME="ZCX_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Manager Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD _constructor_check.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CHECK                                             *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Contrôle paramètère //                            *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_rzllitab TYPE zcl_task_manager=&gt;ts_rzllitab.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  IF iv_use_default_group EQ abap_false.
    &quot; -----------------------------------------------------------
    &quot; Contrôle Groupe de Serveur
    &quot; -----------------------------------------------------------

    &quot; Récupération entrée sur Groupe de Serveur
    READ TABLE zcl_task_manager=&gt;ms_persistent_data-t_rzllitab WITH TABLE KEY classname = iv_grfc
                                                                    ASSIGNING FIELD-SYMBOL(&lt;lfs_s_rzllitab&gt;).
    IF sy-subrc NE 0.
      &quot; Entrée non encore référencé
      &quot;&quot;  --&gt; Recherche le Groupe de Serveur
      SELECT classname FROM rzllitab UP TO 1 ROWS
                       INTO ls_rzllitab-classname
                      WHERE classname EQ iv_grfc.
      ENDSELECT.
      IF sy-subrc NE 0.
        &quot; Le Groupe de Serveur n&apos;existe pas
        &quot;&quot;  --&gt; Initialisation structure
        ls_rzllitab-classname = iv_grfc.
        ls_rzllitab-not_found = abap_true.

      ENDIF.

      &quot; Ajout de l&apos;entrée
      INSERT ls_rzllitab INTO TABLE zcl_task_manager=&gt;ms_persistent_data-t_rzllitab ASSIGNING &lt;lfs_s_rzllitab&gt;.

    ENDIF.

    IF &lt;lfs_s_rzllitab&gt; IS ASSIGNED AND &lt;lfs_s_rzllitab&gt;-not_found EQ abap_true.
      &quot; Le Groupe de Serveur n&apos;existe pas
      &quot;&quot;  --&gt; Lève une Exception
      RAISE EXCEPTION TYPE zcx_task_manager
        EXPORTING
          textid = VALUE #(
            msgid = zif_task_constant=&gt;mc_message_class_id
            msgno = 105
            attr1 = iv_grfc
          ).

    ENDIF.

    &quot; Contrôle Initialisation Groupe de Serveur
    CALL FUNCTION &apos;SPBT_INITIALIZE&apos;
      EXPORTING
        group_name                     = iv_grfc
      EXCEPTIONS
        invalid_group_name             = 3
        internal_error                 = 2
        pbt_env_already_initialized    = 1
        currently_no_resources_avail   = 1
        no_pbt_resources_found         = 4
        cant_init_different_pbt_groups = 6
        OTHERS                         = 7.
    IF sy-subrc GT 1.
      &quot; Erreur création Groupe de //
      &quot;&quot;  --&gt; Lève une Exception
      RAISE EXCEPTION TYPE zcx_task_manager
        EXPORTING
          textid = VALUE #(
            msgid = sy-msgid msgno = sy-msgno
            attr1 = sy-msgv1 attr2 = sy-msgv2
            attr3 = sy-msgv3 attr4 = sy-msgv4
          ).

    ENDIF.

  ENDIF.

  &quot;&quot;  --&gt; Récupère le nombre de Process. disponible sur le Serveur
  rv_task_max = zcl_task_manager=&gt;available_process_get( ).

  IF  iv_dedicated_mode    EQ abap_true
  AND is_task_call_process IS INITIAL.
    &quot; Mode dédié activé mais aucun traitement à exécuter
    RAISE EXCEPTION TYPE zcx_task_manager
      EXPORTING
        textid = VALUE #(
          msgid = zif_task_constant=&gt;mc_message_class_id
          msgno = 107
        ).

  ELSE.
    TRY.
        &quot; -----------------------------------------------------------
        &quot; Contrôle traitement mode dédié
        &quot; -----------------------------------------------------------
        me-&gt;_dedicated_mode_check( is_task_call_process ).

      CATCH zcx_task_manager INTO DATA(lo_cx_exception).
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Lève l&apos;exception
        RAISE EXCEPTION TYPE zcx_task_manager
          EXPORTING
            previous = lo_cx_exception.

    ENDTRY.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_DEDICATED_MODE_CHECK" VERSION="1" LANGU="F" DESCRIPT="Mode dédié - Contrôle" EXPOSURE="0" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_DEDICATED_MODE_CHECK" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement à lancer" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_CALL_PROCESS"/>
   <exception CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_DEDICATED_MODE_CHECK" SCONAME="ZCX_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Manager Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD _dedicated_mode_check.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : _TASK_CALL_PROCESS_CHECK                          *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Traitement - Contrôle cohérence                   *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_cx_exception TYPE REF TO zcx_task_manager.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Contrôle Traitement à appeler
      &quot; -----------------------------------------------------------
      me-&gt;_task_call_process_check( is_task_call_process ).

    CATCH zcx_task_manager INTO lo_cx_exception.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Lève l&apos;exception
      RAISE EXCEPTION TYPE zcx_task_manager
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_TASK_CALL_PROCESS_CHECK" VERSION="1" LANGU="F" DESCRIPT="Traitement - Contrôle cohérence" EXPOSURE="0" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_TASK_CALL_PROCESS_CHECK" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement à lancer" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_CALL_PROCESS"/>
   <exception CLSNAME="ZCL_TASK_MANAGER" CMPNAME="_TASK_CALL_PROCESS_CHECK" SCONAME="ZCX_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Manager Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD _task_call_process_check.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : _TASK_CALL_PROCESS_CHECK                          *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Traitement - Contrôle cohérence                   *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_cx_exception TYPE REF TO zcx_task_manager.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.

      IF NOT is_task_call_process-function_name IS INITIAL.
        &quot; Traitement sur MF
        me-&gt;_call_process_function_check( is_task_call_process-function_name ).

      ELSEIF NOT is_task_call_process-class_name    IS INITIAL
         AND NOT is_task_call_process-function_name IS INITIAL.
        &quot; Traitement sur Méthode
        me-&gt;_call_process_method_check(
          iv_class_name  = is_task_call_process-class_name
          iv_method_name = is_task_call_process-method_name
        ).

      ELSEIF NOT is_task_call_process-repid_name Is INITIAL.
        &quot; Traitement sur Programme
        me-&gt;_call_process_repid_check( is_task_call_process-repid_name ).

      ELSE.
        &quot; Aucun paramètre
        &quot;&quot;  --&gt; Arrêt du traitement
        RETURN.

      ENDIF.

    CATCH zcx_task_manager INTO lo_cx_exception.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Lève l&apos;exception
      RAISE EXCEPTION TYPE zcx_task_manager
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_HANDLER" VERSION="1" LANGU="F" DESCRIPT="Tâche - Handler évènement" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZTASK" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_TASK_HANDLER" CMPNAME="TS_PROCESS" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="7 " SRCCOLUMN2="22 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_process,
      form TYPE ZTEC_S_TASK_PROCESS_BY_FORM,
      method TYPE ZTEC_S_TASK_PROCESS_BY_METHOD,
    END OF   ts_process
"/>
  <types CLSNAME="ZCL_TASK_HANDLER" CMPNAME="TT_PROCESS_RUNTIME" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="4 " SRCROW2="12 " SRCCOLUMN2="32 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF tt_process_runtime,
        after TYPE ZCL_TASK_HANDLER=&gt;ts_process,
        before TYPE ZCL_TASK_HANDLER=&gt;ts_process,
      END OF   tt_process_runtime
"/>
  <friends CLSNAME="ZCL_TASK_HANDLER" REFCLSNAME="ZCL_TASK_MANAGER" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_TASK_HANDLER" CMPNAME="MS_PROCESS_RUNTIME" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_TASK_HANDLER=&gt;TT_PROCESS_RUNTIME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TASK_HANDLER" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CONSTRUCTOR" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="CONSTRUCTOR" SCONAME="IO_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Gestion Processus //" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_TASK_MANAGER"/>
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="CONSTRUCTOR" SCONAME="IS_PROCESS_BY_FORM" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement par Routine" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZCL_TASK_MANAGER=&gt;TS_PROCESS_BY_FORM" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="CONSTRUCTOR" SCONAME="IS_PROCESS_BY_METHOD" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement par Méthode" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZCL_TASK_MANAGER=&gt;TS_PROCESS_BY_METHOD" PAROPTIONL="X"/>
   <source>METHOD constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_TASK_HANDLER                                  *
*&amp; Description     : Constructeur classe Handler TASK_MANAGER          *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Souscription à l&apos;évènement de Fin d&apos;une Tâche sur le Manager
  &quot; -----------------------------------------------------------

  &quot; Souscription à l&apos;événement Fin d&apos;une Tâche
  SET HANDLER me-&gt;handler_manager_end_of_task FOR io_task_manager.

  &quot; Souscription à l&apos;événement Début d&apos;une Tâche
  SET HANDLER me-&gt;handler_manager_before_task FOR io_task_manager.

  &quot; -----------------------------------------------------------
  &quot; Initialisation des attributs
  &quot; -----------------------------------------------------------

  &quot; Traitement fin d&apos;exécution
  IF NOT is_process_by_form-after IS INITIAL.
    &quot; Traitement par Routine
    me-&gt;ms_process_runtime-after-form = is_process_by_form-after.

  ELSEIF NOT is_process_by_method-after IS INITIAL.
    &quot; Traitement par Méthode
    me-&gt;ms_process_runtime-after-method = is_process_by_method-after.

  ELSE.  ##NEEDED
    &quot; Aucun attribut
    &quot;&quot;  --&gt; Pas de traitement ?

  ENDIF.

  &quot; Traitement début d&apos;exécution
  IF NOT is_process_by_form-before IS INITIAL.
    &quot; Traitement par Routine
    me-&gt;ms_process_runtime-before-form = is_process_by_form-before.

  ELSEIF NOT is_process_by_method-before IS INITIAL.
    &quot; Traitement par Méthode
    me-&gt;ms_process_runtime-before-method = is_process_by_method-before.

  ELSE.  ##NEEDED
    &quot; Aucun attribut
    &quot;&quot;  --&gt; Pas de traitement ?

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_FACTORY" VERSION="1" LANGU="F" DESCRIPT="Création Handler" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_FACTORY" SCONAME="IO_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Gestion Processus //" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_TASK_MANAGER"/>
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_FACTORY" SCONAME="IS_PROCESS_BY_FORM" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement par Routine" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZCL_TASK_MANAGER=&gt;TS_PROCESS_BY_FORM" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_FACTORY" SCONAME="IS_PROCESS_BY_METHOD" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement par Méthode" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZCL_TASK_MANAGER=&gt;TS_PROCESS_BY_METHOD" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_FACTORY" SCONAME="RO_HANDLER" VERSION="1" LANGU="F" DESCRIPT="Handler Fin d&apos;une Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK_HANDLER"/>
   <source>METHOD handler_factory.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Création de l&apos;instance Handler
  &quot; -----------------------------------------------------------

  &quot; Création de l&apos;instance
  CREATE OBJECT ro_handler
    EXPORTING
      io_task_manager      = io_task_manager
      is_process_by_form   = is_process_by_form
      is_process_by_method = is_process_by_method.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_MANAGER_BEFORE_TASK" VERSION="1" LANGU="F" DESCRIPT="Handler Evénement début d&apos;une Tâche (TASK_MANAGER)" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="1" MTDDECLTYP="0" REFCLSNAME="ZCL_TASK_MANAGER" REFCMPNAME="MANAGER_BEFORE_TASK" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_MANAGER_BEFORE_TASK" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="1" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="0"/>
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_MANAGER_BEFORE_TASK" SCONAME="IO_TASK_CONTAINER" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="1" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="0"/>
   <source>METHOD handler_manager_before_task.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : HANDLER_MANAGER_BEFORE_TASK                       *
*&amp; Classe          : ZCL_TASK_HANDLER                                  *
*&amp; Description     : Handler sur event                                 *
*                    ZCL_TASK_MANAGER=&gt;MANAGER_BEFORE_TASK             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception TYPE REF TO cx_root.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      IF NOT me-&gt;ms_process_runtime-before-form IS INITIAL.
        &quot; -----------------------------------------------------------
        &quot; Traitement par Routine
        &quot; -----------------------------------------------------------

        &quot; Appel de la routine
        PERFORM (me-&gt;ms_process_runtime-before-form-form)
             IN PROGRAM (me-&gt;ms_process_runtime-before-form-repid)
                  USING is_task_call_process
                        io_task_container
                     IF FOUND.

      ELSEIF NOT me-&gt;ms_process_runtime-before-method IS INITIAL.
        &quot; -----------------------------------------------------------
        &quot; Traitement par appel de méthode
        &quot; -----------------------------------------------------------

        &quot; Appel de la méthode
        CALL METHOD me-&gt;ms_process_runtime-before-method-instance-&gt;(me-&gt;ms_process_runtime-before-method-method)
          EXPORTING
            is_task_call_process = is_task_call_process
            io_task_container    = io_task_container.

      ENDIF.

*-- Ensemble des Exceptions relatives aux appels dynamiques
      &quot; Ces cas ne peuvent se produire que dans le cas d&apos;une mauvaise utilisation du développeur
    CATCH cx_sy_program_not_found cx_sy_dyn_call_error INTO lo_cx_exception.
*-- Ensemble des Exceptions relatives aux appels dynamiques
    CATCH cx_root                 INTO lo_cx_exception.   ##CATCH_ALL
      &quot; Tout autre cas d&apos;erreur
      &quot;&quot;  --&gt; Force la provocation d&apos;un DUMP &quot;spécifique&quot;
      WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
      lo_cx_exception-&gt;get_text( ).
      MESSAGE ID sy-msgid TYPE &apos;X&apos; NUMBER sy-msgno
                                     WITH sy-msgv1
                                          sy-msgv2
                                          sy-msgv3
                                          sy-msgv4.

  ENDTRY.

  IF lo_cx_exception IS BOUND.
    &quot; Ce code est exécuté que dans le cas où une Exception d&apos;une mauvaise utilisation
    &quot;&quot;  --&gt; Lève l&apos;Exception qui ne sera pas catché (DUMP)
    WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
    RAISE EXCEPTION lo_cx_exception.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_MANAGER_END_OF_TASK" VERSION="1" LANGU="F" DESCRIPT="Handler Evénement fin d&apos;une Tâche (TASK_MANAGER)" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="1" MTDDECLTYP="0" REFCLSNAME="ZCL_TASK_MANAGER" REFCMPNAME="MANAGER_END_OF_TASK" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_MANAGER_END_OF_TASK" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Nom de fonction" CMPTYPE="1" MTDTYPE="1" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="0"/>
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_MANAGER_END_OF_TASK" SCONAME="IT_RESULT" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="1" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="0"/>
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_MANAGER_END_OF_TASK" SCONAME="IT_ATTACHED_DATA" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="1" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="0"/>
   <parameter CLSNAME="ZCL_TASK_HANDLER" CMPNAME="HANDLER_MANAGER_END_OF_TASK" SCONAME="IV_ERROR" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="1" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="0"/>
   <source>METHOD handler_manager_end_of_task.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : HANDLER_END_OF_TASK                               *
*&amp; Classe          : ZCL_TASK_HANDLER                                  *
*&amp; Description     : Handler sur event                                 *
*                    ZCL_TASK_MANAGER=&gt;MANAGER_END_OF_TASK             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception TYPE REF TO cx_root.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      IF NOT me-&gt;ms_process_runtime-after-form IS INITIAL.
        &quot; -----------------------------------------------------------
        &quot; Traitement par Routine
        &quot; -----------------------------------------------------------

        &quot; Appel de la routine
        PERFORM (me-&gt;ms_process_runtime-after-form-form)
             IN PROGRAM (me-&gt;ms_process_runtime-after-form-repid)
                  USING is_task_call_process
                        it_result
                        it_attached_data
                        iv_error
                     IF FOUND.

      ELSEIF NOT me-&gt;ms_process_runtime-after-method IS INITIAL.
        &quot; -----------------------------------------------------------
        &quot; Traitement par appel de méthode
        &quot; -----------------------------------------------------------

        &quot; Appel de la méthode
        CALL METHOD me-&gt;ms_process_runtime-after-method-instance-&gt;(me-&gt;ms_process_runtime-after-method-method)
          EXPORTING
            iv_error             = iv_error
            is_task_call_process = is_task_call_process
            it_result            = it_result
            it_attached_data     = it_attached_data.

      ENDIF.

*-- Ensemble des Exceptions relatives aux appels dynamiques
      &quot; Ces cas ne peuvent se produire que dans le cas d&apos;une mauvaise utilisation du développeur
    CATCH cx_sy_program_not_found cx_sy_dyn_call_error INTO lo_cx_exception.
*-- Ensemble des Exceptions relatives aux appels dynamiques
    CATCH cx_root                 INTO lo_cx_exception.   ##CATCH_ALL
      &quot; Tout autre cas d&apos;erreur
      &quot;&quot;  --&gt; Force la provocation d&apos;un DUMP &quot;spécifique&quot;
      WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
      lo_cx_exception-&gt;get_text( ).
      MESSAGE ID sy-msgid TYPE &apos;X&apos; NUMBER sy-msgno
                                     WITH sy-msgv1
                                          sy-msgv2
                                          sy-msgv3
                                          sy-msgv4.

  ENDTRY.

  IF lo_cx_exception IS BOUND.
    &quot; Ce code est exécuté que dans le cas où une Exception d&apos;une mauvaise utilisation
    &quot;&quot;  --&gt; Lève l&apos;Exception qui ne sera pas catché (DUMP)
    WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
    RAISE EXCEPTION lo_cx_exception.

  ENDIF.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_TASK_WIZARD" VERSION="1" LANGU="F" DESCRIPT="Tâche - Exception Assistant" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_DYNAMIC_CHECK">
  <implementing CLSNAME="ZCX_TASK_WIZARD" REFCLSNAME="IF_T100_MESSAGE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_TASK_WIZARD" REFCLSNAME="CX_DYNAMIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_WIZARD" VERSION="1" LANGU="F" DESCRIPT="Tâche - Assistant utilisation Cadriciel" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZTASK" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <implementing CLSNAME="ZCL_TASK_WIZARD" REFCLSNAME="IF_WB_PROGRAM" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations
*&amp;---------------------------------------------------------------------*


*----------------------------------------------------------------------*
*       CLASS LCL_CONVERT DEFINIION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_convert DEFINITION FINAL.

*-- Publique
  PUBLIC SECTION.

***------------------------------------------------------------------***
**                              TYPES                                 **
***------------------------------------------------------------------***

*   Déclaration de type

***------------------------------------------------------------------***
**                           MÉTHODES                                 **
***------------------------------------------------------------------***

*	Déclaration de méthodes

    &quot; Formatage pour application Template
    CLASS-METHODS : boolean_convert_to_string
      IMPORTING
                iv_value        TYPE xsdboolean
      RETURNING VALUE(rv_value) TYPE string.

***------------------------------------------------------------------***
**                            ATTRIBUTS                               **
***------------------------------------------------------------------***

*	Déclaration d&apos;attributs


*-- Privée
  PRIVATE SECTION.

***------------------------------------------------------------------***
**                              TYPES                                 **
***------------------------------------------------------------------***

*   Déclaration de type

***------------------------------------------------------------------***
**                           MÉTHODES                                 **
***------------------------------------------------------------------***

*	Déclaration de méthodes

***------------------------------------------------------------------***
**                            ATTRIBUTS                               **
***------------------------------------------------------------------***

*	Déclaration d&apos;attributs


ENDCLASS.             &quot;lcl_CONVERT DEFINITION

*----------------------------------------------------------------------*
*       CLASS LCL_CONVERT IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_convert IMPLEMENTATION.

  METHOD boolean_convert_to_string.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Transforme Booléan en Littéral
    &quot; -----------------------------------------------------------

    &quot; Convertis le Booléen dans sa version littérale
    rv_value = SWITCH string( iv_value
      WHEN abap_true THEN &apos;ABAP_TRUE&apos;                       &quot;#EC NOTEXT
      ELSE &apos;ABAP_FALSE&apos;                                     &quot;#EC NOTEXT
    ).

  ENDMETHOD.


ENDCLASS.


*----------------------------------------------------------------------*
*       CLASS LCL_source_code DEFINIION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_source_code DEFINITION FINAL.

*-- Publique
  PUBLIC SECTION.

***------------------------------------------------------------------***
**                              TYPES                                 **
***------------------------------------------------------------------***

*   Déclaration de type

    TYPES :
      BEGIN OF ts_source_code_check,
        subrc     TYPE sy-subrc,
        message   TYPE string,
        line      TYPE i,
        word      TYPE string,
        t_warning TYPE tab_rslinlmsg,
      END OF   ts_source_code_check.

***------------------------------------------------------------------***
**                           MÉTHODES                                 **
***------------------------------------------------------------------***

*	Déclaration de méthodes

    &quot; Constructeur Statique
    CLASS-METHODS class_constructor.

    &quot; Programme - Création
    CLASS-METHODS repid_create
      IMPORTING
                !is_program_trdir    TYPE trdir
                !iv_program_title    TYPE clike OPTIONAL
                !iv_mainprogram_name TYPE sy-repid OPTIONAL
                !iv_program_corrnum  TYPE e070-trkorr OPTIONAL
                !iv_program_ordernum TYPE e070-trkorr OPTIONAL
                !iv_program_devclass TYPE tdevc-devclass OPTIONAL
      RETURNING VALUE(rs_return)     TYPE bapiret2.

    &quot; Code Source - Récupération
    CLASS-METHODS source_code_get
      IMPORTING
                !iv_repid             TYPE sy-repid
      EXPORTING
                !eo_abap_pgeditor     TYPE REF TO cl_wb_pgeditor
      RETURNING VALUE(rt_source_code) TYPE stringtab.

    &quot; Code Source - Modification
    CLASS-METHODS source_code_set
      IMPORTING
                !iv_repid             TYPE sy-repid
                !it_source_code       TYPE stringtab
      RETURNING VALUE(rt_source_code) TYPE stringtab.

    &quot; Code Source - Contrôle
    CLASS-METHODS source_code_check
      IMPORTING
                !iv_repid       TYPE sy-repid
                !iv_include     TYPE sy-repid OPTIONAL
                !it_source_code TYPE stringtab
      RETURNING VALUE(rs_check) TYPE lcl_source_code=&gt;ts_source_code_check.

***------------------------------------------------------------------***
**                            ATTRIBUTS                               **
***------------------------------------------------------------------***

*	Déclaration d&apos;attributs


*-- Privée
  PRIVATE SECTION.

***------------------------------------------------------------------***
**                              TYPES                                 **
***------------------------------------------------------------------***

*   Déclaration de type

***------------------------------------------------------------------***
**                           MÉTHODES                                 **
***------------------------------------------------------------------***

*	Déclaration de méthodes

***------------------------------------------------------------------***
**                            ATTRIBUTS                               **
***------------------------------------------------------------------***

*	Déclaration d&apos;attributs

ENDCLASS.             &quot;lcl_source_code DEFINITION

*----------------------------------------------------------------------*
*       CLASS LCL_source_code IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_source_code IMPLEMENTATION.

  METHOD class_constructor.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  ENDMETHOD.

  METHOD repid_create.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
    DATA :
          ls_program_trdir TYPE trdir.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
    DATA :
      lv_program_corrnum  TYPE e070-trkorr,
      lv_program_ordernum TYPE e070-trkorr,
      lv_program_devclass TYPE tdevc-devclass.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Création du Programme
    &quot; -----------------------------------------------------------

    &quot; Initialisation données locale
    ls_program_trdir    = is_program_trdir.
    lv_program_corrnum  = iv_program_corrnum.
    lv_program_ordernum = iv_program_ordernum.
    lv_program_devclass = iv_program_devclass.

    &quot; Création du Programme avec les paramètres spécifiés
    CALL FUNCTION &apos;RS_EDTR_ATTR_ADD&apos;
      EXPORTING
        program_name          = is_program_trdir-name
        program_title         = CONV rs38m-repti( iv_program_title )
        with_trdir_entry      = abap_true
        suppress_dialog       = abap_true
        activate_immediately  = abap_false
        type_switch_allowed   = abap_true
        mainprogram_name      = iv_mainprogram_name
      CHANGING
        program_trdir         = ls_program_trdir
        program_corrnum       = lv_program_corrnum
        program_ordernum      = lv_program_ordernum
        program_devclass      = lv_program_devclass
      EXCEPTIONS
        program_name_missing  = 1
        program_exists        = 2
        wrong_parameter_value = 3
        action_cancelled      = 4
        OTHERS                = 5.
    IF sy-subrc NE 0.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Initialisation données de retour
      rs_return-id         = sy-msgid.
      rs_return-type       = sy-msgty.
      rs_return-number     = sy-msgno.
      rs_return-message_v1 = sy-msgv1.
      rs_return-message_v2 = sy-msgv2.
      rs_return-message_v3 = sy-msgv3.
      rs_return-message_v4 = sy-msgv4.

    ENDIF.

  ENDMETHOD.

  METHOD source_code_get.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
    DATA :
          lo_abap_pgeditor TYPE REF TO cl_wb_pgeditor.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Récupération du Code Source
    &quot; -----------------------------------------------------------

    &quot; Récupération du Code Source
    CREATE OBJECT lo_abap_pgeditor.
    lo_abap_pgeditor-&gt;read_source(
      EXPORTING
        source_name             = iv_repid
*         status                  = SPACE       &quot; Active (&apos;A&apos;)/Inactive (&apos;I&apos;)
        with_conversion         = abap_true     &quot; Conversion If Necessary
        with_enhancements       = abap_true     &quot; with enhancements
        with_impl_enhancements  = abap_false    &quot; without implicit enhancements
      IMPORTING
        source_tab              = rt_source_code
      EXCEPTIONS
        cancelled               = 1
        not_found               = 2
        read_protected          = 3
        OTHERS                  = 4
    ).
    IF sy-subrc NE 0.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Affiche message d&apos;erreur
      FREE : rt_source_code.
      MESSAGE ID sy-msgid TYPE &apos;S&apos;                          &quot;#EC NOTEXT
                        NUMBER sy-msgno
                          WITH sy-msgv1 sy-msgv2
                               sy-msgv3 sy-msgv4
                  DISPLAY LIKE sy-msgty.
    ENDIF.

    IF eo_abap_pgeditor IS SUPPLIED.
      eo_abap_pgeditor = lo_abap_pgeditor.

    ENDIF.

  ENDMETHOD.

  METHOD source_code_set.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Mise en Forme du Code Source
    &quot; -----------------------------------------------------------

    &quot; Application du Pretty Printer
    CALL FUNCTION &apos;PRETTY_PRINTER&apos;
      EXPORTING
        inctoo             = abap_false
      TABLES
        otext              = it_source_code
        ntext              = rt_source_code
      EXCEPTIONS
        include_enqueued   = 1
        include_readerror  = 2
        include_writeerror = 3
        enqueue_table_full = 4.
    IF sy-subrc NE 0.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Initialisation Code Source comme l&apos;entrée
      rt_source_code[] = it_source_code[].

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Modification du Code Source du Programme
    &quot; -----------------------------------------------------------

    &quot; Modification du Code Source (Pretty Printer)
    INSERT REPORT iv_repid FROM rt_source_code.

  ENDMETHOD.

  METHOD source_code_check.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Contrôle du Code Source
    &quot; -----------------------------------------------------------

    &quot; Contrôle le code à injecter
    IF iv_include IS INITIAL.
      &quot; Contrôle Programme Principal
      SYNTAX-CHECK FOR it_source_code MESSAGE rs_check-message      LINE rs_check-line
                                         WORD rs_check-word           ID &apos;MSG&apos; &quot;#EC NOTEXT
                                        TABLE rs_check-t_warning PROGRAM iv_repid.

    ELSE.
      &quot; Contrôle Include
      SYNTAX-CHECK FOR it_source_code MESSAGE rs_check-message      LINE rs_check-line
                                         WORD rs_check-word           ID &apos;MSG&apos; &quot;#EC NOTEXT
                                        TABLE rs_check-t_warning PROGRAM iv_repid
                                    REPLACING iv_include.

    ENDIF.

    &quot; Retourne code retour
    rs_check-subrc = sy-subrc.

  ENDMETHOD.

ENDCLASS.

*----------------------------------------------------------------------*
*       CLASS lcx_injector DEFINIION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcx_injector DEFINITION
                         INHERITING FROM cx_dynamic_check
                                    FINAL CREATE PUBLIC .

*-- Publique
  PUBLIC SECTION.

    INTERFACES if_t100_message .

    METHODS constructor
      IMPORTING
        !textid   LIKE if_t100_message=&gt;t100key OPTIONAL
        !previous LIKE previous OPTIONAL .


ENDCLASS.             &quot;lcx_injector DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcx_injector IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcx_injector IMPLEMENTATION.

  METHOD constructor.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    CALL METHOD super-&gt;constructor
      EXPORTING
        previous = previous.
    CLEAR me-&gt;textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = if_t100_message=&gt;default_textid.
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.

  ENDMETHOD.

ENDCLASS.


*----------------------------------------------------------------------*
*       CLASS LCL_injector DEFINIION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_injector DEFINITION FINAL.

*-- Publique
  PUBLIC SECTION.

***------------------------------------------------------------------***
**                              TYPES                                 **
***------------------------------------------------------------------***

*   Déclaration de type

***------------------------------------------------------------------***
**                           MÉTHODES                                 **
***------------------------------------------------------------------***

*	Déclaration de méthodes

    &quot; Constructeur
    METHODS constructor
      IMPORTING
        !is_task_wizard_data TYPE ztec_s_task_wizard_data
      RAISING
        lcx_injector.

    &quot; Traitement Principal
    METHODS main
      RAISING
        lcx_injector.

***------------------------------------------------------------------***
**                            ATTRIBUTS                               **
***------------------------------------------------------------------***

*	Déclaration d&apos;attributs


*-- Privée
  PRIVATE SECTION.

***------------------------------------------------------------------***
**                              TYPES                                 **
***------------------------------------------------------------------***

*   Déclaration de type

    TYPES :
      BEGIN OF ts_template_anchor_detail,
        header     TYPE stringtab,
        header_set TYPE xsdboolean,
        body       TYPE stringtab,
        end        TYPE stringtab,
      END OF   ts_template_anchor_detail.

    TYPES :
      BEGIN OF ts_template_anchor_function,
        at_eot      TYPE ts_template_anchor_detail,
        before_task TYPE ts_template_anchor_detail,
      END OF   ts_template_anchor_function.

    TYPES :
      BEGIN OF ts_template_anchor_method_det,
        classname  TYPE ts_template_anchor_detail,
        methodname TYPE ts_template_anchor_detail,
      END OF   ts_template_anchor_method_det.

    TYPES :
      BEGIN OF ts_template_anchor_method,
        at_eot      TYPE ts_template_anchor_method_det,
        before_task TYPE ts_template_anchor_method_det,
      END OF   ts_template_anchor_method.

    TYPES :
      BEGIN OF ts_template_anchor_repid,
        at_eot      TYPE ts_template_anchor_detail,
        before_task TYPE ts_template_anchor_detail,
      END OF   ts_template_anchor_repid.

    TYPES :
      BEGIN OF ts_template_anchor,
        repid    TYPE ts_template_anchor_repid,
        method   TYPE ts_template_anchor_method,
        function TYPE ts_template_anchor_function,
      END OF   ts_template_anchor.

    TYPES :
      BEGIN OF ts_classname_list,
        event     TYPE string,
        classname TYPE string,
      END OF   ts_classname_list.

    TYPES : tt_classname_list TYPE SORTED TABLE OF ts_classname_list
            WITH UNIQUE KEY primary_key COMPONENTS event classname.

    TYPES :
      BEGIN OF ts_source_code,
        t_target_repid                 TYPE stringtab,
        t_target_incl_framework        TYPE stringtab,
        t_target_incl_selscreen        TYPE stringtab,
        t_template_task                TYPE stringtab,
        t_template_framework           TYPE stringtab,
        t_template_selscreen           TYPE stringtab,
        t_template_wizard_include_sign TYPE stringtab,
      END OF   ts_source_code.

    TYPES :
      BEGIN OF ts_transport_request,
        corrnum       TYPE e070-trkorr,
        ordernum      TYPE e070-trkorr,
        devclass      TYPE tadir-devclass,
        transport_key TYPE trkey,
      END OF   ts_transport_request.

***------------------------------------------------------------------***
**                           MÉTHODES                                 **
***------------------------------------------------------------------***

*	Déclaration de méthodes

    &quot; Injection du Template dans le programme Cible
    METHODS template_task_inject
      RETURNING VALUE(rv_subrc) TYPE sy-subrc.

    &quot; Template - Application
    METHODS template_apply.

    &quot; Template - Contrôle Code Source
    METHODS template_source_code_check
      EXPORTING
                ev_include_used TYPE xsdboolean
      RETURNING VALUE(rs_check) TYPE lcl_source_code=&gt;ts_source_code_check.

    &quot; Template - Injection
    METHODS template_source_code_inject.

    &quot; Création de l&apos;Include
    METHODS include_task_create
      IMPORTING
                iv_include_name       TYPE sy-repid
                iv_include_title      TYPE clike
      RETURNING VALUE(rt_source_code) TYPE stringtab.

    &quot; Ajout de l&apos;Include dans le Template
    METHODS template_task_include_add
      IMPORTING
        iv_include TYPE sy-repid.

    &quot; Ajout du Template du Cadriciel
    METHODS template_task_add
      CHANGING ct_source_code TYPE stringtab.

    &quot; Ajout du Template d&apos;Ecran de sélection
    METHODS template_selscreen_add
      CHANGING ct_source_code TYPE stringtab.

    &quot; Ajout du Template Modification Ecran de sélection
    METHODS template_selscreen_output_add
      CHANGING ct_source_code TYPE stringtab.

    &quot; Récupération du Template de Tâche
    METHODS template_task_get
      RAISING lcx_injector.

    &quot; Template - Modification attribut
    METHODS template_task_attribute_set.

    &quot; Template - Attributs - Génération - Modification
    METHODS template_task_attr_wizard_set.

    &quot; Template - Attributs - Configuration - Modification
    METHODS template_task_attr_config_set.

    &quot; Récupération Template
    METHODS template_get_by_anchor
      IMPORTING
                iv_anchor_beg      TYPE clike
                iv_anchor_end      TYPE clike
      RETURNING VALUE(rt_template) TYPE stringtab
      RAISING   lcx_injector.

    &quot; Modification Template Handler
    METHODS template_handler_task_set.

    &quot; Template - Ajout traitement sur Evènement
    METHODS template_handler_add
      IMPORTING
        iv_event             TYPE clike
        is_task_call_process TYPE ztec_s_task_call_process.

    &quot; Template - Anchor - Chargement
    METHODS template_anchor_load.

    &quot; Template - Anchor - Chargement - Programme
    METHODS template_anchor_load_repid.

    &quot; Template - Anchor - Chargement - Méthode
    METHODS template_anchor_load_method.

    &quot; Template - Anchor - Chargement - MF
    METHODS template_anchor_load_function.

    &quot; Template - Anchor - Nettoyage
    METHODS template_anchor_clean.

    &quot; Ordre de Transport - Ajout
    METHODS transport_request_add
      IMPORTING
                !iv_repid       TYPE sy-repid
      RETURNING VALUE(rv_subrc) TYPE sy-subrc.

***------------------------------------------------------------------***
**                            ATTRIBUTS                               **
***------------------------------------------------------------------***

* Constantes

    &quot; Template :
    CONSTANTS : mc_template_classname TYPE string VALUE &apos;LCL_TASK_TEMPLATE&apos;. &quot;#EC NOTEXT

    &quot; Evènement :
    CONSTANTS : mc_event_at_eot      TYPE string VALUE &apos;AT_EOT&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_event_before_task TYPE string VALUE &apos;BEFORE_TASK&apos;. &quot;#EC NOTEXT

    &quot; Anchor Variable - Implémentation :
    CONSTANTS : mc_anchor_grfc               TYPE string VALUE &apos;#grfc#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_datum              TYPE string VALUE &apos;#DATUM#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_uname              TYPE string VALUE &apos;#UNAME#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_grfc_r             TYPE string VALUE &apos;#grfc_r#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_task_max           TYPE string VALUE &apos;#task_max#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_task_trace         TYPE string VALUE &apos;#task_trace#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_compress_l         TYPE string VALUE &apos;#compress_l#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_compress_g         TYPE string VALUE &apos;#compress_g#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_compress_activ     TYPE string VALUE &apos;#compress_activ#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_shm_management     TYPE string VALUE &apos;#shm_management#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_use_server_default TYPE string VALUE &apos;#use_server_default#&apos;. &quot;#EC NOTEXT

    &quot; Anchor Méthode / Traitement :
    CONSTANTS : mc_anchor_at_eot               TYPE string VALUE &apos;ANCHOR-AT_EOT&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_before_task          TYPE string VALUE &apos;ANCHOR-BEFORE_TASK&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_template_task_beg    TYPE string VALUE &apos;#ANCHOR-TASK_TEMPLATE-BEG#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_template_task_end    TYPE string VALUE &apos;#ANCHOR-TASK_TEMPLATE-END#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_template_sign_beg    TYPE string VALUE &apos;#ANCHOR-WIZARD_SIGN-INCLUDE-BEG#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_template_sign_end    TYPE string VALUE &apos;#ANCHOR-WIZARD_SIGN-INCLUDE-END#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_template_selscre_beg TYPE string VALUE &apos;#ANCHOR-SELECTION-SCREEN-BEG#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_template_selscre_end TYPE string VALUE &apos;#ANCHOR-SELECTION-SCREEN-END#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_template_outputd_beg TYPE string VALUE &apos;#ANCHOR-AT_SELECTION_SCREEN_OUTPUT-DEF-BEG#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_template_outputd_end TYPE string VALUE &apos;#ANCHOR-AT_SELECTION_SCREEN_OUTPUT-DEF-END#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_template_outputi_beg TYPE string VALUE &apos;#ANCHOR-AT_SELECTION_SCREEN_OUTPUT-IMPL-BEG#&apos;. &quot;#EC NOTEXT
    CONSTANTS : mc_anchor_template_outputi_end TYPE string VALUE &apos;#ANCHOR-AT_SELECTION_SCREEN_OUTPUT-IMPL-END#&apos;. &quot;#EC NOTEXT

*	Déclaration d&apos;attributs
    DATA : ms_source_code TYPE ts_source_code.
    DATA : mv_repid_target TYPE sy-repid.
    DATA : mt_classname_list TYPE tt_classname_list.
    DATA : mv_task_classname TYPE string.
    DATA : ms_template_anchor TYPE ts_template_anchor.
    DATA : ms_task_wizard_data TYPE ztec_s_task_wizard_data.
    DATA : ms_transport_request TYPE ts_transport_request.
    DATA : mt_task_call_process TYPE ztec_t_task_call_process.

ENDCLASS.             &quot;lcl_injector DEFINITION

*----------------------------------------------------------------------*
*       CLASS LCL_injector IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_injector IMPLEMENTATION.

  METHOD constructor.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
    DATA :
          ls_textid TYPE scx_t100key.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
    FIELD-SYMBOLS :
                   &lt;lfs_instance&gt; TYPE any.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Contrôle
    &quot; -----------------------------------------------------------

    IF is_task_wizard_data-target_repid IS INITIAL
    OR is_task_wizard_data-task_template_repid IS INITIAL.
      &quot; Pas de programme
      RAISE EXCEPTION TYPE lcx_injector.

    ELSEIF is_task_wizard_data-target_repid(1)        NE &apos;Z&apos; &quot;#EC NOTEXT
        OR is_task_wizard_data-task_template_repid(1) NE &apos;Z&apos;. &quot;#EC NOTEXT
      &quot; Pas un programme spécifique
      RAISE EXCEPTION TYPE lcx_injector.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Initialisation Attributs
    &quot; -----------------------------------------------------------

    me-&gt;mv_repid_target        = is_task_wizard_data-target_repid.
    me-&gt;ms_task_wizard_data    = is_task_wizard_data.
    me-&gt;mt_task_call_process[] = is_task_wizard_data-t_task_call_process[].

    &quot; -----------------------------------------------------------
    &quot; Récupération du Template de Tâche
    &quot; -----------------------------------------------------------

    &quot; Récupération du Code Source du Programme courant
    me-&gt;template_task_get( ).

    &quot; -----------------------------------------------------------
    &quot; Modification des Attributs du Template
    &quot; -----------------------------------------------------------

    &quot; Modification des variables
    me-&gt;template_task_attribute_set( ).

  ENDMETHOD.

  METHOD main.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
    DATA :
      ls_textid            TYPE scx_t100key,
      ls_code_source_check TYPE lcl_source_code=&gt;ts_source_code_check.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Modification Template Traitement Handler
    &quot; -----------------------------------------------------------

    &quot; Modification Template Handler
    me-&gt;template_handler_task_set( ).

    &quot; -----------------------------------------------------------
    &quot; Suppression des références d&apos;ancrage du Template
    &quot; -----------------------------------------------------------

    &quot; Nettoyage du Template
    me-&gt;template_anchor_clean( ).

    &quot; -----------------------------------------------------------
    &quot; Injection du Template
    &quot; -----------------------------------------------------------

    &quot; Pousse le Template dans le programme cible
    IF NOT me-&gt;template_task_inject( ) IS INITIAL.
      &quot; Une erreur de syntaxe est présente
      &quot;&quot;  --&gt; Lève une Exception
      ls_textid-msgno = 304.                                &quot;#EC NOTEXT
      ls_textid-msgid = &apos;BRAINOLAPAPI&apos;.                     &quot;#EC NOTEXT
      RAISE EXCEPTION TYPE lcx_injector
        EXPORTING
          textid = ls_textid.

    ENDIF.

  ENDMETHOD.

  METHOD template_handler_task_set.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Modifie le Template des Handler
    &quot; -----------------------------------------------------------

    LOOP AT me-&gt;mt_task_call_process ASSIGNING FIELD-SYMBOL(&lt;lfs_s_task_call_process&gt;).

      &quot; -----------------------------------------------------------
      &quot; Modification Template Traitement AT_EOT
      &quot; -----------------------------------------------------------

      &quot; Ajout Template Evènement - AT_EOT
      me-&gt;template_handler_add(
        iv_event             = lcl_injector=&gt;mc_event_at_eot
        is_task_call_process = &lt;lfs_s_task_call_process&gt;
      ).

      &quot; Ajout Template Evènement - BEFORE_TASK
      me-&gt;template_handler_add(
        iv_event             = lcl_injector=&gt;mc_event_before_task
        is_task_call_process = &lt;lfs_s_task_call_process&gt;
      ).

    ENDLOOP.

  ENDMETHOD.

  METHOD template_anchor_load.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Charge les Templates liées aux Anchors Programme
    &quot; -----------------------------------------------------------

    me-&gt;template_anchor_load_repid( ).

    &quot; -----------------------------------------------------------
    &quot; Charge les Templates liées aux Anchors Méthode
    &quot; -----------------------------------------------------------

    me-&gt;template_anchor_load_method( ).

    &quot; -----------------------------------------------------------
    &quot; Charge les Templates liées aux Anchors MF
    &quot; -----------------------------------------------------------

    me-&gt;template_anchor_load_function( ).

  ENDMETHOD.

  METHOD template_anchor_load_method.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Charge les Templates liées aux Anchors Méthode - CLASSNAME
    &quot; -----------------------------------------------------------

    &quot; BEFORE_TASK &amp; AT_EOT - CLASSNAME - classname
    me-&gt;ms_template_anchor-method-before_task-classname-header
      = me-&gt;ms_template_anchor-method-at_eot-classname-header
      = VALUE stringtab(
      ( |&quot; -----------------------------------------------------------| ) &quot;#EC NOTEXT
      ( |&quot; Traitement sur Méthode Statique| )
      ( |&quot; -----------------------------------------------------------| ) &quot;#EC NOTEXT
      ( )
      ( |&quot; Suivant la Classe appelée| )                     &quot;#EC NOTEXT
      ( |CASE is_task_call_process-class_name.| )           &quot;#EC NOTEXT
      ( )
    ).

    &quot; Ajout Anchor pour positionner les Classes
    APPEND |//ANCHOR-AT_EOT-CLASSLIST|      TO ms_template_anchor-method-at_eot-classname-header. &quot;#EC NOTEXT
    APPEND |//ANCHOR-BEFORE_TASK-CLASSLIST| TO me-&gt;ms_template_anchor-method-before_task-classname-header. &quot;#EC NOTEXT

    &quot; BEFORE_TASK &amp; AT_EOT - CLASSNAME - Corps
    me-&gt;ms_template_anchor-method-before_task-classname-body
      = me-&gt;ms_template_anchor-method-at_eot-classname-body
      = VALUE stringtab(
      ( |WHEN &apos;&lt;&amp;CLASSNAME&amp;&gt;&apos;. &quot;#EC NOTEXT| )               &quot;#EC NOTEXT
      ( | &quot;Classe &lt;&amp;CLASSNAME&amp;&gt; | )
      ( |&quot;&quot;  --&gt; Suivant la méthode appelée| )              &quot;#EC NOTEXT
      ( |CASE is_task_call_process-method_name.| )          &quot;#EC NOTEXT
      ( )
    ).

    &quot; Ajout Anchor pour positionner les Méthodes de Classes
    APPEND |//ANCHOR-AT_EOT-&lt;&amp;CLASSNAME&amp;&gt;-METHODLIST|      TO me-&gt;ms_template_anchor-method-at_eot-classname-body. &quot;#EC NOTEXT
    APPEND |//ANCHOR-BEFORE_TASK-&lt;&amp;CLASSNAME&amp;&gt;-METHODLIST| TO me-&gt;ms_template_anchor-method-before_task-classname-body. &quot;#EC NOTEXT

    &quot; BEFORE_TASK &amp; AT_EOT - CLASSNAME - Fin
    me-&gt;ms_template_anchor-method-before_task-classname-end
      = me-&gt;ms_template_anchor-method-at_eot-classname-end
      = VALUE stringtab(
      ( |WHEN OTHERS.| )                                    &quot;#EC NOTEXT
      ( | &quot; Autre classe| )                                 &quot;#EC NOTEXT
      ( )
      ( |ENDCASE.| )                                        &quot;#EC NOTEXT
      ( )
    ).

    &quot; -----------------------------------------------------------
    &quot; Charge les Templates liées aux Anchors Méthode - METHODNAME
    &quot; -----------------------------------------------------------

    &quot; BEFORE_TASK &amp; AT_EOT - METHODNAME - Corps
    me-&gt;ms_template_anchor-method-before_task-methodname-body
      = me-&gt;ms_template_anchor-method-at_eot-methodname-body
      = VALUE stringtab(
      ( |WHEN &apos;&lt;&amp;PROCESS&amp;&gt;&apos;. &quot;#EC NOTEXT| )                 &quot;#EC NOTEXT
      ( |&quot;&quot;  --&gt; Traitement sur Méthode &lt;&amp;PROCESS&amp;&gt;| )      &quot;#EC NOTEXT
      ( |&quot;ToDo | )                                          &quot;#EC NOTEXT
      ( )
    ).

    &quot; BEFORE_TASK &amp; AT_EOT - METHODNAME - Fin
    me-&gt;ms_template_anchor-method-before_task-methodname-end
      = me-&gt;ms_template_anchor-method-at_eot-methodname-end
      = VALUE stringtab(
      ( |WHEN OTHERS.| )                                    &quot;#EC NOTEXT
      ( | &quot; Autre méthode| )                                &quot;#EC NOTEXT
      ( )
      ( |ENDCASE.| )                                        &quot;#EC NOTEXT
      ( )
    ).

  ENDMETHOD.

  METHOD template_anchor_load_function.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Charge les Templates liées aux Anchors MF - AT_EOT
    &quot; -----------------------------------------------------------

    &quot; BEFORE_TASK &amp; AT_EOT - Entête
    me-&gt;ms_template_anchor-function-before_task-header = me-&gt;ms_template_anchor-function-at_eot-header
      = VALUE stringtab(
      ( |&quot; -----------------------------------------------------------| ) &quot;#EC NOTEXT
      ( |&quot; Traitement sur Module Fonction| )                &quot;#EC NOTEXT
      ( |&quot; -----------------------------------------------------------| ) &quot;#EC NOTEXT
      ( )
      ( |&quot; Suivant le MF appelé| )                          &quot;#EC NOTEXT
      ( |CASE is_task_call_process-function_name.| )        &quot;#EC NOTEXT
      ( )
    ).

    &quot; Ajout Anchor pour positionner les MF
    APPEND |//ANCHOR-AT_EOT-FUNCTIONLIST|      TO me-&gt;ms_template_anchor-function-at_eot-header. &quot;#EC NOTEXT
    APPEND |//ANCHOR-BEFORE_TASK-FUNCTIONLIST| TO me-&gt;ms_template_anchor-function-before_task-header. &quot;#EC NOTEXT

    &quot; BEFORE_TASK &amp; AT_EOT - Corps
    me-&gt;ms_template_anchor-function-before_task-body = me-&gt;ms_template_anchor-function-at_eot-body
      = VALUE stringtab(
      ( |WHEN &apos;&lt;&amp;PROCESS&amp;&gt;&apos;. &quot;#EC NOTEXT| )                 &quot;#EC NOTEXT
      ( |&quot;&quot;  --&gt; Traitement sur MF &lt;&amp;PROCESS&amp;&gt;| )           &quot;#EC NOTEXT
      ( |&quot;ToDo | )                                          &quot;#EC NOTEXT
      ( )
    ).

    &quot; BEFORE_TASK &amp; AT_EOT - Fin
    me-&gt;ms_template_anchor-function-before_task-end = me-&gt;ms_template_anchor-function-at_eot-end
      = VALUE stringtab(
      ( |WHEN OTHERS.| )                                    &quot;#EC NOTEXT
      ( | &quot; Autre cas| )                                    &quot;#EC NOTEXT
      ( )
      ( |ENDCASE.| )                                        &quot;#EC NOTEXT
      ( )
    ).

  ENDMETHOD.

  METHOD template_anchor_load_repid.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Charge les Templates liées aux Anchors Programme - AT_EOT
    &quot; -----------------------------------------------------------

    &quot; BEFORE_TASK &amp; AT_EOT - Entête
    me-&gt;ms_template_anchor-function-before_task-header = me-&gt;ms_template_anchor-repid-at_eot-header
      = VALUE stringtab(
      ( |&quot; -----------------------------------------------------------| ) &quot;#EC NOTEXT
      ( |&quot; Traitement sur Programme| )                      &quot;#EC NOTEXT
      ( |&quot; -----------------------------------------------------------| ) &quot;#EC NOTEXT
      ( )
      ( |&quot; Suivant le Programme appelé| )                   &quot;#EC NOTEXT
      ( |CASE is_task_call_process-repid_name.| )           &quot;#EC NOTEXT
      ( )
    ).

    &quot; Ajout Anchor pour positionner les Programmes
    APPEND |//ANCHOR-AT_EOT-REPIDLIST|      TO me-&gt;ms_template_anchor-repid-at_eot-header. &quot;#EC NOTEXT
    APPEND |//ANCHOR-BEFORE_TASK-REPIDLIST| TO me-&gt;ms_template_anchor-repid-before_task-header. &quot;#EC NOTEXT

    &quot; BEFORE_TASK &amp; AT_EOT - Corps
    me-&gt;ms_template_anchor-function-before_task-body = me-&gt;ms_template_anchor-repid-at_eot-body
      = VALUE stringtab(
      ( |WHEN &apos;&lt;&amp;PROCESS&amp;&gt;&apos;. &quot;#EC NOTEXT| )                 &quot;#EC NOTEXT
      ( |&quot;&quot;  --&gt; Traitement sur Programme &lt;&amp;PROCESS&amp;&gt;| )    &quot;#EC NOTEXT
      ( |&quot;ToDo | )                                          &quot;#EC NOTEXT
      ( )
    ).

    &quot; BEFORE_TASK &amp; AT_EOT - Fin
    me-&gt;ms_template_anchor-function-before_task-end = me-&gt;ms_template_anchor-repid-at_eot-end
      = VALUE stringtab(
      ( |WHEN OTHERS.| )                                    &quot;#EC NOTEXT
      ( | &quot; Autre cas| )                                    &quot;#EC NOTEXT
      ( )
      ( |ENDCASE.| )                                        &quot;#EC NOTEXT
      ( )
    ).

  ENDMETHOD.

  METHOD template_anchor_clean.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Suppression des ancrages liées au Template Evènement
    &quot; -----------------------------------------------------------

    &quot; Recherche position de tous les Anchor AT_EOT
    FIND ALL OCCURRENCES OF lcl_injector=&gt;mc_anchor_at_eot
                   IN TABLE me-&gt;ms_source_code-t_template_task
                    RESULTS DATA(lt_results).
    IF sy-subrc EQ 0.
      &quot; Suppression des Anchors
      SORT lt_results BY line DESCENDING.
      LOOP AT lt_results ASSIGNING FIELD-SYMBOL(&lt;lfs_s_results&gt;).

        DELETE me-&gt;ms_source_code-t_template_task INDEX &lt;lfs_s_results&gt;-line.

      ENDLOOP.

    ENDIF.

    &quot; Recherche position de tous les Anchor BEFORE_TASK
    FIND ALL OCCURRENCES OF lcl_injector=&gt;mc_anchor_before_task
                   IN TABLE me-&gt;ms_source_code-t_template_task
                    RESULTS lt_results.
    IF sy-subrc EQ 0.
      &quot; Suppression des Anchors
      SORT lt_results BY line DESCENDING.
      LOOP AT lt_results ASSIGNING &lt;lfs_s_results&gt;.

        DELETE me-&gt;ms_source_code-t_template_task INDEX &lt;lfs_s_results&gt;-line.

      ENDLOOP.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Suppression des ancrages liées au Template Ecran de Sélection
    &quot; -----------------------------------------------------------

    &quot; Recherche Anchor Définition - Début
    FIND lcl_injector=&gt;mc_anchor_template_outputd_beg IN TABLE me-&gt;ms_source_code-t_template_task
                                                    MATCH LINE DATA(lv_line_def_beg).
    IF sy-subrc EQ 0.
      &quot; Recherche Anchor Définition - Fin
      FIND lcl_injector=&gt;mc_anchor_template_outputd_end IN TABLE me-&gt;ms_source_code-t_template_task
                                                      MATCH LINE DATA(lv_line_def_end).

    ENDIF.

    &quot; Recherche Anchor Implémentation - Début
    FIND lcl_injector=&gt;mc_anchor_template_outputi_beg IN TABLE me-&gt;ms_source_code-t_template_task
                                                    MATCH LINE DATA(lv_line_impl_beg).
    IF sy-subrc EQ 0.
      &quot; Recherche Anchor Implémentation - Fin
      FIND lcl_injector=&gt;mc_anchor_template_outputi_end IN TABLE me-&gt;ms_source_code-t_template_task
                                                      MATCH LINE DATA(lv_line_impl_end).

    ENDIF.

    IF me-&gt;ms_task_wizard_data-target_selscreen_add EQ abap_true.
      &quot; Ajout à l&apos;Ecran de Sélection
      IF NOT lv_line_impl_end IS INITIAL AND NOT lv_line_impl_beg IS INITIAL.
        &quot;&quot;  --&gt; Suppression des Anchor de l&apos;Implémentation
        DELETE me-&gt;ms_source_code-t_template_task INDEX : lv_line_impl_end, lv_line_impl_beg.

      ENDIF.

      IF NOT lv_line_def_end IS INITIAL AND NOT lv_line_def_beg IS INITIAL.
        &quot;&quot;  --&gt; Suppression des Anchor de la Définition
        DELETE me-&gt;ms_source_code-t_template_task INDEX : lv_line_def_end, lv_line_def_beg.

      ENDIF.

    ELSE.
      &quot; Non ajouté à l&apos;Ecran de Sélection
      IF NOT lv_line_impl_end IS INITIAL AND NOT lv_line_impl_beg IS INITIAL.
        &quot;&quot;  --&gt; Suppression de l&apos;Implémentation
        DELETE me-&gt;ms_source_code-t_template_task FROM lv_line_impl_beg TO lv_line_impl_end.

      ENDIF.

      IF NOT lv_line_def_end IS INITIAL AND NOT lv_line_def_beg IS INITIAL.
        &quot;&quot;  --&gt; Suppression de la Définition
        DELETE me-&gt;ms_source_code-t_template_task FROM lv_line_def_beg TO lv_line_def_end.

      ENDIF.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Suppression des ancrages liées à la Signature
    &quot; -----------------------------------------------------------

    IF me-&gt;ms_task_wizard_data-target_framework_incl_use EQ abap_true.
      &quot; Recherche position de début
      CLEAR : lv_line_def_end, lv_line_def_beg.
      FIND lcl_injector=&gt;mc_anchor_template_sign_beg IN TABLE me-&gt;ms_source_code-t_target_incl_framework
                                                   MATCH LINE lv_line_def_beg.
      IF sy-subrc EQ 0.
        &quot; Recherche position de Fin
        FIND lcl_injector=&gt;mc_anchor_template_sign_beg IN TABLE me-&gt;ms_source_code-t_target_incl_framework
                                                     MATCH LINE lv_line_def_end.

      ENDIF.
      IF NOT lv_line_def_end IS INITIAL AND NOT lv_line_def_beg IS INITIAL.
        &quot;&quot;  --&gt; Suppression de l&apos;Implémentation
        DELETE me-&gt;ms_source_code-t_target_incl_framework FROM lv_line_def_beg TO lv_line_def_end.

      ENDIF.

    ENDIF.

    IF  me-&gt;ms_task_wizard_data-target_selscreen_add      EQ abap_true
    AND me-&gt;ms_task_wizard_data-target_selscreen_incl_use EQ abap_true.
      &quot; Recherche position de début
      CLEAR : lv_line_def_end, lv_line_def_beg.
      FIND lcl_injector=&gt;mc_anchor_template_sign_beg IN TABLE me-&gt;ms_source_code-t_target_incl_selscreen
                                                   MATCH LINE lv_line_def_beg.
      IF sy-subrc EQ 0.
        &quot; Recherche position de Fin
        FIND lcl_injector=&gt;mc_anchor_template_sign_beg IN TABLE me-&gt;ms_source_code-t_target_incl_selscreen
                                                     MATCH LINE lv_line_def_end.

      ENDIF.
      IF NOT lv_line_def_end IS INITIAL AND NOT lv_line_def_beg IS INITIAL.
        &quot;&quot;  --&gt; Suppression de l&apos;Implémentation
        DELETE me-&gt;ms_source_code-t_target_incl_selscreen FROM lv_line_def_beg TO lv_line_def_end.

      ENDIF.

    ENDIF.

  ENDMETHOD.

  METHOD template_task_get.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
    DATA :
          ls_textid TYPE scx_t100key.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    CLEAR : me-&gt;ms_source_code.

    &quot; -----------------------------------------------------------
    &quot; Récupération du Code Source du Programme Cadre
    &quot; -----------------------------------------------------------

    &quot; Récupération du Code Source du Programme Cadre
    me-&gt;ms_source_code-t_target_repid = lcl_source_code=&gt;source_code_get( me-&gt;ms_task_wizard_data-target_repid ).
    IF me-&gt;ms_source_code-t_target_repid[] IS INITIAL.
      &quot; Source non trouvée
      &quot;&quot;  --&gt; Lève une Exception
      ls_textid-msgid = zif_task_constant=&gt;mc_message_class_id.
      ls_textid-msgno = 606.
      ls_textid-attr1 = me-&gt;ms_task_wizard_data-target_repid.
      RAISE EXCEPTION TYPE lcx_injector
        EXPORTING
          textid = ls_textid.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Récupération du Code Source du Template
    &quot; -----------------------------------------------------------

    &quot; Récupération du Code Source du Programme Template
    me-&gt;ms_source_code-t_template_framework = lcl_source_code=&gt;source_code_get( me-&gt;ms_task_wizard_data-task_template_repid ).
    IF me-&gt;ms_source_code-t_template_framework[] IS INITIAL.
      &quot; Source non trouvée
      &quot;&quot;  --&gt; Lève une Exception
      ls_textid-msgid = zif_task_constant=&gt;mc_message_class_id.
      ls_textid-msgno = 606.
      ls_textid-attr1 = me-&gt;ms_task_wizard_data-task_template_repid.
      RAISE EXCEPTION TYPE lcx_injector
        EXPORTING
          textid = ls_textid.

    ENDIF.

    IF  me-&gt;ms_task_wizard_data-target_selscreen_add      EQ abap_true
    AND me-&gt;ms_task_wizard_data-target_selscreen_incl_use EQ abap_true.
      &quot; Ajout dans l&apos;Ecran de Sélection et Utilisation Include
      IF me-&gt;ms_task_wizard_data-target_selscreen_incl_data-include_change EQ abap_true.
        &quot; Modification de l&apos;Include spécifié
        &quot;&quot;  --&gt; Récupération du Code Source de l&apos;Include pour l&apos;Ecran de Sélection
        me-&gt;ms_source_code-t_target_incl_selscreen = lcl_source_code=&gt;source_code_get(
          me-&gt;ms_task_wizard_data-target_selscreen_incl_data-include_name
        ).

      ELSE.
        &quot; Création de l&apos;Include spécifié
        &quot;&quot;  --&gt; Création de l&apos;Include
        me-&gt;ms_source_code-t_target_incl_selscreen = me-&gt;include_task_create(
          iv_include_name  = me-&gt;ms_task_wizard_data-target_selscreen_incl_data-include_name
          iv_include_title = me-&gt;ms_task_wizard_data-target_selscreen_incl_data-include_name
        ).

      ENDIF.

      &quot;&quot;  --&gt; Ajout de l&apos;Include dans le Programme principal
      me-&gt;template_task_include_add( me-&gt;ms_task_wizard_data-target_selscreen_incl_data-include_name ).

    ENDIF.

    IF me-&gt;ms_task_wizard_data-target_framework_incl_use EQ abap_true.
      &quot; Utilisation d&apos;un Include pour le Cadriciel
      IF me-&gt;ms_task_wizard_data-target_framework_incl_data-include_change EQ abap_true.
        &quot; Modification de l&apos;Include spécifié
        &quot;&quot;  --&gt; Récupération du Code Source de l&apos;Include pour le Cadriciel
        me-&gt;ms_source_code-t_target_incl_framework = lcl_source_code=&gt;source_code_get(
          me-&gt;ms_task_wizard_data-target_framework_incl_data-include_name
        ).

      ELSE.
        &quot; Création de l&apos;Include spécifié
        &quot;&quot;  --&gt; Création de l&apos;Include
        me-&gt;ms_source_code-t_target_incl_framework = me-&gt;include_task_create(
          iv_include_name  = me-&gt;ms_task_wizard_data-target_framework_incl_data-include_name
          iv_include_title = me-&gt;ms_task_wizard_data-target_selscreen_incl_data-include_name
        ).

      ENDIF.

      &quot;&quot;  --&gt; Ajout de l&apos;Include dans le Programme principal
      me-&gt;template_task_include_add( me-&gt;ms_task_wizard_data-target_framework_incl_data-include_name ).

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Récupération du Template du Cadriciel de Tâche
    &quot; -----------------------------------------------------------

    &quot; Retourne le Template du Cadriciel de Tâche
    me-&gt;ms_source_code-t_template_task = me-&gt;template_get_by_anchor(
      iv_anchor_beg = lcl_injector=&gt;mc_anchor_template_task_beg
      iv_anchor_end = lcl_injector=&gt;mc_anchor_template_task_end
    ).

    &quot; -----------------------------------------------------------
    &quot; Récupération du Template d&apos;Ecran de sélection
    &quot; -----------------------------------------------------------

    &quot; Retourne le Template d&apos;Ecran de sélection
    me-&gt;ms_source_code-t_template_selscreen = me-&gt;template_get_by_anchor(
      iv_anchor_beg = lcl_injector=&gt;mc_anchor_template_selscre_beg
      iv_anchor_end = lcl_injector=&gt;mc_anchor_template_selscre_end
    ).

    &quot; -----------------------------------------------------------
    &quot; Récupération du Template de Signature
    &quot; -----------------------------------------------------------

    &quot; Retourne le Template de Signature
    me-&gt;ms_source_code-t_template_wizard_include_sign = me-&gt;template_get_by_anchor(
      iv_anchor_beg = lcl_injector=&gt;mc_anchor_template_sign_beg
      iv_anchor_end = lcl_injector=&gt;mc_anchor_template_sign_end
    ).

    &quot; -----------------------------------------------------------
    &quot; Charge les Templates MF et Méthode
    &quot; -----------------------------------------------------------

    me-&gt;template_anchor_load( ).

  ENDMETHOD.

  METHOD template_get_by_anchor.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
    DATA :
          ls_textid TYPE scx_t100key.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Isole Position début et fin du Template recherché
    &quot; -----------------------------------------------------------

    &quot; Détermine position du template de Tâche (1er et dernière ligne)
    FIND iv_anchor_beg IN TABLE me-&gt;ms_source_code-t_template_framework MATCH LINE DATA(lv_line_beg). &quot;#EC NOTEXT
    FIND iv_anchor_end IN TABLE me-&gt;ms_source_code-t_template_framework MATCH LINE DATA(lv_line_end). &quot;#EC NOTEXT
    IF lv_line_end IS INITIAL OR lv_line_beg IS INITIAL.
      &quot; Source non trouvée
      &quot;&quot;  --&gt; Lève une Exception
      ls_textid-msgid = zif_task_constant=&gt;mc_message_class_id.
      ls_textid-msgno = 605.
      ls_textid-attr1 = iv_anchor_beg.
      ls_textid-attr2 = iv_anchor_end.
      RAISE EXCEPTION TYPE lcx_injector
        EXPORTING
          textid = ls_textid.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Isole le Template d&apos;Ecran de sélection
    &quot; -----------------------------------------------------------

    &quot; Retourne le Template Ecran de sélection
    rt_template = VALUE stringtab(
      FOR i = lv_line_beg + 1 UNTIL i &gt; lv_line_end - 1 &quot;Se positionne après l&apos;Anchor de début et avant celui de fin
        ( me-&gt;ms_source_code-t_template_framework[ i ] )
    ).

  ENDMETHOD.

  METHOD template_task_attribute_set.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Modification des attributs de génération du Template
    &quot; -----------------------------------------------------------

    &quot; Initialisation des Attributs de Génération
    me-&gt;template_task_attr_wizard_set( ).

    &quot; -----------------------------------------------------------
    &quot; Modification des attributs de génération du Template
    &quot; -----------------------------------------------------------

    &quot; Initialisation des Attributs de Configuration
    me-&gt;template_task_attr_config_set( ).

  ENDMETHOD.

  METHOD template_task_attr_wizard_set.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
    DATA :
      lv_attribute               TYPE string,
      lv_template_task_classname TYPE string.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Modification des attributs de génération du Template
    &quot; -----------------------------------------------------------

    FIND lcl_injector=&gt;mc_anchor_uname IN TABLE me-&gt;ms_source_code-t_template_task
                                     MATCH LINE DATA(lv_line).
    IF sy-subrc EQ 0.
      ASSIGN me-&gt;ms_source_code-t_template_task[ lv_line ] TO FIELD-SYMBOL(&lt;lfs_s_template_task&gt;).
      IF sy-subrc EQ 0.
        &quot; Modification Attribut
        lv_attribute = |{ sy-datum DATE = USER }|.
        REPLACE lcl_injector=&gt;mc_anchor_datum WITH lv_attribute INTO &lt;lfs_s_template_task&gt;.
        REPLACE lcl_injector=&gt;mc_anchor_uname WITH sy-uname INTO &lt;lfs_s_template_task&gt;.

      ENDIF.

    ENDIF.

    &quot; Modification Nom de la Classe
    CLEAR : me-&gt;mv_task_classname.
    IF me-&gt;ms_task_wizard_data-task_class_replace IS INITIAL.
      &quot; Pas de nom
      &quot;&quot;  --&gt; Utilisation nom générique
      me-&gt;mv_task_classname = lcl_injector=&gt;mc_template_classname.

    ELSEIF strlen( me-&gt;ms_task_wizard_data-task_class_replace ) GT 4
       AND |{ me-&gt;ms_task_wizard_data-task_class_replace(4) CASE = UPPER }|  EQ &apos;LCL_&apos;. &quot;#EC NOTEXT
      &quot; Indicatif classe locale renseignée
      &quot;&quot;  --&gt; Utilisation du nom
      me-&gt;mv_task_classname = me-&gt;ms_task_wizard_data-task_class_replace.

    ELSE.
      &quot; Nom inférieur à 4 caractère
      &quot;&quot;  --&gt; Ajout de l&apos;Indicatif classe locale
      me-&gt;mv_task_classname = |LCL_{ me-&gt;ms_task_wizard_data-task_class_replace }|. &quot;#EC NOTEXT

    ENDIF.
    IF  NOT me-&gt;mv_task_classname IS INITIAL
    AND me-&gt;mv_task_classname NE lcl_injector=&gt;mc_template_classname.
      &quot; Remplace le Nom générique par le nom fourni
      lv_template_task_classname = lcl_injector=&gt;mc_template_classname.
      REPLACE ALL OCCURRENCES OF lv_template_task_classname IN TABLE me-&gt;ms_source_code-t_template_task
                                                                WITH me-&gt;mv_task_classname.
      lv_template_task_classname = |{ lv_template_task_classname CASE = LOWER }|.
      REPLACE ALL OCCURRENCES OF lv_template_task_classname IN TABLE me-&gt;ms_source_code-t_template_task
                                                                WITH me-&gt;mv_task_classname.

    ENDIF.

  ENDMETHOD.

  METHOD template_task_attr_config_set.

***------------------------------------------------------------------***
**                              TYPES                                 **
***------------------------------------------------------------------***

    TYPES :
      BEGIN OF lts_template_task_config,
        anchor  TYPE string,
        value   TYPE string,
        default TYPE string,
        all     TYPE xsdboolean,
      END OF   lts_template_task_config.

    TYPES : ltt_template_task_config TYPE STANDARD TABLE OF lts_template_task_config
           WITH NON-UNIQUE KEY primary_key COMPONENTS anchor.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
    DATA :
          lt_configuration TYPE ltt_template_task_config.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
    DATA :
      lv_default_value  TYPE string,
      lv_default_anchor TYPE string.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Initialisation de la Configuration à appliquer
    &quot; -----------------------------------------------------------

    IF me-&gt;ms_task_wizard_data-target_selscreen_add EQ abap_true.
      &quot; Utilisation de l&apos;Ecran de Sélection
      &quot;&quot;  --&gt; Initialisation variables portant sur les élèments de l&apos;Ecran de Sélection
      lt_configuration = VALUE #(
        (
          anchor  = lcl_injector=&gt;mc_anchor_grfc
          value   = &apos;P_GRFC&apos;                                &quot;#EC NOTEXT
          default = me-&gt;ms_task_wizard_data-grfc
        )
        (
          anchor  = lcl_injector=&gt;mc_anchor_grfc_r
          value   = &apos;P_GRFC_R&apos;                              &quot;#EC NOTEXT
          default = me-&gt;ms_task_wizard_data-server_user
        )
        (
          anchor  = lcl_injector=&gt;mc_anchor_task_max
          value   = &apos;P_NTASK&apos;                               &quot;#EC NOTEXT
          default = me-&gt;ms_task_wizard_data-task_max
        )
        (
          anchor  = lcl_injector=&gt;mc_anchor_task_trace
          value   = &apos;P_TTRACE&apos;                              &quot;#EC NOTEXT
          all     = abap_true
          default = me-&gt;ms_task_wizard_data-trace_activ

        )
        (
          anchor  = lcl_injector=&gt;mc_anchor_compress_g
          value   = &apos;P_TCOMPG&apos;                              &quot;#EC NOTEXT
          default = me-&gt;ms_task_wizard_data-compress_mode-data_compress_global
        )
        (
          anchor  = lcl_injector=&gt;mc_anchor_compress_l
          value   = &apos;P_TCOMPL&apos;                              &quot;#EC NOTEXT
          default = me-&gt;ms_task_wizard_data-compress_mode-data_compress_line_by_line
        )
        (
          anchor  = lcl_injector=&gt;mc_anchor_shm_management
          value   = &apos;P_TSHM&apos;                                &quot;#EC NOTEXT
          default = me-&gt;ms_task_wizard_data-shm_management
        )
        (
          anchor  = lcl_injector=&gt;mc_anchor_compress_activ
          value   = &apos;P_TCOMP&apos;                               &quot;#EC NOTEXT
          default = me-&gt;ms_task_wizard_data-compress_activ
        )
        (
          anchor  = lcl_injector=&gt;mc_anchor_use_server_default
          value   = &apos;P_DGRFC&apos;                               &quot;#EC NOTEXT
          default = me-&gt;ms_task_wizard_data-server_default
        )
      ).

    ELSE.
      &quot; Pas d&apos;utilisation de l&apos;Ecran de Sélection
      &quot;&quot;  --&gt; Initialisation variables portant sur les choix de l&apos;utilisateur
      lt_configuration = VALUE #(
        (
          anchor = lcl_injector=&gt;mc_anchor_grfc
          value  = |&apos;{ me-&gt;ms_task_wizard_data-grfc }&apos;|     &quot;#EC NOTEXT
        )
        (
          anchor = lcl_injector=&gt;mc_anchor_task_max
          value  = |&apos;{ me-&gt;ms_task_wizard_data-task_max }&apos;| &quot;#EC NOTEXT
        )
        (
          anchor = lcl_injector=&gt;mc_anchor_task_trace
          value  = lcl_convert=&gt;boolean_convert_to_string( me-&gt;ms_task_wizard_data-trace_activ )
          all    = abap_true

        )
        (
          anchor = lcl_injector=&gt;mc_anchor_compress_l
          value  = lcl_convert=&gt;boolean_convert_to_string( me-&gt;ms_task_wizard_data-compress_mode-data_compress_line_by_line )
        )
        (
          anchor = lcl_injector=&gt;mc_anchor_compress_g
          value  = lcl_convert=&gt;boolean_convert_to_string( me-&gt;ms_task_wizard_data-compress_mode-data_compress_global )
        )
        (
          anchor = lcl_injector=&gt;mc_anchor_shm_management
          value  = lcl_convert=&gt;boolean_convert_to_string( me-&gt;ms_task_wizard_data-shm_management )
        )
        (
          anchor = lcl_injector=&gt;mc_anchor_compress_activ
          value  = lcl_convert=&gt;boolean_convert_to_string( me-&gt;ms_task_wizard_data-compress_activ )
        )
        (
          anchor = lcl_injector=&gt;mc_anchor_use_server_default
          value  = lcl_convert=&gt;boolean_convert_to_string( me-&gt;ms_task_wizard_data-server_default )
        )
      ).

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Application de la Configuration
    &quot; -----------------------------------------------------------

    LOOP AT lt_configuration ASSIGNING FIELD-SYMBOL(&lt;lfs_s_configuration&gt;).

      CLEAR : lv_default_anchor, lv_default_value.

      IF &lt;lfs_s_configuration&gt;-all EQ abap_true.
        &quot; Sur toutes les occurences
        REPLACE ALL OCCURRENCES OF &lt;lfs_s_configuration&gt;-anchor
                          IN TABLE me-&gt;ms_source_code-t_template_task
                              WITH &lt;lfs_s_configuration&gt;-value.

      ELSE.
        &quot; Sur une seule occurence
        REPLACE &lt;lfs_s_configuration&gt;-anchor IN TABLE me-&gt;ms_source_code-t_template_task
                                                 WITH &lt;lfs_s_configuration&gt;-value.

      ENDIF.

      IF me-&gt;ms_task_wizard_data-target_selscreen_add EQ abap_true.
        &quot; Ecran de Sélection ajouté
        &quot;&quot;  --&gt; Application de la valeur par défaut
        lv_default_anchor = |#{ &lt;lfs_s_configuration&gt;-value CASE = LOWER }_default#|. &quot;#EC NOTEXT
        IF NOT &lt;lfs_s_configuration&gt;-default IS INITIAL.
          lv_default_value = |DEFAULT &apos;{ &lt;lfs_s_configuration&gt;-default }&apos;|. &quot;#EC NOTEXT

        ENDIF.

        &quot;&quot;  --&gt; Remplace l&apos;Anchor par sa valeur
        REPLACE lv_default_anchor IN TABLE me-&gt;ms_source_code-t_template_selscreen
                                      WITH lv_default_value.

      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD template_handler_add.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
    DATA :
          lt_template TYPE stringtab.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
    DATA :
          ls_classname_list TYPE ts_classname_list.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
    DATA :
          lv_component TYPE string.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
    FIELD-SYMBOLS :
      &lt;lfs_process&gt;         TYPE clike,
      &lt;lfs_template_anchor&gt; TYPE ts_template_anchor_detail.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    IF  NOT is_task_call_process-class_name  IS INITIAL
    AND NOT is_task_call_process-method_name IS INITIAL.
      &quot; Traitement sur Méthode Statique
      &quot;&quot;  --&gt; Initialisation Nom composant correspondant
      lv_component = |me-&gt;ms_template_anchor-method-{ iv_event }-classname|. &quot;#EC NOTEXT

      &quot;&quot;  --&gt; Initialisation pointeur sur Nom de la Méthode
      ASSIGN is_task_call_process-method_name TO &lt;lfs_process&gt;.

    ELSEIF NOT is_task_call_process-function_name IS INITIAL.
      &quot; Traitement sur Module Fonction
      &quot;&quot;  --&gt; Initialisation pointeur sur AT_EOT - MF
      lv_component = |me-&gt;ms_template_anchor-function-{ iv_event }|. &quot;#EC NOTEXT

      &quot;&quot;  --&gt; Initialisation pointeur sur Nom du MF
      ASSIGN is_task_call_process-function_name TO &lt;lfs_process&gt;.

    ELSEIF NOT is_task_call_process-repid_name IS INITIAL.
      &quot; Traitement sur Programme
      &quot;&quot;  --&gt; Initialisation pointeur sur AT_EOT - Programme
      lv_component = |me-&gt;ms_template_anchor-repid-{ iv_event }|. &quot;#EC NOTEXT

      &quot;&quot;  --&gt; Initialisation pointeur sur Nom du Programme
      ASSIGN is_task_call_process-repid_name TO &lt;lfs_process&gt;.

    ELSE.
      &quot; Aucun appel
      RETURN.

    ENDIF.

    &quot; Initialisation pointeur données Template
    ASSIGN (lv_component) TO &lt;lfs_template_anchor&gt;.
    IF sy-subrc NE 0.
      &quot; Aucune correspondance
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

    IF &lt;lfs_template_anchor&gt;-header_set NE abap_true.
      &quot; -----------------------------------------------------------
      &quot; Ajout de l&apos;entête
      &quot; -----------------------------------------------------------

      &quot; Recherche position de l&apos;Anchor correspondant à l&apos;évènement
      FIND |#ANCHOR-{ iv_event }#| IN TABLE me-&gt;ms_source_code-t_template_task MATCH LINE DATA(lv_line). &quot;#EC NOTEXT
      IF sy-subrc NE 0.
        &quot; Aucune correspondance
        &quot;&quot;  --&gt; Arrêt du traitement
        RETURN.

      ENDIF.

      &quot; Ajout de l&apos;entête et fin à partir la position trouvée
      INSERT LINES OF &lt;lfs_template_anchor&gt;-end    INTO me-&gt;ms_source_code-t_template_task INDEX lv_line.
      INSERT LINES OF &lt;lfs_template_anchor&gt;-header INTO me-&gt;ms_source_code-t_template_task INDEX lv_line.

      &quot; Initialisation Indicateur entête généré
      &lt;lfs_template_anchor&gt;-header_set = abap_true.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Ajout du Corps
    &quot; -----------------------------------------------------------

    IF NOT is_task_call_process-class_name IS INITIAL.
      &quot; Ajout du Corps de la Classe
      &quot;&quot;  --&gt; Recherche si Classe a déjà été ajoutée
      READ TABLE me-&gt;mt_classname_list WITH TABLE KEY event     = iv_event
                                                      classname = is_task_call_process-class_name
                                         TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.
        &quot; Classe non ajoutée
        &quot;&quot;  --&gt; Recherche position de l&apos;Anchor
        FIND |//ANCHOR-{ iv_event }-CLASSLIST| IN TABLE me-&gt;ms_source_code-t_template_task MATCH LINE lv_line. &quot;#EC NOTEXT
        IF sy-subrc NE 0.
          &quot; Pas de correspondance
          &quot;&quot;  --&gt; Arrêt du traitement
          RETURN.

        ENDIF.

        &quot;&quot;  --&gt; Initialisation du Corps de la Classe
        lt_template[] = me-&gt;ms_template_anchor-method-at_eot-classname-body[].
        REPLACE ALL OCCURRENCES OF &apos;&lt;&amp;CLASSNAME&amp;&gt;&apos; IN TABLE lt_template WITH is_task_call_process-class_name. &quot;#EC NOTEXT

        &quot;&quot;  --&gt; Ajout dans le Template
        INSERT LINES OF me-&gt;ms_template_anchor-method-at_eot-methodname-end INTO me-&gt;ms_source_code-t_template_task INDEX lv_line.
        INSERT LINES OF lt_template INTO me-&gt;ms_source_code-t_template_task INDEX lv_line.

        &quot;&quot;  --&gt; Ajout dans de la classe dans la liste
        ls_classname_list-event     = iv_event.
        ls_classname_list-classname = is_task_call_process-class_name.
        INSERT ls_classname_list INTO TABLE me-&gt;mt_classname_list.

      ENDIF.

      &quot; Initialisation pointeur sur Template Méthode
      ASSIGN me-&gt;ms_template_anchor-method-at_eot-methodname TO &lt;lfs_template_anchor&gt;.

    ENDIF.

    IF NOT is_task_call_process-method_name IS INITIAL.
      &quot; Récupération position Anchor Liste des Méthodes de la Classe
      FIND |//ANCHOR-{ iv_event }-{ is_task_call_process-class_name }-METHODLIST| &quot;#EC NOTEXT
        IN TABLE me-&gt;ms_source_code-t_template_task MATCH LINE lv_line.

    ELSEIF NOT is_task_call_process-function_name IS INITIAL.
      &quot; Récupération position Anchor Liste des MFs
      FIND |//ANCHOR-{ iv_event }-FUNCTIONLIST|             &quot;#EC NOTEXT
        IN TABLE me-&gt;ms_source_code-t_template_task MATCH LINE lv_line.

    ELSEIF NOT is_task_call_process-repid_name IS INITIAL.
      &quot; Récupération position Anchor Liste des Programmes
      FIND |//ANCHOR-{ iv_event }-REPIDLIST|                &quot;#EC NOTEXT
        IN TABLE me-&gt;ms_source_code-t_template_task MATCH LINE lv_line.

    ELSE.
      &quot; Autre
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

    IF sy-subrc NE 0.
      &quot; Aucune correspondance
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

    &quot; Initialisation du Corps
    lt_template[] = &lt;lfs_template_anchor&gt;-body[].

    &quot; Modification de la Variable de Traitement
    REPLACE ALL OCCURRENCES OF &apos;&lt;&amp;PROCESS&amp;&gt;&apos; IN TABLE lt_template WITH &lt;lfs_process&gt;. &quot;#EC NOTEXT

    &quot; Ajout dans le Template
    INSERT LINES OF lt_template INTO me-&gt;ms_source_code-t_template_task INDEX lv_line.

  ENDMETHOD.

  METHOD include_task_create.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
    DATA :
          ls_program_trdir TYPE trdir.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
    DATA :
      lv_program_corrnum  TYPE e070-trkorr,
      lv_program_ordernum TYPE e070-trkorr.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Initialisation des données
    &quot; -----------------------------------------------------------

    &quot; Initialisation données
    ls_program_trdir-name    = iv_include_name.
    ls_program_trdir-varcl   = abap_true.
    ls_program_trdir-subc    = &apos;I&apos;.                         &quot;#EC NOTEXT
    ls_program_trdir-cnam    = ls_program_trdir-unam = sy-uname.
    ls_program_trdir-cdat    = ls_program_trdir-udat = sy-datum.
    ls_program_trdir-vern    = |{ &apos;1&apos; ALPHA = IN }|.        &quot;#EC NOTEXT
    ls_program_trdir-levl    = &apos;740&apos;.                       &quot;#EC NOTEXT
    ls_program_trdir-rmand   = sy-mandt.
    ls_program_trdir-rload   = sy-langu.
    ls_program_trdir-uccheck = abap_true.

    IF me-&gt;ms_transport_request-devclass IS INITIAL.
      &quot; -----------------------------------------------------------
      &quot; Détermination Package à utilisé
      &quot; -----------------------------------------------------------

      &quot; Récupération Package du Programme Cadre
      SELECT SINGLE devclass
               FROM tadir
              WHERE obj_name EQ @me-&gt;ms_task_wizard_data-target_repid
               INTO @me-&gt;ms_transport_request-devclass.

    ENDIF.

    IF me-&gt;ms_transport_request-devclass NE &apos;$TMP&apos;.         &quot;#EC NOTEXT
      &quot; -----------------------------------------------------------
      &quot; Détermination de l&apos;Ordre de Transport à utiliser
      &quot; -----------------------------------------------------------

      &quot; Récupération de l&apos;OT modifiable courant sur le Programme Cadre
      SELECT SINGLE task~trkorr, order~strkorr
               FROM e071           AS task
         INNER JOIN e070           AS order
                 ON order~trkorr   EQ task~trkorr
              WHERE task~obj_name  EQ @me-&gt;ms_task_wizard_data-target_repid
                AND order~trstatus EQ &apos;D&apos;                   &quot;#EC NOTEXT
               INTO (@me-&gt;ms_transport_request-corrnum, @me-&gt;ms_transport_request-ordernum).

      &quot; Ajout de l&apos;Include dans l&apos;OT
      me-&gt;transport_request_add( iv_include_name ).

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Création de l&apos;Include
    &quot; -----------------------------------------------------------

    &quot; Création de l&apos;Include
    DATA(ls_return) = lcl_source_code=&gt;repid_create(
        is_program_trdir    = ls_program_trdir
        iv_program_title    = iv_include_title
        iv_program_corrnum  = me-&gt;ms_transport_request-corrnum
        iv_program_ordernum = me-&gt;ms_transport_request-ordernum
        iv_program_devclass = me-&gt;ms_transport_request-devclass
        iv_mainprogram_name = me-&gt;ms_task_wizard_data-target_repid
    ).

    &quot; -----------------------------------------------------------
    &quot; Récupération du Code Source
    &quot; -----------------------------------------------------------

    &quot; Récupération du Code Source
    rt_source_code = lcl_source_code=&gt;source_code_get( iv_include_name ).

    &quot; Ajout Template Génération
    APPEND LINES OF me-&gt;ms_source_code-t_template_wizard_include_sign TO rt_source_code.

  ENDMETHOD.

  METHOD template_task_include_add.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Recherche si l&apos;Include est déjà déclaré
    &quot; -----------------------------------------------------------

    &quot; Recherche présence de l&apos;Include dans le Programme Cadre
    FIND REGEX |(^\\s*INCLUDE[: \\s]*{ iv_include })| IN TABLE me-&gt;ms_source_code-t_target_repid. &quot;#EC NOTEXT
    IF sy-subrc EQ 0.
      &quot; Include déjà présent dans le Programme Cadre
      &quot;&quot;  --&gt; arrêt du traitement
      RETURN.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Ajout de l&apos;Include dans Programme Cadre
    &quot; -----------------------------------------------------------

    &quot; Ajout de l&apos;Include dans le Programme Cadre
    APPEND |INCLUDE { iv_include }. &quot;{ &apos;Ajouté par l&apos;&apos;Assistant&apos;(i01) } | TO me-&gt;ms_source_code-t_target_repid. &quot;#EC NOTEXT

  ENDMETHOD.

  METHOD template_selscreen_add.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
    DATA :
          lv_line_inject TYPE i.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Recherche présence de l&apos;écran de sélection existant
    &quot; -----------------------------------------------------------

    &quot; ToDo : Rechercher emplacement Ecran de Sélection
    &quot; ToDo : Si non trouvée rechercher dans les Includes Z* du Prg. /!\

*    &quot; Recherche présence de Block
*    FIND &apos;SELECTION-SCREEN BEGIN OF BLOCK&apos; IN TABLE ct_source_code &quot;#EC NOTEXT
*                                            RESULTS DATA(lt_results).
*    IF sy-subrc NE 0.
*      &quot; Pas de Block trouvé
*      &quot;&quot;  --&gt; Recherche présence d&apos;Onglet
*      FIND &apos;SELECTION-SCREEN BEGIN OF TABBED BLOCK&apos; IN TABLE ct_source_code &quot;#EC NOTEXT
*                                                     RESULTS lt_results.
*
*    ENDIF.
*    IF sy-subrc NE 0.
*      &quot; Pas d&apos;Onglet trouvé
*      &quot;&quot;  --&gt; Recherche présence de Ligne
*      FIND &apos;SELECTION-SCREEN BEGIN OF LINE&apos; IN TABLE ct_source_code &quot;#EC NOTEXT
*                                             RESULTS lt_results.
*
*    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Ajout du Template de l&apos;Ecran de Sélection
    &quot; -----------------------------------------------------------

    &quot; Ajout de l&apos;Ecran de Sélection
    IF lv_line_inject IS INITIAL.
      &quot; Pas de ligne précise déterminée
      &quot;&quot;  --&gt; Ajout à la fin
      APPEND LINES OF me-&gt;ms_source_code-t_template_selscreen TO ct_source_code.

    ELSE.
      &quot; Ligne d&apos;Ajout défini
      &quot;&quot;  --&gt; Insertion à l&apos;Emplacement trouvé
      INSERT LINES OF me-&gt;ms_source_code-t_template_selscreen INTO ct_source_code INDEX lv_line_inject.

    ENDIF.

  ENDMETHOD.

  METHOD template_task_add.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
    DATA :
          lv_line_inject TYPE i.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Contrôle présence autre instance généré
    &quot; -----------------------------------------------------------

    &quot; ToDo : Contrôler présence précédente génération de Tâche

    &quot; -----------------------------------------------------------
    &quot; Détermination de l&apos;Emplacement d&apos;Injection
    &quot; -----------------------------------------------------------

    &quot; ToDo : Se positionner au bon endroit

    &quot; -----------------------------------------------------------
    &quot; Ajout du Template du Cadriciel
    &quot; -----------------------------------------------------------

    &quot; Ajout du Cadriciel
    IF lv_line_inject IS INITIAL.
      &quot; Pas de ligne précise déterminée
      &quot;&quot;  --&gt; Ajout à la fin
      APPEND LINES OF me-&gt;ms_source_code-t_template_task TO ct_source_code.

    ELSE.
      &quot; Ligne d&apos;Ajout définie
      &quot;&quot;  --&gt; Insertion à l&apos;Emplacement trouvé
      INSERT LINES OF me-&gt;ms_source_code-t_template_task INTO ct_source_code INDEX lv_line_inject.

    ENDIF.

  ENDMETHOD.

  METHOD template_selscreen_output_add.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Ajout modification Ecran via Evènement AT-SELECTION-SCREEN-OUTPUT
    &quot; -----------------------------------------------------------

    &quot; Recherche position de l&apos;évènement
    FIND &apos;AT SELECTION-SCREEN OUTPUT&apos; IN TABLE ct_source_code &quot;#EC NOTEXT
                                    MATCH LINE DATA(lv_line).
    IF sy-subrc NE 0.
      &quot; Aucune correspondance
      &quot;&quot;  --&gt; Ajout à la fin
      APPEND &apos;AT SELECTION-SCREEN OUTPUT.&apos; TO ct_source_code. &quot;#EC NOTEXT
      lv_line = sy-tabix.

    ENDIF.

    &quot; Ajout de l&apos;Appel de la Méthode
    INSERT LINES OF VALUE stringtab(
      ( |&quot; Modification affichage paramètre de parallélisation | ) &quot;#EC NOTEXT
      ( CONV string( |{ me-&gt;mv_task_classname }=&gt;AT_SELECTION_SCREEN_OUTPUT( ).| )  ) &quot;#EC NOTEXT
      ( )
    ) INTO ct_source_code INDEX lv_line + 1.

  ENDMETHOD.

  METHOD template_apply.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
    DATA :
      lo_source_code_selscreen TYPE REF TO stringtab,
      lo_source_code_framework TYPE REF TO stringtab.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    IF  me-&gt;ms_task_wizard_data-target_selscreen_add EQ abap_true
    AND me-&gt;ms_task_wizard_data-target_selscreen_incl_use EQ abap_true.
      &quot; Ajout Ecran de Sélection dans un Include
      &quot;&quot;  --&gt; Initialisation Référence sur l&apos;Include
      lo_source_code_selscreen = REF #( me-&gt;ms_source_code-t_target_incl_selscreen ).

    ELSE.
      &quot; Ajout Ecran de Sélection dans le Programme Cadre
      &quot;&quot;  --&gt; Initialisation Référence sur le Programme Cadre
      lo_source_code_selscreen = REF #( me-&gt;ms_source_code-t_target_repid ).

    ENDIF.

    IF me-&gt;ms_task_wizard_data-target_framework_incl_use EQ abap_true.
      &quot; Ajout Ecran de Sélection dans un Include
      &quot;&quot;  --&gt; Initialisation Référence sur l&apos;Include
      lo_source_code_framework = REF #( me-&gt;ms_source_code-t_target_incl_framework ).

    ELSE.
      &quot; Ajout Ecran de Sélection dans le Programme Cadre
      &quot;&quot;  --&gt; Initialisation Référence sur le Programme Cadre
      lo_source_code_framework = REF #( me-&gt;ms_source_code-t_target_repid ).

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Sélection des données
    &quot; -----------------------------------------------------------

    IF me-&gt;ms_task_wizard_data-target_selscreen_add EQ abap_true.
      &quot; -----------------------------------------------------------
      &quot; Ecran de Sélection
      &quot; -----------------------------------------------------------

      &quot; Ajout de l&apos;Ecran de Sélection
      me-&gt;template_selscreen_add( CHANGING ct_source_code = lo_source_code_selscreen-&gt;* ).

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Cadriciel
    &quot; -----------------------------------------------------------

    &quot; Ajout du Template de Tâche
    me-&gt;template_task_add( CHANGING ct_source_code = lo_source_code_framework-&gt;* ).

    IF me-&gt;ms_task_wizard_data-target_selscreen_add EQ abap_true.
      &quot; -----------------------------------------------------------
      &quot; Evènement Modification Ecran de Sélection
      &quot; -----------------------------------------------------------

      &quot; Ajout du Template Modification Ecran de Sélection
      me-&gt;template_selscreen_output_add( CHANGING ct_source_code = me-&gt;ms_source_code-t_target_repid ).

    ENDIF.

  ENDMETHOD.

  METHOD template_task_inject.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
    DATA:
      lv_answer       TYPE c LENGTH 1,
      lv_include_used TYPE xsdboolean.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Ajout du Template
    &quot; -----------------------------------------------------------

    &quot; Application du Template
    me-&gt;template_apply( ).

    &quot; -----------------------------------------------------------
    &quot; Contrôle Code Source
    &quot; -----------------------------------------------------------

    &quot; Contrôle Code Source
    DATA(ls_check) = me-&gt;template_source_code_check( IMPORTING ev_include_used = lv_include_used ).
    IF  lv_include_used    EQ abap_false
    AND NOT ls_check-subrc IS INITIAL.
      &quot; Erreur syntaxique &amp; Pas d&apos;utilisation d&apos;Include
      &quot;&quot;  --&gt; Propose l&apos;Ajout malgré l&apos;erreur
      CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
        EXPORTING
          text_question         = &apos;Erreur syntaxe présente. Appliquer le Template ?&apos;(q01) &quot;#EC NOTEXT
          text_button_1         = &apos;Oui&apos;(r01)                &quot;#EC NOTEXT
          text_button_2         = &apos;Non&apos;(r02)                &quot;#EC NOTEXT
          display_cancel_button = abap_false
        IMPORTING
          answer                = lv_answer
        EXCEPTIONS
          text_not_found        = 1
          OTHERS                = 2.
      IF sy-subrc NE 0.
        &quot; Erreur
        &quot;&quot; --&gt; Réinitialisation réponse utilisateur
        CLEAR : lv_answer.

      ENDIF.

      &quot; Suivant la réponse utilisateur
      CASE lv_answer.

        WHEN 1.
          &quot; L&apos;utilisateur souhaite poursuivre malgré l&apos;erreur syntaxique

        WHEN OTHERS.
          &quot; L&apos;utilisateur n&apos;a pas validé l&apos;injection
          &quot;&quot;  --&gt; Arrêt du traitement
          RETURN.

      ENDCASE.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Injection du Code Source
    &quot; -----------------------------------------------------------

    &quot; Injection du Code Source
    me-&gt;template_source_code_inject( ).

  ENDMETHOD.

  METHOD template_source_code_check.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    CLEAR : ev_include_used.

    &quot; -----------------------------------------------------------
    &quot; Sélection des données
    &quot; -----------------------------------------------------------

    &quot; Contrôle Code Source Programme Cadre
    DATA(ls_check) = lcl_source_code=&gt;source_code_check(
      iv_repid       = me-&gt;mv_repid_target
      it_source_code = me-&gt;ms_source_code-t_target_repid
    ).
    IF NOT ls_check IS INITIAL.
      &quot; Une erreur de syntaxe est présente
      &quot;&quot;  --&gt; Initialisation de l&apos;erreur en retour
      rs_check = ls_check.

    ENDIF.

    IF  me-&gt;ms_task_wizard_data-target_selscreen_add      EQ abap_true
    AND me-&gt;ms_task_wizard_data-target_selscreen_incl_use EQ abap_true.
      &quot; Ajout de l&apos;Ecran de Sélection dans un Include à part
      &quot;&quot;  --&gt; Contrôle Code Source Include Ecran de Sélection
      ls_check = lcl_source_code=&gt;source_code_check(
        iv_repid       = me-&gt;mv_repid_target
        iv_include     = me-&gt;ms_task_wizard_data-target_selscreen_incl_data-include_name
        it_source_code = me-&gt;ms_source_code-t_target_incl_selscreen
      ).
      IF NOT ls_check IS INITIAL.
        &quot; Une erreur de syntaxe est présente
        &quot;&quot;  --&gt; Initialisation de l&apos;erreur en retour
        rs_check = ls_check.

      ENDIF.

      &quot;&quot;  --&gt; Initialisation Indicateur utilisation Include
      ev_include_used = abap_true.

    ENDIF.

    IF me-&gt;ms_task_wizard_data-target_framework_incl_use EQ abap_true.
      &quot; Ajout du Cadriciel dans un Include
      &quot;&quot;  --&gt; Contrôle Code Source Include Ecran de Sélection
      ls_check = lcl_source_code=&gt;source_code_check(
        iv_repid       = me-&gt;mv_repid_target
        iv_include     = me-&gt;ms_task_wizard_data-target_selscreen_incl_data-include_name
        it_source_code = me-&gt;ms_source_code-t_target_incl_framework
      ).
      IF NOT ls_check IS INITIAL.
        &quot; Une erreur de syntaxe est présente
        &quot;&quot;  --&gt; Initialisation de l&apos;erreur en retour
        rs_check = ls_check.

      ENDIF.

      &quot;&quot;  --&gt; Initialisation Indicateur utilisation Include
      ev_include_used = abap_true.

    ENDIF.

  ENDMETHOD.

  METHOD template_source_code_inject.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Modification du Programme Cadre
    &quot; -----------------------------------------------------------

    &quot; Modification du Code Source du programme Cadre
    me-&gt;ms_source_code-t_target_repid = lcl_source_code=&gt;source_code_set(
      iv_repid         = me-&gt;mv_repid_target
      it_source_code   = me-&gt;ms_source_code-t_target_repid
    ).

    IF  me-&gt;ms_task_wizard_data-target_selscreen_add      EQ abap_true
    AND me-&gt;ms_task_wizard_data-target_selscreen_incl_use EQ abap_true.
      &quot; Modification du Code Source de l&apos;Include Ecran de Sélection
      lcl_source_code=&gt;source_code_set(
        iv_repid       = me-&gt;ms_task_wizard_data-target_selscreen_incl_data-include_name
        it_source_code = me-&gt;ms_source_code-t_target_incl_selscreen
      ).

    ENDIF.

    IF me-&gt;ms_task_wizard_data-target_framework_incl_use EQ abap_true.
      &quot; Modification du Code Source de l&apos;Include Cadriciel
      lcl_source_code=&gt;source_code_set(
        iv_repid       = me-&gt;ms_task_wizard_data-target_framework_incl_data-include_name
        it_source_code = me-&gt;ms_source_code-t_target_incl_framework
      ).

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Rafraichissement de l&apos;Editeur
    &quot; -----------------------------------------------------------

    DATA : lo_abap_pgeditor TYPE REF TO cl_wb_pgeditor.
    ASSIGN (&apos;(SAPLS38E)ABAP_PGEDITOR&apos;) TO FIELD-SYMBOL(&lt;lfs_instance&gt;).
    IF sy-subrc EQ 0.
      &quot; Instance de Programme transmise
      &quot;&quot;  --&gt; Move-Cast
      lo_abap_pgeditor ?= &lt;lfs_instance&gt;.

      IF lo_abap_pgeditor-&gt;source_id EQ me-&gt;mv_repid_target.
        &quot;&quot;  --&gt; Modification de l&apos;Affichage
        lo_abap_pgeditor-&gt;source_instance-&gt;set_source_tab( me-&gt;ms_source_code-t_target_repid ).
        lo_abap_pgeditor-&gt;source_instance-&gt;set_lineindex( mode_changed = abap_true ).
        lo_abap_pgeditor-&gt;source_instance-&gt;set_linenumbers( ).
        lo_abap_pgeditor-&gt;abap_editor-&gt;visualize_source( ).

      ENDIF.

    ENDIF.

  ENDMETHOD.

  METHOD transport_request_add.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Sélection de l&apos;OT
    &quot; -----------------------------------------------------------

    &quot; Ajout du Programme dans l&apos;OT
    CALL FUNCTION &apos;RS_CORR_INSERT&apos;
      EXPORTING
        object              = iv_repid
        object_class        = &apos;REPS&apos;  &quot;#EC NOTEXT
        mode                = space
        global_lock         = space
        devclass            = me-&gt;ms_transport_request-devclass
        extend              = space
        activation_call     = abap_true
        suppress_dialog     = space
      IMPORTING
        korrnum             = me-&gt;ms_transport_request-corrnum
        ordernum            = me-&gt;ms_transport_request-ordernum
        transport_key       = me-&gt;ms_transport_request-transport_key
      EXCEPTIONS
        cancelled           = 1
        permission_failure  = 2
        unknown_objectclass = 3
        OTHERS              = 4.
    IF sy-subrc NE 0.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Retourne Code d&apos;erreur
      rv_subrc = sy-subrc.

    ENDIF.

  ENDMETHOD.

ENDCLASS.</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <textPool>
   <language SPRAS="F">
    <textElement ID="I" KEY="I01" ENTRY="Ajouté par l&apos;Assistant" LENGTH="44 "/>
    <textElement ID="I" KEY="Q01" ENTRY="Erreur syntaxe présente. Appliquer le Template ?" LENGTH="96 "/>
    <textElement ID="I" KEY="R01" ENTRY="Oui" LENGTH="13 "/>
    <textElement ID="I" KEY="R02" ENTRY="Non" LENGTH="3 "/>
   </language>
  </textPool>
  <interfaceMethod CLSNAME="ZCL_TASK_WIZARD" CPDNAME="IF_WB_PROGRAM~GET_CURRENT_WB_OBJECT_STATE">
   <source>METHOD if_wb_program~get_current_wb_object_state.&quot;#EC NEEDED
 ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TASK_WIZARD" CPDNAME="IF_WB_PROGRAM~GET_ENQUEUE_OBJECT">
   <source>METHOD if_wb_program~get_enqueue_object.&quot;#EC NEEDED
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TASK_WIZARD" CPDNAME="IF_WB_PROGRAM~GET_REQUEST_FROM_TOOL_ACCESS">
   <source>METHOD if_wb_program~get_request_from_tool_access.  &quot;#EC NEEDED
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TASK_WIZARD" CPDNAME="IF_WB_PROGRAM~GET_RESTORE_WB_PROGRAM_STATE">
   <source>METHOD if_wb_program~get_restore_wb_program_state.&quot;#EC NEEDED
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TASK_WIZARD" CPDNAME="IF_WB_PROGRAM~GET_RESTORE_WB_REQUEST">
   <source>METHOD if_wb_program~get_restore_wb_request.&quot;#EC NEEDED
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TASK_WIZARD" CPDNAME="IF_WB_PROGRAM~PREPARE_FOR_REINVOCATION">
   <source>METHOD if_wb_program~prepare_for_reinvocation.&quot;#EC NEEDED
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TASK_WIZARD" CPDNAME="IF_WB_PROGRAM~PREPARE_FOR_TERMINATION">
   <source>METHOD if_wb_program~prepare_for_termination.&quot;#EC NEEDED
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TASK_WIZARD" CPDNAME="IF_WB_PROGRAM~PROCESS_WB_REQUEST">
   <source>METHOD if_wb_program~process_wb_request.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : IF_WB_PROGRAM~PROCESS_WB_REQUEST                  *
*&amp; Classe          : ZCL_TASK_WIZARD                                   *
*&amp; Description     : Traitement évènement Menu Contextuel              *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Gestion Action Utilisateur
  &quot; -----------------------------------------------------------

  &quot; Suivant le Code Fonction
  CASE p_wb_request-&gt;operation.

    WHEN zcl_im_wb_obj_ctmenu=&gt;mc_fc_task_wz.
      &quot;Tâche - Assistant Cadriciel
      me-&gt;task_wizard(
        EXPORTING
          io_wb_request           = p_wb_request
          io_wb_program_state     = p_wb_program_state
          iv_window_id            = p_window_id
        CHANGING
          co_wb_data_container    = p_wb_data_container
        EXCEPTIONS
          operation_not_supported = 1
          wrong_program_state     = 2
          action_cancelled        = 3
          error_occured           = 4
          object_not_found        = 5
          permission_failure      = 6
          OTHERS                  = 7
      ).

    WHEN OTHERS.
      &quot; Autres
      &quot;&quot;  --&gt; Non géré
      RETURN.

  ENDCASE.

  &quot; -----------------------------------------------------------
  &quot; Suivant le Code Retour
  &quot; -----------------------------------------------------------

  CASE sy-subrc.

    WHEN 0.
      &quot; Traitement correctement effectuée

    WHEN 3.
      &quot; Annulé par l&apos;utilisateur
      &quot;&quot;  --&gt; Affiche message
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                          WITH sy-msgv1 sy-msgv2
                               sy-msgv3 sy-msgv4
                       RAISING action_cancelled.

    WHEN OTHERS.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Affichage message d&apos;erreur
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                          WITH sy-msgv1 sy-msgv2
                               sy-msgv3 sy-msgv4
                       RAISING error_occured.

  ENDCASE.

ENDMETHOD.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_TASK_WIZARD" CMPNAME="TASK_TEMPLATE_INJECT" VERSION="1" LANGU="F" DESCRIPT="Tâche - Template - Injection dans le Programme Cadre" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_WIZARD" CMPNAME="TASK_TEMPLATE_INJECT" SCONAME="IS_TASK_WIZARD_DATA" VERSION="1" LANGU="F" DESCRIPT="Tâche - Données Assistant" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_WIZARD_DATA"/>
   <exception CLSNAME="ZCL_TASK_WIZARD" CMPNAME="TASK_TEMPLATE_INJECT" SCONAME="ZCX_TASK_WIZARD" VERSION="1" LANGU="F" DESCRIPT="Exceptions with Dynamic Check Only of the RAISING Clause" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD task_template_inject.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_TEMPLATE_INJECT                              *
*&amp; Classe          : ZCL_TASK_WIZARD                                   *
*&amp; Description     : Application du Template dans le Prg. Cadre        *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Injection du Template dans le Programme Cadre
      &quot; -----------------------------------------------------------

      &quot; Création de l&apos;Instance
      DATA(lo_task_injector) = NEW lcl_injector( is_task_wizard_data ).

      &quot; Injection du Template avec les paramètres défini par l&apos;utilisateur
      lo_task_injector-&gt;main( ).

    CATCH lcx_injector INTO DATA(lo_cx_exception).
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Lève l&apos;Exception
      RAISE EXCEPTION TYPE zcx_task_wizard
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_WIZARD" CMPNAME="TASK_WIZARD" VERSION="1" LANGU="F" DESCRIPT="Tâche - Assistant" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_WIZARD" CMPNAME="TASK_WIZARD" SCONAME="IO_WB_REQUEST" VERSION="1" LANGU="F" DESCRIPT="Workbench Manager: Request" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_WB_REQUEST"/>
   <parameter CLSNAME="ZCL_TASK_WIZARD" CMPNAME="TASK_WIZARD" SCONAME="IO_WB_PROGRAM_STATE" VERSION="1" LANGU="F" DESCRIPT="Workbench Manager: State of a Tool or Browser" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="IF_WB_PROGRAM_STATE"/>
   <parameter CLSNAME="ZCL_TASK_WIZARD" CMPNAME="TASK_WIZARD" SCONAME="IV_WINDOW_ID" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_TASK_WIZARD" CMPNAME="TASK_WIZARD" SCONAME="CO_WB_DATA_CONTAINER" VERSION="1" LANGU="F" DESCRIPT="Data Container for Passing Values" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_WB_DATA_CONTAINER" PAROPTIONL="X"/>
   <exception CLSNAME="ZCL_TASK_WIZARD" CMPNAME="TASK_WIZARD" SCONAME="OPERATION_NOT_SUPPORTED" VERSION="1" LANGU="F" DESCRIPT="Tool Does Not Support Operation" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TASK_WIZARD" CMPNAME="TASK_WIZARD" SCONAME="WRONG_PROGRAM_STATE" VERSION="1" LANGU="F" DESCRIPT="Program state does not match tool" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_TASK_WIZARD" CMPNAME="TASK_WIZARD" SCONAME="ACTION_CANCELLED" VERSION="1" LANGU="F" DESCRIPT="Activity Terminated" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_TASK_WIZARD" CMPNAME="TASK_WIZARD" SCONAME="ERROR_OCCURED" VERSION="1" LANGU="F" DESCRIPT="Error occurred while processing request" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_TASK_WIZARD" CMPNAME="TASK_WIZARD" SCONAME="OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Object Not Found" MTDTYPE="0" EDITORDER="5 "/>
   <exception CLSNAME="ZCL_TASK_WIZARD" CMPNAME="TASK_WIZARD" SCONAME="PERMISSION_FAILURE" VERSION="1" LANGU="F" DESCRIPT="Missing authorization" MTDTYPE="0" EDITORDER="6 "/>
   <source>METHOD task_wizard.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_WIZARD                                       *
*&amp; Classe          : ZCL_TASK_WIZARD                                   *
*&amp; Description     : Lancement Assistant Cadriciel                     *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
        ls_task_wizard_data TYPE ztec_s_task_wizard_data.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_cx_exception TYPE REF TO cx_root.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***


  &quot; -----------------------------------------------------------
  &quot; Lancement de l&apos;Assistant
  &quot; -----------------------------------------------------------

  &quot; Lancement de l&apos;Assistant de configuration
  CALL FUNCTION &apos;WZ_ZTASK_WIZARD_START&apos;
    EXPORTING
      iv_repid_default    = CONV repid( io_wb_request-&gt;object_name )
    IMPORTING
      es_task_wizard_data = ls_task_wizard_data
    EXCEPTIONS
      cancelled_by_user   = 1
      error               = 2
      OTHERS              = 3.

  &quot; -----------------------------------------------------------
  &quot; Gestion code retour
  &quot; -----------------------------------------------------------

  &quot; Suivant le code retour
  CASE sy-subrc.

    WHEN 0.
      &quot; Aucune erreur
      TRY.
          &quot;&quot;  --&gt; Applique le Template du cadriciel au Programme Cadre
          me-&gt;task_template_inject( ls_task_wizard_data ).

        CATCH zcx_task_wizard INTO lo_cx_exception.
          &quot; Une erreur est survenue
          &quot;&quot;  --&gt; Affiche l&apos;Exception
          WHILE lo_cx_exception-&gt;previous IS BOUND.
            lo_cx_exception ?= lo_cx_exception-&gt;previous.
          ENDWHILE.
          DATA(lv_message) = lo_cx_exception-&gt;get_text( ).
          MESSAGE ID &apos;00&apos; TYPE &apos;E&apos; NUMBER 368 &quot;#EC NOTEXT
                          WITH lv_message
                       RAISING error_occured.

      ENDTRY.

    WHEN 1.
      &quot; Annulé par l&apos;utilisateur
      &quot;&quot;  --&gt; Affiche message
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                          WITH sy-msgv1 sy-msgv2
                               sy-msgv3 sy-msgv4
                       RAISING action_cancelled.

    WHEN OTHERS.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Affichage message d&apos;erreur
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                          WITH sy-msgv1 sy-msgv2
                               sy-msgv3 sy-msgv4
                       RAISING error_occured.

  ENDCASE.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK" VERSION="1" LANGU="F" DESCRIPT="Tâche - Instance" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZTASK" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_TASK" CMPNAME="TS_SEOSUBCODF" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="11 " SRCCOLUMN2="25 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_seosubcodf.
          INCLUDE TYPE seoscokey.
  TYPES :
    pardecltyp TYPE seosubcodf-pardecltyp,
    typtype    TYPE seosubcodf-typtype,
    type       TYPE seosubcodf-type,
    scotype    TYPE seosubco-scotype,
    END OF   ts_seosubcodf
"/>
  <types CLSNAME="ZCL_TASK" CMPNAME="TT_SEOSUBCODF" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="4 " SRCROW2="14 " SRCCOLUMN2="71 " TYPESRC_LENG="0 " TYPESRC="tt_seosubcodf TYPE SORTED TABLE OF ts_seosubcodf
          WITH UNIQUE KEY primary_key COMPONENTS clsname cmpname sconame
"/>
  <types CLSNAME="ZCL_TASK" CMPNAME="TS_SEOCOMPODF" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="16 " SRCCOLUMN1="4 " SRCROW2="21 " SRCCOLUMN2="25 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_seocompodf,
      clsname   TYPE seocompodf-clsname,
      cmpname   TYPE seocompodf-cmpname,
      mtdnewexc TYPE seocompodf-mtdnewexc,
      not_found TYPE xsdboolean,
    END OF   ts_seocompodf
"/>
  <types CLSNAME="ZCL_TASK" CMPNAME="TT_SEOCOMPODF" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="23 " SRCCOLUMN1="4 " SRCROW2="24 " SRCCOLUMN2="63 " TYPESRC_LENG="0 " TYPESRC="tt_seocompodf TYPE SORTED TABLE OF ts_seocompodf
          WITH UNIQUE KEY primary_key COMPONENTS clsname cmpname
"/>
  <types CLSNAME="ZCL_TASK" CMPNAME="TS_FUPARAREF" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="5 " TYPTYPE="4" SRCROW1="26 " SRCCOLUMN1="4 " SRCROW2="31 " SRCCOLUMN2="24 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_fupararef,
      funcname  TYPE fupararef-funcname,
      parameter TYPE fupararef-parameter,
      paramtype TYPE fupararef-paramtype,
      structure TYPE fupararef-structure,
    END OF   ts_fupararef
"/>
  <types CLSNAME="ZCL_TASK" CMPNAME="TT_FUPARAREF" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="6 " TYPTYPE="4" SRCROW1="33 " SRCCOLUMN1="4 " SRCROW2="34 " SRCCOLUMN2="80 " TYPESRC_LENG="0 " TYPESRC="tt_fupararef TYPE SORTED TABLE OF ts_fupararef
                        WITH UNIQUE KEY primary_key COMPONENTS funcname parameter
"/>
  <types CLSNAME="ZCL_TASK" CMPNAME="TT_RSEL_INFO" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="7 " TYPTYPE="4" SRCROW1="35 " SRCCOLUMN1="10 " SRCROW2="35 " SRCCOLUMN2="102 " TYPESRC_LENG="0 " TYPESRC="tt_rsel_info TYPE STANDARD TABLE OF rsel_info WITh NON-UNIQUE KEY PRIMARY_KEY COMPONENTS name
"/>
  <types CLSNAME="ZCL_TASK" CMPNAME="TS_REPID_SELECTION_SCREEN" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="8 " TYPTYPE="4" SRCROW1="37 " SRCCOLUMN1="4 " SRCROW2="42 " SRCCOLUMN2="37 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_repid_selection_screen,
      repid        TYPE sy-repid,
      t_field_info TYPE zcl_task=&gt;tt_rsel_info,
      t_def_values TYPE pivb_rsparamsl_255_t,
      no_data      TYPE xsdboolean,
    END OF   ts_repid_selection_screen
"/>
  <types CLSNAME="ZCL_TASK" CMPNAME="TT_REPID_SELECTION_SCREEN" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="9 " TYPTYPE="4" SRCROW1="44 " SRCCOLUMN1="4 " SRCROW2="45 " SRCCOLUMN2="53 " TYPESRC_LENG="0 " TYPESRC="tt_repid_selection_screen TYPE SORTED TABLE OF ts_repid_selection_screen
          WITH UNIQUE KEY primary_key COMPONENTS repid
"/>
  <types CLSNAME="ZCL_TASK" CMPNAME="TS_PERSISTENT_DATA" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="10 " TYPTYPE="4" SRCROW1="47 " SRCCOLUMN1="4 " SRCROW2="53 " SRCCOLUMN2="30 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_persistent_data,
      t_fupararef              TYPE zcl_task=&gt;tt_fupararef,
      t_seocompodf             TYPE zcl_task=&gt;tt_seocompodf,
      t_seosubcodf             TYPE zcl_task=&gt;tt_seosubcodf,
      t_repid_selection_screen TYPE zcl_task=&gt;tt_repid_selection_screen,
      t_generic_type_list      TYPE sana_type_list,
    END OF   ts_persistent_data
"/>
  <types CLSNAME="ZCL_TASK" CMPNAME="TS_TASK_PROCESS" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="11 " SRCCOLUMN1="4 " SRCROW2="15 " SRCCOLUMN2="29 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_task_process,
        task_call_process        TYPE        ztec_s_task_call_process,
        task_container           TYPE REF TO zcl_task_container,
        t_definition_type_in_shm TYPE        stringtab,
      END OF   ts_task_process
"/>
  <types CLSNAME="ZCL_TASK" CMPNAME="TS_TASK" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="17 " SRCCOLUMN1="4 " SRCROW2="29 " SRCCOLUMN2="21 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_task,
        task_id               TYPE ztask_id,
        task_manager_id       TYPE ztask_manager_id,
        task_trace_id         TYPE ztask_trace_id,
        shm_manage_by_manager TYPE xsdboolean,
        shm_manage_by_local   TYPE xsdboolean,
        data_compress_param   TYPE ztec_s_task_compress_param,
        task_running          TYPE xsdboolean,
        task_grfc             TYPE rfcgr,
        task_dedicated        TYPE xsdboolean,
        task_process          TYPE zcl_task=&gt;ts_task_process,
        use_default_group     TYPE xsdboolean,
      END OF   ts_task
"/>
  <friends CLSNAME="ZCL_TASK" REFCLSNAME="ZCL_TASK_MANAGER" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <events CLSNAME="ZCL_TASK" CMPNAME="TASK_END" VERSION="1" LANGU="F" DESCRIPT="Evènement Fin de la Tâche" EXPOSURE="0" STATE="1" EDITORDER="1 " EVTDECLTYP="0" BCEVTCAT="00">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="TASK_END" SCONAME="IO_TASK" VERSION="1" LANGU="F" CMPTYPE="2" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK"/>
  </events>
  <events CLSNAME="ZCL_TASK" CMPNAME="TASK_BEFORE" VERSION="1" LANGU="F" DESCRIPT="Evènement Début d&apos;une Tâche" EXPOSURE="0" STATE="1" EDITORDER="2 " EVTDECLTYP="0" BCEVTCAT="00">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="TASK_BEFORE" SCONAME="IO_TASK" VERSION="1" LANGU="F" DESCRIPT="Instance Tâche" CMPTYPE="2" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK"/>
  </events>
  <events CLSNAME="ZCL_TASK" CMPNAME="TASK_ERROR_RECEIVE_RESULT" VERSION="1" LANGU="F" DESCRIPT="Evènement erreur réception résultalt Tâche" EXPOSURE="0" STATE="1" EDITORDER="3 " EVTDECLTYP="0" BCEVTCAT="00">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="TASK_ERROR_RECEIVE_RESULT" SCONAME="IO_TASK" VERSION="1" LANGU="F" DESCRIPT="Instance Tâche" CMPTYPE="2" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="TASK_ERROR_RECEIVE_RESULT" SCONAME="IS_TEXTID" VERSION="1" LANGU="F" DESCRIPT="Clé T100 avec mappage des paramètres pour attributs de nom" CMPTYPE="2" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="SCX_T100KEY" PAROPTIONL="X"/>
  </events>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_TASK" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_TASK" TYPEGROUP="SANA" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <forwardDeclaration>SANA</forwardDeclaration>
  <typeClasDef CLSNAME="ZCL_TASK" TYPEGROUP="ZCL_TASK" VERSION="1" TPUTYPE="1" IMPLICIT="X"/>
  <typeIntfDef CLSNAME="ZCL_TASK" TYPEGROUP="ZIF_TASK_CONSTANT" VERSION="1" TPUTYPE="2" IMPLICIT="X"/>
  <attribute CLSNAME="ZCL_TASK" CMPNAME="MS_PERSISTENT_DATA" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_TASK=&gt;TS_PERSISTENT_DATA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK" CMPNAME="MS_TASK_DATA" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_TASK=&gt;TS_TASK" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TASK" CMPNAME="AT_END_OF_TASK" VERSION="1" LANGU="F" DESCRIPT="Traitement : At End Of Task (fin Tâche arrière-plan)" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="AT_END_OF_TASK" SCONAME="P_TASK" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE"/>
   <exception CLSNAME="ZCL_TASK" CMPNAME="AT_END_OF_TASK" SCONAME="ZCX_TASK" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD at_end_of_task.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : AT_END_OF_TASK                                    *
*&amp; Classe          : ZCL_TASK_MANAGER                                  *
*&amp; Description     : Méthode appelé lorsque le traitement // est finis *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_task_result TYPE ztec_t_function_parameters.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_textid TYPE scx_t100key.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_message                     TYPE c LENGTH 255,
    lv_task_result_data_compressed TYPE xstring.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération des données
  &quot; -----------------------------------------------------------

  &quot; Récupération des données issues du MF
  RECEIVE RESULTS FROM FUNCTION &apos;Z_TASK_CALL_PROCESS&apos;
    IMPORTING
      et_task_result                 = lt_task_result
      ev_task_result_data_compressed = lv_task_result_data_compressed
    EXCEPTIONS
      system_failure                 = 1 MESSAGE lv_message
      communication_failure          = 2 MESSAGE lv_message
      resource_failure               = 3
      error_message                  = 4
      OTHERS                         = 5.
  IF sy-subrc EQ 0.
    &quot; Données correctement récupérée
    &quot;&quot;  --&gt; Appel méthode fin de traitement
    me-&gt;__at_end_of_task(
      it_task_result                 = lt_task_result
      iv_task_result_data_compressed = lv_task_result_data_compressed
    ).

  ELSE.
    &quot; Une erreur est survenue
    &quot;&quot;  --&gt; Lève une Exception
    ls_textid-msgid = sy-msgid.
    ls_textid-msgno = sy-msgno.
    ls_textid-attr1 = sy-msgv1.
    ls_textid-attr2 = sy-msgv2.
    ls_textid-attr3 = sy-msgv3.
    ls_textid-attr4 = sy-msgv4.
    RAISE EVENT task_error_receive_result &quot;(à destination de ZCL_TASK_MANAGER)
      EXPORTING
        io_task   = me
        is_textid = ls_textid.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CONSTRUCTOR" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONSTRUCTOR" SCONAME="IV_GRFC" VERSION="1" LANGU="F" DESCRIPT="Groupe de serveurs RFC pour traitement paralléle" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="RFCGR" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONSTRUCTOR" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement à lancer" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_CALL_PROCESS" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONSTRUCTOR" SCONAME="IV_MANAGE_SHM" VERSION="1" LANGU="F" DESCRIPT="SHM - Gestion de la SHM" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZSHM_MANAGEMENT" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONSTRUCTOR" SCONAME="IV_TASK_MANAGER_ID" VERSION="1" LANGU="F" DESCRIPT="Tâche - ID Manager Tâche" CMPTYPE="1" MTDTYPE="2" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTASK_MANAGER_ID"/>
   <exception CLSNAME="ZCL_TASK" CMPNAME="CONSTRUCTOR" SCONAME="ZCX_TASK" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" MTDTYPE="2" EDITORDER="1 "/>
   <source>METHOD constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Constructeur instance                             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_task TYPE REF TO zcx_task.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Note d&apos;utilisation :
  &quot;   Si paramètre &quot;IS_TASK_CALL_PROCESS&quot; est valorisé
  &quot;     la Tâche sera dédié à ce traitement, dans
  &quot;     ce cas le paramètre d&apos;appel &quot;IV_FUNCTION_NAME&quot;
  &quot;     de la méthode &quot;TASK_START&quot; n&apos;est pas utilisé
  &quot;   Dans le cas contraire, il est obligatoire !
  &quot; -----------------------------------------------------------

  &quot; -----------------------------------------------------------
  &quot; Détermination des types prédéfinis
  &quot; -----------------------------------------------------------

  IF zcl_task=&gt;ms_persistent_data-t_generic_type_list[] IS INITIAL.
    &quot; Récupération Type ABAP prédéfini
    CALL FUNCTION &apos;RS_GET_PREDEFINED_TYPES&apos;
      IMPORTING
        type_list      = zcl_task=&gt;ms_persistent_data-t_generic_type_list
      EXCEPTIONS
        internal_error = 1
        error_message  = 2
        OTHERS         = 3.
    IF sy-subrc EQ 0.
      &quot; Suppression types non génériques
      DELETE zcl_task=&gt;ms_persistent_data-t_generic_type_list WHERE is_generic NE abap_true.

      &quot; Mise en correspondance des données
      LOOP AT zcl_task=&gt;ms_persistent_data-t_generic_type_list ASSIGNING FIELD-SYMBOL(&lt;lfs_s_type_list&gt;).

        IF &lt;lfs_s_type_list&gt;-name CS &apos;%_&apos;.                  &quot;#EC NOTEXT
          &quot; Suppression caractère indésirable
          REPLACE ALL OCCURRENCES OF &apos;%_&apos; IN &lt;lfs_s_type_list&gt;-name WITH space. &quot;#EC NOTEXT
          TRANSLATE &lt;lfs_s_type_list&gt;-name USING &apos;_ &apos;.      &quot;#EC NOTEXT

        ENDIF.

      ENDLOOP.

      &quot; Tri
      SORT zcl_task=&gt;ms_persistent_data-t_generic_type_list BY name.

    ENDIF.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Création instance de Tâche
  &quot; -----------------------------------------------------------

  TRY.
      &quot; Génération ID de Tâche Unique
      me-&gt;ms_task_data-task_id = cl_system_uuid=&gt;create_uuid_c32_static( ).

    CATCH cx_uuid_error.
      &quot; Erreur génération GUID unique
      &quot;&quot;  --&gt; Génération ID aléatoire
      me-&gt;ms_task_data-task_id = |{ sy-datum }{ sy-uzeit }|.

  ENDTRY.

  &quot; -----------------------------------------------------------
  &quot; Initialisation autres attributs
  &quot; -----------------------------------------------------------

  &quot; Initialisation Groupe de Serveur
  IF NOT iv_grfc IS INITIAL.
    &quot; Groupe de Serveur spécifié
    me-&gt;ms_task_data-task_grfc = iv_grfc.

  ELSE.
    &quot; Utilisation Groupe de Serveur par défaut
    me-&gt;ms_task_data-use_default_group = abap_true.

  ENDIF.

  &quot; Initialisation ID Manager
  me-&gt;ms_task_data-task_manager_id = iv_task_manager_id.

  &quot; Initialisation Indicateur Gestion SHM
  me-&gt;ms_task_data-shm_manage_by_manager = iv_manage_shm.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Initialisation données liées au mode dédié
      &quot; -----------------------------------------------------------
      IF NOT is_task_call_process IS INITIAL.

        &quot;&quot;  --&gt; Initialisation Nom Traitement à appeler
        me-&gt;ms_task_data-task_process-task_call_process = is_task_call_process.

        &quot;&quot;  --&gt; Initialisation indicateur Tâche dédiée
        me-&gt;ms_task_data-task_dedicated = abap_true.

        IF NOT is_task_call_process-function_name IS INITIAL.
          &quot; Traitement sur MF
          &quot;&quot;  --&gt; Récupération des paramètres du MF
          me-&gt;func_call_parameters_get( me-&gt;ms_task_data-task_process-task_call_process-function_name ).

        ELSEIF NOT is_task_call_process-class_name  IS INITIAL
           AND NOT is_task_call_process-method_name IS INITIAL.
          &quot; Traitement sur Méthode
          &quot;&quot;  --&gt; Récupération des paramètres de la Méthode
          me-&gt;meth_call_parameters_get(
            iv_class_name  = me-&gt;ms_task_data-task_process-task_call_process-class_name
            iv_method_name = me-&gt;ms_task_data-task_process-task_call_process-method_name
          ).

        ENDIF.

      ENDIF.

    CATCH zcx_task INTO lo_cx_task.
      &quot; Erreur lors de la récupération des paramètres d&apos;appel
      RAISE EXCEPTION TYPE zcx_task
        EXPORTING
          previous = lo_cx_task.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="CONVERT_DYNAMIC_PARAMETERS" VERSION="1" LANGU="F" DESCRIPT="Conversion données paramètres dynamique en statique" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONVERT_DYNAMIC_PARAMETERS" SCONAME="IT_FUNCTION_PARAMETERS_DYNAMIC" VERSION="1" LANGU="F" DESCRIPT="Table des paramètres Dynamique" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_FUNCTION_PARAMETERS"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONVERT_DYNAMIC_PARAMETERS" SCONAME="EV_FUNCTION_DATA_COMPRESSED" VERSION="1" LANGU="F" DESCRIPT="Données compressées" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="XSTRING"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONVERT_DYNAMIC_PARAMETERS" SCONAME="RT_FUNCTION_PARAMETERS_STATIC" VERSION="1" LANGU="F" DESCRIPT="Type de table paramètre d&apos;appel Statique" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTEC_T_FUNCTION_PARAMETERS"/>
   <exception CLSNAME="ZCL_TASK" CMPNAME="CONVERT_DYNAMIC_PARAMETERS" SCONAME="ZCX_TASK" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD convert_dynamic_parameters.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONVERT_DYNAMIC_PARAMETERS                        *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Convertis les données des paramètres &quot;dynamique&quot;  *
*                    en données &quot;statiques&quot;                            *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_cx_exception TYPE REF TO cx_root.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE  : rt_function_parameters_static.
  CLEAR : ev_function_data_compressed.

  IF it_function_parameters_dynamic[] IS INITIAL.
    &quot; Rien à  traiter
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Transformation des paramètres en Version Statique
      &quot; -----------------------------------------------------------

      IF NOT me-&gt;ms_task_data-task_process-task_call_process-function_name IS INITIAL.
        &quot; Traitement pour MF
        rt_function_parameters_static = me-&gt;_convert_dynamic_param_func(
          EXPORTING
            it_function_parameters_dynamic = it_function_parameters_dynamic
          IMPORTING
            ev_function_data_compressed    = ev_function_data_compressed
        ).

      ELSEIF NOT me-&gt;ms_task_data-task_process-task_call_process-class_name  IS INITIAL
         AND NOT me-&gt;ms_task_data-task_process-task_call_process-method_name IS INITIAL.
        &quot; Traitement pour Méthode
        rt_function_parameters_static = me-&gt;_convert_dynamic_param_meth(
          EXPORTING
            it_function_parameters_dynamic = it_function_parameters_dynamic
          IMPORTING
            ev_function_data_compressed    = ev_function_data_compressed
        ).

      ELSEIF NOT me-&gt;ms_task_data-task_process-task_call_process-repid_name IS INITIAL.
        &quot; Traitement pour Programme
        rt_function_parameters_static = me-&gt;_convert_dynamic_param_repid(
          EXPORTING
            it_function_parameters_dynamic = it_function_parameters_dynamic
          IMPORTING
            ev_function_data_compressed    = ev_function_data_compressed
        ).

      ENDIF.

    CATCH zcx_task INTO lo_cx_exception.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Lève l&apos;Exception
      RAISE EXCEPTION TYPE zcx_task
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="CONVERT_STATIC_PARAMETERS" VERSION="1" LANGU="F" DESCRIPT="Conversion données paramètres statique en dynamique" EXPOSURE="0" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONVERT_STATIC_PARAMETERS" SCONAME="IT_FUNCTION_PARAMETERS_STATIC" VERSION="1" LANGU="F" DESCRIPT="Type de table paramètre d&apos;appel Statique" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_T_FUNCTION_PARAMETERS"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONVERT_STATIC_PARAMETERS" SCONAME="IV_FUNCTION_DATA_COMPRESSED" VERSION="1" LANGU="F" DESCRIPT="Données compressées" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSTRING" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="CONVERT_STATIC_PARAMETERS" SCONAME="RT_FUNCTION_PARAMETERS_DYNAMIC" VERSION="1" LANGU="F" DESCRIPT="Table des paramètres dynamique" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_FUNCTION_PARAMETERS"/>
   <source>METHOD convert_static_parameters.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONVERT_STATIC_PARAMETERS                         *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Convertis les données des paramètres &quot;statiques&quot;  *
*                    en données &quot;dynamiques&quot;                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE  : rt_function_parameters_dynamic.

  IF it_function_parameters_static[] IS INITIAL.
    &quot; Rien à  traiter
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Transformation des paramètres en Version Statique
  &quot; -----------------------------------------------------------

  IF NOT me-&gt;ms_task_data-task_process-task_call_process-function_name IS INITIAL.
    &quot; Traitement pour MF
    rt_function_parameters_dynamic = me-&gt;_convert_static_param_func(
      it_function_parameters_static = it_function_parameters_static
      iv_function_data_compressed   =  iv_function_data_compressed
    ).

  ELSEIF NOT me-&gt;ms_task_data-task_process-task_call_process-class_name  IS INITIAL
     AND NOT me-&gt;ms_task_data-task_process-task_call_process-method_name IS INITIAL.
    &quot; Traitement pour Méthode
    rt_function_parameters_dynamic = me-&gt;_convert_static_param_meth(
        it_function_parameters_static = it_function_parameters_static
        iv_function_data_compressed   = iv_function_data_compressed
    ).

  ELSEIF not me-&gt;ms_task_data-task_process-task_call_process-repid_name IS INITIAL.
    &quot; Traitement pour Programme
    rt_function_parameters_dynamic = me-&gt;_convert_static_param_repid(
        it_function_parameters_static = it_function_parameters_static
        iv_function_data_compressed   = iv_function_data_compressed
    ).

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="FUNC_CALL_PARAMETERS_GET" VERSION="1" LANGU="F" DESCRIPT="Module Fonction - Paramètres - Récupération" EXPOSURE="0" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="FUNC_CALL_PARAMETERS_GET" SCONAME="IV_FUNCTION_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom du module fonction" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="RS38L_FNAM"/>
   <exception CLSNAME="ZCL_TASK" CMPNAME="FUNC_CALL_PARAMETERS_GET" SCONAME="ZCX_TASK" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD FUNC_CALL_PARAMETERS_GET.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : FUNCTION_CALL_PARAMETERS_GET                      *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Récupération des paramètres d&apos;appel du MF         *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_fupararef TYPE zcl_task=&gt;tt_fupararef.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_textid    TYPE scx_t100key,
    ls_fupararef TYPE zcl_task=&gt;ts_fupararef.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle le sur le Nom du MF
  &quot; -----------------------------------------------------------

  SELECT SINGLE funcname FROM tfdir   &quot;Entrée bufférisée
                        WHERE funcname EQ @iv_function_name
                         INTO @ls_fupararef-funcname.
  IF sy-subrc NE 0.
    &quot; Le MF n&apos;existe pas
    &quot;&quot;  --&gt; Lève une exception
    ls_textid-msgid = zif_task_constant=&gt;mc_message_class_id.
    ls_textid-msgno = 002.
    ls_textid-attr1 = me-&gt;ms_task_data-task_id.
    ls_textid-attr2 = iv_function_name.
    RAISE EXCEPTION TYPE zcx_task
      EXPORTING
        textid = ls_textid.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Récupération de la liste des paramètres du MF
  &quot; -----------------------------------------------------------

  &quot; Liste paramètres déjà  récupérée ?
  READ TABLE zcl_task=&gt;ms_persistent_data-t_fupararef WITH KEY funcname = iv_function_name
                                        TRANSPORTING NO FIELDS BINARY SEARCH.
  IF sy-subrc NE 0.
    &quot;&quot;  --&gt; Récupération données des paramètres du MF
    SELECT funcname,  parameter,
           paramtype, structure FROM fupararef
                               WHERE funcname EQ @iv_function_name
                          INTO TABLE @lt_fupararef.
    IF sy-subrc NE 0.
      &quot; Aucun paramètre existant pour ce MF
      &quot;&quot;  --&gt; Création d&apos;une nouvelle entrée afin d&apos;éviter de rechercher à  nouveau
      ls_fupararef-funcname = iv_function_name.
      INSERT ls_fupararef INTO TABLE zcl_task=&gt;ms_persistent_data-t_fupararef.

    ELSE.
      &quot; Paramètres existant
      &quot;&quot;  --&gt; Ajout de la liste des Paramètres
      INSERT LINES OF lt_fupararef INTO TABLE zcl_task=&gt;ms_persistent_data-t_fupararef.

    ENDIF.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="METH_CALL_PARAMETERS_GET" VERSION="1" LANGU="F" DESCRIPT="Méthode - Paramètres - Récupération" EXPOSURE="0" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="METH_CALL_PARAMETERS_GET" SCONAME="IV_CLASS_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom de type d&apos;objet" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCLSNAME"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="METH_CALL_PARAMETERS_GET" SCONAME="IV_METHOD_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom d&apos;une méthode" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOMTDNAME"/>
   <exception CLSNAME="ZCL_TASK" CMPNAME="METH_CALL_PARAMETERS_GET" SCONAME="ZCX_TASK" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD meth_call_parameters_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : METHOD_CALL_PARAMETERS_GET                        *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Récupération des paramètres d&apos;appel de la méthode *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_seosubcodf TYPE zcl_task=&gt;tt_seosubcodf.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_textid     TYPE scx_t100key,
    ls_seocompodf TYPE zcl_task=&gt;ts_seocompodf,
    ls_seosubcodf TYPE zcl_task=&gt;ts_seosubcodf.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Contrôle sur le Nom de la Méthode
      &quot; -----------------------------------------------------------

      IF zcl_task=&gt;ms_persistent_data-t_seocompodf[ clsname = iv_class_name
                                                    cmpname = iv_method_name
                                                  ]-not_found EQ abap_true.
        &quot;&quot;  --&gt; Lève une exception
        ls_textid-msgid = zif_task_constant=&gt;mc_message_class_id.
        ls_textid-msgno = 002.
        ls_textid-attr1 = me-&gt;ms_task_data-task_id.
        ls_textid-attr2 = |{ iv_class_name }=&gt;{ iv_method_name }|.
        RAISE EXCEPTION TYPE zcx_task
          EXPORTING
            textid = ls_textid.

      ENDIF.

    CATCH cx_sy_itab_line_not_found.
      &quot; Entrée non trouvée en Buffer
      &quot;&quot;  --&gt; Recherche en DB
      SELECT SINGLE clsname, cmpname,
                    mtdnewexc
               FROM seocompodf
              WHERE clsname    EQ @iv_class_name
                AND cmpname    EQ @iv_method_name
                AND version    EQ &apos;1&apos; &quot;Actif &quot;#EC NOTEXT
                AND exposure   EQ &apos;2&apos; &quot;Publique &quot;#EC NOTEXT
                AND mtddecltyp EQ &apos;1&apos; &quot;Statique &quot;#EC NOTEXT
                INTO @ls_seocompodf.
      IF sy-subrc NE 0.
        &quot; La méthode n&apos;existe pas
        &quot;&quot;  --&gt; Force l&apos;Ajout en Buffer
        ls_seocompodf-clsname   = iv_class_name.
        ls_seocompodf-cmpname   = iv_method_name.
        ls_seocompodf-not_found = abap_true.
        INSERT ls_seocompodf INTO TABLE zcl_task=&gt;ms_persistent_data-t_seocompodf.

        &quot;&quot;  --&gt; Lève une Exception
        ls_textid-msgid = zif_task_constant=&gt;mc_message_class_id.
        ls_textid-msgno = 002.
        ls_textid-attr1 = me-&gt;ms_task_data-task_id.
        ls_textid-attr2 = |{ iv_class_name }=&gt;{ iv_method_name }|.
        RAISE EXCEPTION TYPE zcx_task
          EXPORTING
            textid = ls_textid.

      ENDIF.

      &quot; Ajout de l&apos;entrée
      INSERT ls_seocompodf INTO TABLE zcl_task=&gt;ms_persistent_data-t_seocompodf.

  ENDTRY.

  &quot; -----------------------------------------------------------
  &quot; Récupération de la liste des paramètres de la Méthode
  &quot; -----------------------------------------------------------

  &quot; Liste paramètres déjà récupérée ?
  READ TABLE zcl_task=&gt;ms_persistent_data-t_seosubcodf WITH KEY clsname = iv_class_name
                                                                cmpname = iv_method_name
                                 TRANSPORTING NO FIELDS BINARY SEARCH.
  IF sy-subrc NE 0.
    &quot;&quot;  --&gt; Récupération données des paramètres de la Méthode
    SELECT main~clsname,    main~cmpname, main~sconame,
           main~pardecltyp, main~typtype, main~type,
           header~scotype
      FROM seosubcodf AS main INNER JOIN seosubco     AS header
                                      ON main~clsname EQ header~clsname
                                     AND main~cmpname EQ header~cmpname
                                     AND main~sconame EQ header~sconame
                                   WHERE main~clsname EQ @iv_class_name
                                     AND main~cmpname EQ @iv_method_name
                                     AND main~version EQ &apos;1&apos;  &quot;Actif #EC NOTEXT
                              INTO TABLE @lt_seosubcodf.
    IF sy-subrc NE 0.
      &quot; Aucun paramètre existant pour ce MF
      &quot;&quot;  --&gt; Création d&apos;une nouvelle entrée afin d&apos;éviter de rechercher à nouveau
      ls_seosubcodf-clsname = iv_class_name.
      ls_seosubcodf-cmpname = iv_method_name.
      INSERT ls_seosubcodf INTO TABLE zcl_task=&gt;ms_persistent_data-t_seosubcodf.

    ELSE.
      &quot; Paramètres existant
      &quot;&quot;  --&gt; Ajout de la liste des Paramètres
      INSERT LINES OF lt_seosubcodf INTO TABLE zcl_task=&gt;ms_persistent_data-t_seosubcodf.

    ENDIF.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="REPID_CALL_PARAMETERS_GET" VERSION="1" LANGU="F" DESCRIPT="Programme - Paramètres - Récupération" EXPOSURE="0" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="REPID_CALL_PARAMETERS_GET" SCONAME="IV_REPID" VERSION="1" LANGU="F" DESCRIPT="Nom du programme ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="REPID"/>
   <source>METHOD repid_call_parameters_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : REPID_CALL_PARAMETERS_GET                         *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Récupération des paramètres d&apos;appel du Programme  *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *
***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
        ls_repid_selection_screen TYPE zcl_task=&gt;ts_repid_selection_screen.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération des Paramètres de l&apos;Ecran de Sélection
  &quot; -----------------------------------------------------------

  &quot; Récupération des données en Buffer
  READ TABLE zcl_task=&gt;ms_persistent_data-t_repid_selection_screen
  WITH TABLE KEY repid = iv_repid
       ASSIGNING FIELD-SYMBOL(&lt;lfs_s_repid_selection_screen&gt;).
  IF sy-subrc NE 0.
    &quot; Aucune correspondance en Buffers
    &quot;&quot;  --&gt; Récupération des élèments de l&apos;Ecran de Sélection
    CALL FUNCTION &apos;RS_REPORTSELECTIONS_INFO&apos;
      EXPORTING
        report              = iv_repid
        default_values      = abap_true
      TABLES
        field_info          = ls_repid_selection_screen-t_field_info
        def_values_255      = ls_repid_selection_screen-t_def_values
      EXCEPTIONS
        no_selections       = 1
        report_not_existent = 2
        subroutine_pool     = 3
        error_message       = 4
        OTHERS              = 5.
    IF sy-subrc EQ 0.
      &quot; Données récupérées
      &quot;&quot;  --&gt; Tri pour performance
      ls_repid_selection_screen-no_data = abap_true.
      SORT ls_repid_selection_screen-t_field_info BY name.
      SORT ls_repid_selection_screen-t_def_values BY selname.

    ENDIF.

    &quot;&quot;  --&gt; Ajout de l&apos;entrée
    ls_repid_selection_screen-repid = iv_repid.
    INSERT ls_repid_selection_screen INTO TABLE zcl_task=&gt;ms_persistent_data-t_repid_selection_screen
                                      ASSIGNING &lt;lfs_s_repid_selection_screen&gt;.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="TASK_FREE" VERSION="1" LANGU="F" DESCRIPT="Tâche - Réinitialisation" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD task_free.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_FREE                                         *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Réinitialisation de la Tâche                      *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; Réinitialisation des données relatives à la Tâche
  FREE : me-&gt;ms_task_data-task_running,
         me-&gt;ms_task_data-task_trace_id,
         me-&gt;ms_task_data-task_process-task_container,
         me-&gt;ms_task_data-task_process-t_definition_type_in_shm.

  IF me-&gt;ms_task_data-task_dedicated NE abap_true.
    &quot; Dans le cas d&apos;une Tâche non dédiée
    &quot;&quot;  --&gt; Réinitialisation traitement à appeler
    CLEAR : me-&gt;ms_task_data-task_process-task_call_process.

    &quot;&quot;  --&gt; Réinitialisation Indicateur de Gestion de la SHM
    CLEAR : me-&gt;ms_task_data-shm_manage_by_local.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="TASK_START" VERSION="1" LANGU="F" DESCRIPT="Tâche - Lancement" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="TASK_START" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement à lancer" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_CALL_PROCESS" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="TASK_START" SCONAME="IO_TASK_CONTAINER" VERSION="1" LANGU="F" DESCRIPT="Container paramètres d&apos;appel" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_TASK_CONTAINER" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="TASK_START" SCONAME="IS_TASK_COMPRESS_PARAM" VERSION="1" LANGU="F" DESCRIPT="Tâche - Paramètres de compression" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_COMPRESS_PARAM"/>
   <exception CLSNAME="ZCL_TASK" CMPNAME="TASK_START" SCONAME="ZCX_TASK" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD task_start.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_START                                        *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Permet de démarrer le processus de la Tâche       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_task_result         TYPE ztec_t_function_parameters,
    lt_function_parameters TYPE ztec_t_function_parameters.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_textid              TYPE scx_t100key,
    ls_task_call_process   TYPE ztec_s_task_call_process,
    ls_task_compress_param TYPE ztec_s_task_compress_param.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_cx_exception TYPE REF TO cx_root.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_function_data_compressed    TYPE xstring,
    lv_task_result_data_compressed TYPE xstring.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : me-&gt;ms_task_data-task_process-t_definition_type_in_shm,
         me-&gt;ms_task_data-task_process-task_container,
         me-&gt;ms_task_data-data_compress_param.

  &quot; -----------------------------------------------------------
  &quot; Initialisation Indicateur Tâche en cours de préparation
  &quot; -----------------------------------------------------------

  &quot; Initialisation Indicateur Tâche en cours de préparation
  me-&gt;ms_task_data-task_running = abap_undefined.

  &quot; Initialisation variable locale
  IF me-&gt;ms_task_data-task_dedicated EQ abap_true.
    &quot; Mode dédié
    &quot;&quot;  --&gt; Initialisation avec paramètre Dédiée
    ls_task_call_process = me-&gt;ms_task_data-task_process-task_call_process.

  ELSE.
    &quot; Initialisation avec paramètre d&apos;Appel
    ls_task_call_process = is_task_call_process.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Contrôle
  &quot; -----------------------------------------------------------

  IF me-&gt;ms_task_data-task_dedicated EQ abap_false AND ls_task_call_process IS INITIAL.
    &quot; Le traitement à appeler devient alors obligatoire et ce dernier n&apos;a pas été transmis
    &quot;&quot;  --&gt; Arrêt du traitement // Lève une exception
    me-&gt;ms_task_data-task_running = abap_false.
    ls_textid-msgid = zif_task_constant=&gt;mc_message_class_id.
    ls_textid-msgno = 003.
    ls_textid-attr1 = me-&gt;ms_task_data-task_id.
    RAISE EXCEPTION TYPE zcx_task
      EXPORTING
        textid = ls_textid.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Chargement données nécessaires
      &quot; -----------------------------------------------------------

      IF NOT ls_task_call_process-function_name IS INITIAL.
        &quot; Nom MF transmis
        &quot;&quot;  --&gt; Récupération des paramètres du MF
        me-&gt;func_call_parameters_get( ls_task_call_process-function_name ).

        &quot;&quot;  --&gt; Initialisation du nom du MF pour poursuite du traitement
        me-&gt;ms_task_data-task_process-task_call_process-function_name = ls_task_call_process-function_name.

      ELSEIF NOT ls_task_call_process-class_name  IS INITIAL
         AND NOT ls_task_call_process-method_name IS INITIAL.
        &quot; Méthode statique transmise
        &quot;&quot;  --&gt; Récupération des paramètres de la méthode
        me-&gt;meth_call_parameters_get(
          iv_class_name  = ls_task_call_process-class_name
          iv_method_name = ls_task_call_process-method_name
        ).

        &quot;&quot;  --&gt; Initialisation du nom de la méthode pour poursuite du traitement
        me-&gt;ms_task_data-task_process-task_call_process-class_name  = ls_task_call_process-class_name.
        me-&gt;ms_task_data-task_process-task_call_process-method_name = ls_task_call_process-method_name.

      ELSEIF NOT ls_task_call_process-repid_name IS INITIAL.
        &quot; Programme transmis
        &quot;&quot;  --&gt; Récupération des paramètres du Programme
        me-&gt;repid_call_parameters_get( ls_task_call_process-repid_name ).

        &quot;&quot;  --&gt; Initialisation du nom de la méthode pour poursuite du traitement
        me-&gt;ms_task_data-task_process-task_call_process-repid_name  = ls_task_call_process-repid_name.

      ELSE.
        &quot; Aucun traitement à appeler
        RETURN.

      ENDIF.

    CATCH zcx_task INTO lo_cx_exception.
      &quot; Erreur lors de la récupération des paramètres d&apos;appel
      me-&gt;ms_task_data-task_running = abap_false.
      RAISE EXCEPTION TYPE zcx_task
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

  &quot; -----------------------------------------------------------
  &quot; Initialisation configuration de compression
  &quot; -----------------------------------------------------------

  &quot; Intiailisation paramètre de configuration pour la compression
  me-&gt;ms_task_data-data_compress_param = is_task_compress_param.

  &quot; -----------------------------------------------------------
  &quot; Initialisation paramètres d&apos;appel
  &quot; -----------------------------------------------------------

  IF io_task_container IS BOUND.
    &quot; Utilisation des paramètres d&apos;appel transmis
    me-&gt;ms_task_data-task_process-task_container = io_task_container-&gt;copy_get( ).

  ELSE.
    &quot; Création nouvelle instance Container
    CREATE OBJECT me-&gt;ms_task_data-task_process-task_container.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Evènement début d&apos;une Tâche
  &quot; -----------------------------------------------------------

  &quot; Déclenche évènement début d&apos;une Tâche
  RAISE EVENT task_before
    EXPORTING
      io_task = me.

  IF NOT me-&gt;ms_task_data-task_process-task_container-&gt;mt_function_parameters[] IS INITIAL.
    &quot; -----------------------------------------------------------
    &quot; Initialisation table de paramètre statique pour appel Asynchrone
    &quot; -----------------------------------------------------------

    TRY.
        &quot; Conversion des paramètres dynamique en statique (pour appel MF de lancement)
        lt_function_parameters = me-&gt;convert_dynamic_parameters(
          EXPORTING
            it_function_parameters_dynamic = me-&gt;ms_task_data-task_process-task_container-&gt;mt_function_parameters
          IMPORTING
            ev_function_data_compressed    = lv_function_data_compressed
        ).

      CATCH zcx_task INTO lo_cx_exception.
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Lève une Exception
        me-&gt;ms_task_data-task_running = abap_false.
        RAISE EXCEPTION TYPE zcx_task
          EXPORTING
            textid = ls_textid.

    ENDTRY.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Initialisation Indicateur Tâche en cours de traitement
  &quot; -----------------------------------------------------------

  &quot; Initialisation Indicateur Tâche occupée
  me-&gt;ms_task_data-task_running = abap_true.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Appel du Traitement en //
      &quot; -----------------------------------------------------------

      IF me-&gt;ms_task_data-use_default_group EQ abap_true.
        &quot; Appel fonction générique (avec paramètre statique) qui appel le MF souhaité
        CALL FUNCTION &apos;Z_TASK_CALL_PROCESS&apos;
          STARTING NEW TASK me-&gt;ms_task_data-task_id DESTINATION IN GROUP DEFAULT
          CALLING at_end_of_task ON END OF TASK
          EXPORTING
            is_task_call_process         = me-&gt;ms_task_data-task_process-task_call_process
            it_task_call_parameters      = lt_function_parameters
            iv_task_call_data_compressed = lv_function_data_compressed
            is_task_data_compress_param  = me-&gt;ms_task_data-data_compress_param
          EXCEPTIONS
            system_failure               = 1
            communication_failure        = 2
            resource_failure             = 3
            error_message                = 4
            OTHERS                       = 5.

      ELSE.
        &quot; Appel fonction générique (avec paramètre statique) qui appel le MF souhaité
        CALL FUNCTION &apos;Z_TASK_CALL_PROCESS&apos;
          STARTING NEW TASK me-&gt;ms_task_data-task_id DESTINATION IN GROUP me-&gt;ms_task_data-task_grfc
          CALLING at_end_of_task ON END OF TASK
          EXPORTING
            is_task_call_process         = me-&gt;ms_task_data-task_process-task_call_process
            it_task_call_parameters      = lt_function_parameters
            iv_task_call_data_compressed = lv_function_data_compressed
            is_task_data_compress_param  = me-&gt;ms_task_data-data_compress_param
          EXCEPTIONS
            system_failure               = 1
            communication_failure        = 2
            resource_failure             = 3
            error_message                = 4
            OTHERS                       = 5.

      ENDIF.
      IF sy-subrc EQ 0.
        &quot; Aucune erreur

      ELSEIF sy-subrc EQ 1
          OR sy-subrc EQ 2
          OR sy-subrc EQ 3.
        &quot; Erreur lors de l&apos;appel RFC asynchrone
        &quot;&quot;  --&gt; Appel du Traitement en Synchrone
        CALL FUNCTION &apos;Z_TASK_CALL_PROCESS&apos;
          EXPORTING
            is_task_call_process           = me-&gt;ms_task_data-task_process-task_call_process
            it_task_call_parameters        = lt_function_parameters
            iv_task_call_data_compressed   = lv_function_data_compressed
            is_task_data_compress_param    = me-&gt;ms_task_data-data_compress_param
          IMPORTING
            et_task_result                 = lt_task_result
            ev_task_result_data_compressed = lv_task_result_data_compressed
          EXCEPTIONS
            call_process_error             = 1
            dynamic_convert_error          = 2
            during_process_error           = 3
            error_message                  = 4
            OTHERS                         = 5.
        IF sy-subrc NE 0.
          &quot; Une erreur est survenue
          &quot;&quot;  --&gt; Appel traitement de fin d&apos;une Tâche en erreur
          CLEAR : ls_textid.
          ls_textid-msgid = sy-msgid.
          ls_textid-msgno = sy-msgno.
          ls_textid-attr1 = sy-msgv1.
          ls_textid-attr2 = sy-msgv2.
          ls_textid-attr3 = sy-msgv3.
          ls_textid-attr4 = sy-msgv4.
          RAISE EVENT task_error_receive_result &quot;(à destination de ZCL_TASK_MANAGER)
            EXPORTING
              io_task   = me
              is_textid = ls_textid.

        ELSE.
          &quot; Une erreur est survenue
          &quot;&quot;  --&gt; Appel traitement de fin d&apos;une Tâche
          me-&gt;__at_end_of_task(
            it_task_result                 = lt_task_result
            iv_task_result_data_compressed = lv_task_result_data_compressed
          ).

        ENDIF.

      ELSE.
        &quot; Erreur &quot;fonctionnelle&quot; // Si implémentée au niveau du MF &quot;Z_TASK_CALL_PROCESS&quot;
        &quot;&quot;  --&gt; Initialisation code en erreur
        ls_textid-msgid = sy-msgid.
        ls_textid-msgno = sy-msgno.
        ls_textid-attr1 = sy-msgv1.
        ls_textid-attr2 = sy-msgv2.
        ls_textid-attr3 = sy-msgv3.
        ls_textid-attr4 = sy-msgv4.
        RAISE EXCEPTION TYPE zcx_task
          EXPORTING
            textid = ls_textid.

      ENDIF.

    CATCH cx_root INTO lo_cx_exception.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Lève l&apos;Exception
      RAISE EXCEPTION TYPE zcx_task
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="TASK_STOP" VERSION="1" LANGU="F" DESCRIPT="Tâche - Fin d&apos;une Tâche" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD task_stop.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_STOP                                         *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Termine la Tâche                                  *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Note d&apos;utilisation :
  &quot;  On ne libère pas la Tâche (réinitialisation de l&apos;indicateur
  &quot;  en cours de traitement) dans cette classe !
  &quot;  Seule la classe ZCL_TASK_MANAGER se réserve le droit
  &quot;  de modifier cet indicateur afin de maitriser
  &quot;  parfaitement les débuts et fin de Tâche.
  &quot; -----------------------------------------------------------

  &quot; -----------------------------------------------------------
  &quot; Traitement lors du fin de la Tâche
  &quot; -----------------------------------------------------------

  &quot;&quot;  --&gt; Lève évènement fin de Tâche (à destination de ZCL_TASK_MANAGER)
  RAISE EVENT task_end
    EXPORTING
      io_task = me.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_DYNAMIC_PARAM_FUNC" VERSION="1" LANGU="F" DESCRIPT="Module Fonction - Conversion données Dyn --&gt; Stat" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_DYNAMIC_PARAM_FUNC" SCONAME="IT_FUNCTION_PARAMETERS_DYNAMIC" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_FUNCTION_PARAMETERS"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_DYNAMIC_PARAM_FUNC" SCONAME="EV_FUNCTION_DATA_COMPRESSED" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="XSTRING"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_DYNAMIC_PARAM_FUNC" SCONAME="RT_FUNCTION_PARAMETERS_STATIC" VERSION="1" LANGU="F" DESCRIPT="Type de table paramètre d&apos;appel Statique" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTEC_T_FUNCTION_PARAMETERS"/>
   <exception CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_DYNAMIC_PARAM_FUNC" SCONAME="ZCX_TASK" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD _convert_dynamic_param_func.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : _CONVERT_DYNAMIC_PARAM_FUNC                       *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Convertis les données des paramètres &quot;dynamique&quot;  *
*                    en données &quot;statiques&quot;                            *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lot_table TYPE REF TO data.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_function_parameters_static TYPE ztec_s_function_parameters.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_data TYPE REF TO data.

  DATA :
    lo_abap_zip        TYPE REF TO cl_abap_zip,
    lo_cx_exception    TYPE REF TO cx_root,
    lo_type_definition TYPE REF TO zcl_type_definition.

  DATA :
    lo_typedescr  TYPE REF TO cl_abap_typedescr,
    lo_datadescr  TYPE REF TO cl_abap_datadescr,
    lo_tabledescr TYPE REF TO cl_abap_tabledescr.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_parameter_data&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE  : rt_function_parameters_static.
  CLEAR : ev_function_data_compressed.

  IF it_function_parameters_dynamic[] IS INITIAL.
    &quot; Rien à  traiter
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Pré-Traitement
  &quot; -----------------------------------------------------------

  IF NOT me-&gt;ms_task_data-data_compress_param IS INITIAL.
    &quot; Activation de la Compression globale ou Ligne par Ligne
    &quot;&quot;  --&gt; Création instance de Compression
    CREATE OBJECT lo_abap_zip.
    lo_abap_zip-&gt;support_unicode_names = abap_true.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Transforme données en paramètre statique
  &quot; -----------------------------------------------------------

  &quot; Parcours l&apos;ensemble des paramètres &quot;dynamiques&quot;
  LOOP AT it_function_parameters_dynamic ASSIGNING FIELD-SYMBOL(&lt;lfs_s_function_parameters&gt;).

    CLEAR    : ls_function_parameters_static, lo_tabledescr, lo_typedescr, lo_datadescr.
    UNASSIGN : &lt;lfs_parameter_data&gt;.

    &quot; Initialisation Nom du Paramètre
    ls_function_parameters_static-parameter_name = &lt;lfs_s_function_parameters&gt;-parameter_name.

    &quot; Récupération données du paramètre
    READ TABLE zcl_task=&gt;ms_persistent_data-t_fupararef WITH TABLE KEY funcname  = me-&gt;ms_task_data-task_process-task_call_process-function_name
                                                     parameter = CONV fupararef-parameter( &lt;lfs_s_function_parameters&gt;-parameter_name )
                                           ASSIGNING FIELD-SYMBOL(&lt;lfs_s_fupararef&gt;).
    IF sy-subrc NE 0.
      &quot; Paramètre inexistant
      &quot;&quot;  --&gt; Passe à l&apos;itération suivante
      CONTINUE.

    ENDIF.

    TRY.
        &quot; Initialisation type du paramètre
        ls_function_parameters_static-parameter_kind = SWITCH string( &lt;lfs_s_fupararef&gt;-paramtype
            WHEN &apos;I&apos; THEN zif_task_constant=&gt;mc_parameter_kind_exporting &quot;#EC NOTEXT
            WHEN &apos;E&apos; THEN zif_task_constant=&gt;mc_parameter_kind_importing &quot;#EC NOTEXT
            WHEN &apos;T&apos; THEN zif_task_constant=&gt;mc_parameter_kind_tables &quot;#EC NOTEXT
            WHEN &apos;C&apos; THEN zif_task_constant=&gt;mc_parameter_kind_changing &quot;#EC NOTEXT
            ELSE THROW cx_sy_arg_out_of_domain( )
        ).

      CATCH cx_sy_arg_out_of_domain.
        &quot; Autre valeur
        IF &lt;lfs_s_fupararef&gt;-paramtype EQ &apos;X&apos;.
          &quot; Cas d&apos;une Exception
          ls_function_parameters_static-parameter_kind = zif_task_constant=&gt;mc_parameter_kind_exception.
          INSERT ls_function_parameters_static INTO TABLE rt_function_parameters_static.

        ENDIF.

        &quot;&quot;  --&gt; Passe à  l&apos;itération suivante
        CONTINUE.

    ENDTRY.

    &quot; Récupération définition type du paramètre
    cl_abap_typedescr=&gt;describe_by_name(
      EXPORTING
        p_name         = &lt;lfs_s_fupararef&gt;-structure
      RECEIVING
        p_descr_ref    = lo_typedescr
      EXCEPTIONS
        type_not_found = 1
        OTHERS         = 2
    ).
    IF sy-subrc NE 0.
      &quot; Une erreur est survenue (cas du &quot;ANY TABLE&quot; par exemple)
      CLEAR : lo_typedescr.

    ENDIF.

    IF &lt;lfs_s_function_parameters&gt;-parameter_data IS BOUND.
      &quot; Initialisation pointeur sur les données
      ASSIGN &lt;lfs_s_function_parameters&gt;-parameter_data-&gt;* TO &lt;lfs_parameter_data&gt;.

    ELSEIF &lt;lfs_s_fupararef&gt;-paramtype EQ &apos;T&apos;               &quot;#EC NOTEXT
       AND lo_typedescr IS BOUND.
      &quot; Paramètre Type Table et non transmis
      &quot;&quot;  --&gt; Création du Type de table
      TRY.
          &quot; Création Type de Table
          lo_datadescr ?= lo_typedescr.
          lo_tabledescr = cl_abap_tabledescr=&gt;create( p_line_type = lo_datadescr ).

          &quot; Initialisation Pointeur sur les données
          CREATE DATA lot_table TYPE HANDLE lo_tabledescr.
          ASSIGN lot_table-&gt;* TO &lt;lfs_parameter_data&gt;.

        CATCH cx_sy_table_creation.
          &quot; Erreur lors de la création du Type
          &quot;&quot;  --&gt; Force la provocation d&apos;un DUMP
          MESSAGE x005(ztask) WITH me-&gt;ms_task_data-task_id &lt;lfs_s_function_parameters&gt;-parameter_name.

      ENDTRY.

    ENDIF.

    &quot; Traitement cas particulier des types génériques
    READ TABLE zcl_task=&gt;ms_persistent_data-t_generic_type_list WITH KEY name = &lt;lfs_s_fupararef&gt;-structure
                                          TRANSPORTING NO FIELDS BINARY SEARCH.
    IF sy-subrc EQ 0 OR NOT lo_typedescr IS BOUND OR lo_typedescr-&gt;is_ddic_type( ) EQ abap_false.
      &quot; Type générique ou pas du dictionnaire
      &quot;&quot;  --&gt; Contrôle supplémentaire
      IF  NOT &lt;lfs_parameter_data&gt; IS ASSIGNED
      AND &lt;lfs_s_function_parameters&gt;-type_for_none_ddic_parameter IS INITIAL.
        &quot; Aucun moyen de déterminer le type
        &quot;&quot;  --&gt; Force la provocation d&apos;un DUMP
        MESSAGE x005(ztask) WITH me-&gt;ms_task_data-task_id &lt;lfs_s_function_parameters&gt;-parameter_name.

      ELSEIF NOT &lt;lfs_s_function_parameters&gt;-type_for_none_ddic_parameter IS INITIAL.
        &quot; Type transmis
        &quot;&quot;  --&gt; Récupération descriptino du Type
        cl_abap_typedescr=&gt;describe_by_name(
          EXPORTING
            p_name         = &lt;lfs_s_function_parameters&gt;-type_for_none_ddic_parameter
          RECEIVING
            p_descr_ref    = lo_typedescr
          EXCEPTIONS
            type_not_found = 1
            OTHERS         = 2
        ).
        IF sy-subrc NE 0.
          &quot; Type non défini dans le RTTS
          &quot;&quot;  --&gt; Aucun moyen de déterminer le type // Force la provocation d&apos;un DUMP
          MESSAGE x005(ztask) WITH me-&gt;ms_task_data-task_id &lt;lfs_s_function_parameters&gt;-parameter_name.

        ENDIF.

      ELSEIF &lt;lfs_parameter_data&gt; IS ASSIGNED.
        &quot; Données transmises
        &quot;&quot;  --&gt; Récupération description des données
        lo_typedescr = cl_abap_typedescr=&gt;describe_by_data( &lt;lfs_parameter_data&gt; ).

      ELSE.
        &quot; Nous n&apos;irons jamais ici, mais au moins il est présent
        &quot;&quot;  --&gt; Force la provocation d&apos;un DUMP
        MESSAGE x005(ztask) WITH me-&gt;ms_task_data-task_id &lt;lfs_s_function_parameters&gt;-parameter_name.

      ENDIF.

      IF lo_typedescr-&gt;is_ddic_type( ) EQ abap_false.
        &quot; Type non présent dans le dictionnaire
        &quot;&quot;  --&gt; Utilisation SHM pour stockage du Type
        TRY.
            IF NOT lo_type_definition IS BOUND.
              &quot; Récupération de l&apos;instance courante
              lo_type_definition = zcl_type_definition=&gt;get_instance( ).

            ENDIF.

            IF lo_type_definition IS BOUND.
              &quot; Ajout de la définition
              lo_type_definition-&gt;definition_type_add( io_definition = lo_typedescr ).

              IF me-&gt;ms_task_data-shm_manage_by_manager EQ abap_true
              OR zcl_task_param=&gt;task_param_get( me-&gt;ms_task_data-task_process-task_call_process )-shm_management EQ abap_true.
                TRY.
                    &quot; -----------------------------------------------------------
                    &quot; Enregistre l&apos;ID Manager de Tâche dans la SHM
                    &quot; -----------------------------------------------------------

                    &quot; Ajout de l&apos;ID du Manager de Tâche
                    zcl_task_shm=&gt;get_instance( lo_typedescr-&gt;absolute_name )-&gt;task_manager_register( me-&gt;ms_task_data-task_manager_id ).

                    &quot; Ajout du Type dans la Liste stocké en SHM
                    APPEND lo_typedescr-&gt;absolute_name TO me-&gt;ms_task_data-task_process-t_definition_type_in_shm.

                  CATCH cx_root.          &quot;#EC CATCH_ALL #EC NO_HANDLER
                    &quot; Erreur lors de l&apos;ajout dans la SHM

                ENDTRY.

                &quot; Initialisation Indicateur Gestion Local de la SHM
                me-&gt;ms_task_data-shm_manage_by_local = abap_true.

              ENDIF.

            ENDIF.

          CATCH cx_root.                  &quot;#EC CATCH_ALL #EC NO_HANDLER
            &quot; Une erreur est survenue lors de l&apos;utilisation de la mémoire partagée

        ENDTRY.

      ENDIF.        &quot;Fin test Type DDIC

    ENDIF.          &quot;Fin test type générique

    &quot; Initialisation type (ABAP) de données
    IF &lt;lfs_s_fupararef&gt;-paramtype EQ &apos;T&apos;.                  &quot;#EC NOTEXT
      &quot; Paramètre d&apos;appel de type &quot;Table&quot;
      &quot;&quot;  --&gt; Force le type en Type de table
      ls_function_parameters_static-value_kind = cl_abap_typedescr=&gt;kind_table.

    ELSE.
      &quot; Paramètre d&apos;appel d&apos;autre type
      &quot;&quot;  --&gt; Utilisation type tel que fourni par le standard
      ls_function_parameters_static-value_kind = lo_typedescr-&gt;kind.

    ENDIF.

    &quot; Initialisation Type
    ls_function_parameters_static-value_type = lo_typedescr-&gt;absolute_name.

    IF ls_function_parameters_static-parameter_kind NE zif_task_constant=&gt;mc_parameter_kind_importing.
      &quot; Paramètre &lt;&gt; Import (Vue appelant)
      IF NOT &lt;lfs_parameter_data&gt; IS ASSIGNED.
        &quot; Pas de données
        &quot;&quot;  --&gt; Création container données vide
        lo_datadescr ?= lo_typedescr.
        CREATE DATA lo_data TYPE HANDLE lo_datadescr.
        ASSIGN lo_data-&gt;* TO &lt;lfs_parameter_data&gt;.

      ENDIF.

      TRY.
          &quot;&quot;  --&gt; Suivant son type (Table / Structure / Référence / Autres ...)
          CASE lo_typedescr-&gt;kind.

            WHEN cl_abap_typedescr=&gt;kind_elem.
              &quot; Elementaire
              &quot;&quot;  --&gt; Initialisation de la données
              ls_function_parameters_static-value_data = &lt;lfs_parameter_data&gt;.

            WHEN OTHERS.
              &quot; Cas structure complexe
              TRY.
                  &quot;&quot;  --&gt; Initialisation des données sous format XML
                  CALL TRANSFORMATION id
                               SOURCE data = &lt;lfs_parameter_data&gt;
                           RESULT XML ls_function_parameters_static-value_data_xml.

                CATCH cx_root INTO lo_cx_exception.      &quot;#EC CATCH_ALL
                  &quot; Erreur conversion en XML
                  &quot;&quot;  --&gt; Lève une exception
                  RAISE EXCEPTION TYPE zcx_task
                    EXPORTING
                      previous = lo_cx_exception.

              ENDTRY.

              IF NOT me-&gt;ms_task_data-data_compress_param IS INITIAL.
                &quot; Compression des données activée
                IF NOT lo_abap_zip IS BOUND.
                  &quot;&quot;  --&gt; Création instance Compression
                  CREATE OBJECT lo_abap_zip.
                  lo_abap_zip-&gt;support_unicode_names = abap_true.

                ENDIF.

                &quot;&quot;  --&gt; Ajout de la données dans dossier compression
                lo_abap_zip-&gt;add(
                    name    = &lt;lfs_s_function_parameters&gt;-parameter_name
                    content = ls_function_parameters_static-value_data_xml
                ).

                &quot;&quot;  --&gt; Suivant le type de compression
                CASE abap_true.

                  WHEN me-&gt;ms_task_data-data_compress_param-data_compress_line_by_line.
                    &quot; Compression à la ligne
                    &quot;&quot;  --&gt; Récupération données compressées
                    ls_function_parameters_static-value_data_xml = lo_abap_zip-&gt;save( ).

                    &quot;&quot;  --&gt; Initialisation indicateur données compressées ligne à ligne
                    ls_function_parameters_static-value_is_compressed_local = abap_true.

                    &quot;&quot;  --&gt; Libération instance Compression
                    FREE : lo_abap_zip.

                  WHEN me-&gt;ms_task_data-data_compress_param-data_compress_global.
                    &quot; Compression globale
                    &quot;&quot;  --&gt; Libération contenu données
                    FREE : ls_function_parameters_static-value_data_xml.

                    &quot;&quot;  --&gt; Initialisation indicateur données compressées globale
                    ls_function_parameters_static-value_is_compressed_global = abap_true.

                  WHEN OTHERS.
                    &quot; Autres

                ENDCASE.      &quot;Fin test Type de Compression

              ENDIF.          &quot;Fin test Compression données active

          ENDCASE.            &quot;Fin test Type de Paramètre (DDIC)

        CATCH cx_root INTO lo_cx_exception.              &quot;#EC CATCH_ALL
          &quot; Une erreur est survenue
          &quot;&quot;  --&gt; Lève une exception
          RAISE EXCEPTION TYPE zcx_task
            EXPORTING
              previous = lo_cx_exception.

      ENDTRY.

    ENDIF.                &quot;Fin test Type de Paramètre (signature)

    &quot; Ajout du paramètre
    INSERT ls_function_parameters_static INTO TABLE rt_function_parameters_static.

  ENDLOOP.

  &quot; -----------------------------------------------------------
  &quot; Post-Traitement
  &quot; -----------------------------------------------------------

  IF me-&gt;ms_task_data-data_compress_param-data_compress_global EQ abap_true.
    &quot; Donneés compressées au global
    &quot;&quot;  --&gt; Réstitution du dossier de compression
    ev_function_data_compressed = lo_abap_zip-&gt;save( ).

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_DYNAMIC_PARAM_METH" VERSION="1" LANGU="F" DESCRIPT="Méthode - Conversion données Dyn --&gt; Stat" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_DYNAMIC_PARAM_METH" SCONAME="IT_FUNCTION_PARAMETERS_DYNAMIC" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_FUNCTION_PARAMETERS"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_DYNAMIC_PARAM_METH" SCONAME="EV_FUNCTION_DATA_COMPRESSED" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="XSTRING"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_DYNAMIC_PARAM_METH" SCONAME="RT_FUNCTION_PARAMETERS_STATIC" VERSION="1" LANGU="F" DESCRIPT="Type de table paramètre d&apos;appel Statique" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTEC_T_FUNCTION_PARAMETERS"/>
   <exception CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_DYNAMIC_PARAM_METH" SCONAME="ZCX_TASK" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD _convert_dynamic_param_meth.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : _CONVERT_DYNAMIC_PARAM_METH                       *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Convertis les données des paramètres &quot;dynamique&quot;  *
*                    en données &quot;statiques&quot;                            *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lot_table TYPE REF TO data.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_function_parameters_static TYPE ztec_s_function_parameters.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
      lo_data TYPE REF TO data.

  DATA :
    lo_abap_zip        TYPE REF TO cl_abap_zip,
    lo_cx_exception    TYPE REF TO cx_root,
    lo_type_definition TYPE REF TO zcl_type_definition.

  DATA :
    lo_typedescr  TYPE REF TO cl_abap_typedescr,
    lo_datadescr  TYPE REF TO cl_abap_datadescr,
    lo_tabledescr TYPE REF TO cl_abap_tabledescr.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_parameter_data&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE  : rt_function_parameters_static.
  CLEAR : ev_function_data_compressed.

  IF it_function_parameters_dynamic[] IS INITIAL.
    &quot; Rien à  traiter
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Pré-Traitement
  &quot; -----------------------------------------------------------

  IF NOT me-&gt;ms_task_data-data_compress_param IS INITIAL.
    &quot; Activation de la Compression globale ou Ligne par Ligne
    &quot;&quot;  --&gt; Création instance de Compression
    CREATE OBJECT lo_abap_zip.
    lo_abap_zip-&gt;support_unicode_names = abap_true.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Transforme données en paramètre statique
  &quot; -----------------------------------------------------------

  &quot; Parcours l&apos;ensemble des paramètres &quot;dynamiques&quot;
  LOOP AT it_function_parameters_dynamic ASSIGNING FIELD-SYMBOL(&lt;lfs_s_function_parameters&gt;).

    CLEAR    : ls_function_parameters_static, lo_tabledescr, lo_typedescr, lo_datadescr.
    UNASSIGN : &lt;lfs_parameter_data&gt;.

    &quot; Initialisation Nom du Paramètre
    ls_function_parameters_static-parameter_name = &lt;lfs_s_function_parameters&gt;-parameter_name.

    &quot; Récupération données du paramètre
    READ TABLE zcl_task=&gt;ms_persistent_data-t_seosubcodf
    WITH TABLE KEY clsname = me-&gt;ms_task_data-task_process-task_call_process-class_name
                   cmpname = me-&gt;ms_task_data-task_process-task_call_process-method_name
                   sconame = CONV seosubcodf-sconame( &lt;lfs_s_function_parameters&gt;-parameter_name )
         ASSIGNING FIELD-SYMBOL(&lt;lfs_s_seosubcodf&gt;).
    IF sy-subrc NE 0.
      &quot; Paramètre inexistant
      &quot;&quot;  --&gt; Passe à l&apos;itération suivante
      CONTINUE.

    ENDIF.

    IF NOT &lt;lfs_s_seosubcodf&gt;-scotype IS INITIAL.
      &quot; Il s&apos;agit d&apos;une Exception
      &quot;&quot;  --&gt; Passe à l&apos;itération suivante
      CONTINUE.

    ENDIF.

    TRY.
        &quot; Initialisation type du paramètre
        ls_function_parameters_static-parameter_kind = SWITCH string( &lt;lfs_s_seosubcodf&gt;-pardecltyp
          WHEN &apos;0&apos; THEN cl_abap_objectdescr=&gt;exporting      &quot;#EC NOTEXT
          WHEN &apos;1&apos; THEN cl_abap_objectdescr=&gt;importing      &quot;#EC NOTEXT
          WHEN &apos;2&apos; THEN cl_abap_objectdescr=&gt;changing       &quot;#EC NOTEXT
          WHEN &apos;3&apos; THEN cl_abap_objectdescr=&gt;returning      &quot;#EC NOTEXT
          ELSE THROW cx_sy_arg_out_of_domain( )
        ).

      CATCH cx_sy_arg_out_of_domain.
        &quot; Autre valeur
        &quot;&quot;  --&gt; Passe à  l&apos;itération suivante
        CONTINUE.

    ENDTRY.

    &quot; Récupération définition type du paramètre
    cl_abap_typedescr=&gt;describe_by_name(
      EXPORTING
        p_name         = &lt;lfs_s_seosubcodf&gt;-type
      RECEIVING
        p_descr_ref    = lo_typedescr
      EXCEPTIONS
        type_not_found = 1
        OTHERS         = 2
    ).
    IF sy-subrc NE 0.
      &quot; Une erreur est survenue (cas du &quot;ANY TABLE&quot; par exemple)
      CLEAR : lo_typedescr.

    ENDIF.

    IF &lt;lfs_s_function_parameters&gt;-parameter_data IS BOUND.
      &quot; Initialisation pointeur sur les données
      ASSIGN &lt;lfs_s_function_parameters&gt;-parameter_data-&gt;* TO &lt;lfs_parameter_data&gt;.

    ENDIF.

    &quot; Traitement cas particulier des types génériques
    READ TABLE zcl_task=&gt;ms_persistent_data-t_generic_type_list WITH KEY name = &lt;lfs_s_seosubcodf&gt;-type
                                          TRANSPORTING NO FIELDS BINARY SEARCH.
    IF sy-subrc EQ 0 OR NOT lo_typedescr IS BOUND OR lo_typedescr-&gt;is_ddic_type( ) EQ abap_false.
      &quot; Type générique ou pas du dictionnaire
      &quot;&quot;  --&gt; Contrôle supplémentaire
      IF  NOT &lt;lfs_parameter_data&gt; IS ASSIGNED
      AND &lt;lfs_s_function_parameters&gt;-type_for_none_ddic_parameter IS INITIAL.
        &quot; Aucun moyen de déterminer le type
        &quot;&quot;  --&gt; Force la provocation d&apos;un DUMP
        MESSAGE x005(ztask) WITH me-&gt;ms_task_data-task_id &lt;lfs_s_function_parameters&gt;-parameter_name.

      ELSEIF NOT &lt;lfs_s_function_parameters&gt;-type_for_none_ddic_parameter IS INITIAL.
        &quot; Type transmis
        &quot;&quot;  --&gt; Récupération descriptino du Type
        cl_abap_typedescr=&gt;describe_by_name(
          EXPORTING
            p_name         = &lt;lfs_s_function_parameters&gt;-type_for_none_ddic_parameter
          RECEIVING
            p_descr_ref    = lo_typedescr
          EXCEPTIONS
            type_not_found = 1
            OTHERS         = 2
        ).
        IF sy-subrc NE 0.
          &quot; Type non défini dans le RTTS
          &quot;&quot;  --&gt; Aucun moyen de déterminer le type // Force la provocation d&apos;un DUMP
          MESSAGE x005(ztask) WITH me-&gt;ms_task_data-task_id &lt;lfs_s_function_parameters&gt;-parameter_name.

        ENDIF.

      ELSEIF &lt;lfs_parameter_data&gt; IS ASSIGNED.
        &quot; Données transmises
        &quot;&quot;  --&gt; Récupération description des données
        lo_typedescr = cl_abap_typedescr=&gt;describe_by_data( &lt;lfs_parameter_data&gt; ).

      ELSE.
        &quot; Nous n&apos;irons jamais ici, mais au moins il est présent
        &quot;&quot;  --&gt; Force la provocation d&apos;un DUMP
        MESSAGE x005(ztask) WITH me-&gt;ms_task_data-task_id &lt;lfs_s_function_parameters&gt;-parameter_name.

      ENDIF.

      IF lo_typedescr-&gt;is_ddic_type( ) EQ abap_false.
        &quot; Type non présent dans le dictionnaire
        &quot;&quot;  --&gt; Utilisation SHM pour stockage du Type
        TRY.
            IF NOT lo_type_definition IS BOUND.
              &quot; Récupération de l&apos;instance courante
              lo_type_definition = zcl_type_definition=&gt;get_instance( ).

            ENDIF.

            IF lo_type_definition IS BOUND.
              &quot; Ajout de la définition
              lo_type_definition-&gt;definition_type_add( io_definition = lo_typedescr ).

              IF me-&gt;ms_task_data-shm_manage_by_manager EQ abap_true
              OR zcl_task_param=&gt;task_param_get( me-&gt;ms_task_data-task_process-task_call_process )-shm_management EQ abap_true.
                TRY.
                    &quot; -----------------------------------------------------------
                    &quot; Enregistre l&apos;ID Manager de Tâche dans la SHM
                    &quot; -----------------------------------------------------------

                    &quot; Ajout de l&apos;ID du Manager de Tâche
                    zcl_task_shm=&gt;get_instance( lo_typedescr-&gt;absolute_name )-&gt;task_manager_register( me-&gt;ms_task_data-task_manager_id ).

                    &quot; Ajout du Type dans la Liste stocké en SHM
                    APPEND lo_typedescr-&gt;absolute_name TO me-&gt;ms_task_data-task_process-t_definition_type_in_shm.

                  CATCH cx_root.          &quot;#EC CATCH_ALL #EC NO_HANDLER
                    &quot; Erreur lors de l&apos;ajout dans la SHM

                ENDTRY.

                &quot; Initialisation Indicateur Gestion Local de la SHM
                me-&gt;ms_task_data-shm_manage_by_local = abap_true.

              ENDIF.

            ENDIF.

          CATCH cx_root.                  &quot;#EC CATCH_ALL #EC NO_HANDLER
            &quot; Une erreur est survenue lors de l&apos;utilisation de la mémoire partagée

        ENDTRY.

      ENDIF.        &quot;Fin test Type DDIC

    ENDIF.          &quot;Fin test type générique

    &quot; Initialisation type (ABAP) de données
    ls_function_parameters_static-value_kind = lo_typedescr-&gt;kind.

    &quot; Initialisation Type
    ls_function_parameters_static-value_type = lo_typedescr-&gt;absolute_name.

    IF ls_function_parameters_static-parameter_kind NE cl_abap_objectdescr=&gt;importing.
      &quot; Paramètre &lt;&gt; Import
      IF NOT &lt;lfs_parameter_data&gt; IS ASSIGNED.
        &quot; Pas de données
        &quot;&quot;  --&gt; Création container données vide
        lo_datadescr ?= lo_typedescr.
        CREATE DATA lo_data TYPE HANDLE lo_datadescr.
        ASSIGN lo_data-&gt;* TO &lt;lfs_parameter_data&gt;.

      ENDIF.

      TRY.
          &quot;&quot;  --&gt; Suivant son type (Table / Structure / Référence / Autres ...)
          CASE lo_typedescr-&gt;kind.

            WHEN cl_abap_typedescr=&gt;kind_elem.
              &quot; Elementaire
              &quot;&quot;  --&gt; Initialisation de la données
              ls_function_parameters_static-value_data = &lt;lfs_parameter_data&gt;.

            WHEN OTHERS.
              &quot; Cas structure complexe
              TRY.
                  &quot;&quot;  --&gt; Initialisation des données sous format XML
                  CALL TRANSFORMATION id
                               SOURCE data = &lt;lfs_parameter_data&gt;
                           RESULT XML ls_function_parameters_static-value_data_xml.

                CATCH cx_root INTO lo_cx_exception.      &quot;#EC CATCH_ALL
                  &quot; Erreur conversion en XML
                  &quot;&quot;  --&gt; Lève une exception
                  RAISE EXCEPTION TYPE zcx_task
                    EXPORTING
                      previous = lo_cx_exception.

              ENDTRY.

              IF NOT me-&gt;ms_task_data-data_compress_param IS INITIAL.
                &quot; Compression des données activée
                IF NOT lo_abap_zip IS BOUND.
                  &quot;&quot;  --&gt; Création instance Compression
                  CREATE OBJECT lo_abap_zip.
                  lo_abap_zip-&gt;support_unicode_names = abap_true.

                ENDIF.

                &quot;&quot;  --&gt; Ajout de la données dans dossier compression
                lo_abap_zip-&gt;add(
                    name    = &lt;lfs_s_function_parameters&gt;-parameter_name
                    content = ls_function_parameters_static-value_data_xml
                ).

                &quot;&quot;  --&gt; Suivant le type de compression
                CASE abap_true.

                  WHEN me-&gt;ms_task_data-data_compress_param-data_compress_line_by_line.
                    &quot; Compression à la ligne
                    &quot;&quot;  --&gt; Récupération données compressées
                    ls_function_parameters_static-value_data_xml = lo_abap_zip-&gt;save( ).

                    &quot;&quot;  --&gt; Initialisation indicateur données compressées ligne à ligne
                    ls_function_parameters_static-value_is_compressed_local = abap_true.

                    &quot;&quot;  --&gt; Libération instance Compression
                    FREE : lo_abap_zip.

                  WHEN me-&gt;ms_task_data-data_compress_param-data_compress_global.
                    &quot; Compression globale
                    &quot;&quot;  --&gt; Libération contenu données
                    FREE : ls_function_parameters_static-value_data_xml.

                    &quot;&quot;  --&gt; Initialisation indicateur données compressées globale
                    ls_function_parameters_static-value_is_compressed_global = abap_true.

                  WHEN OTHERS.
                    &quot; Autres

                ENDCASE.      &quot;Fin test Type de Compression

              ENDIF.          &quot;Fin test Compression données active

          ENDCASE.            &quot;Fin test Type de Paramètre (DDIC)

        CATCH cx_root INTO lo_cx_exception.
          &quot; Une erreur est survenue
          &quot;&quot;  --&gt; Lève l&apos;Exception
          RAISE EXCEPTION TYPE zcx_task
            EXPORTING
              previous = lo_cx_exception.

      ENDTRY.

    ENDIF.                &quot;Fin test Type de Paramètre (signature)

    &quot; Ajout du paramètre
    INSERT ls_function_parameters_static INTO TABLE rt_function_parameters_static.

  ENDLOOP.

  &quot; -----------------------------------------------------------
  &quot; Post-Traitement
  &quot; -----------------------------------------------------------

  IF me-&gt;ms_task_data-data_compress_param-data_compress_global EQ abap_true.
    &quot; Donneés compressées au global
    &quot;&quot;  --&gt; Réstitution du dossier de compression
    ev_function_data_compressed = lo_abap_zip-&gt;save( ).

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_DYNAMIC_PARAM_REPID" VERSION="1" LANGU="F" DESCRIPT="Programme - Conversion données Dyn --&gt; Stat" EXPOSURE="0" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_DYNAMIC_PARAM_REPID" SCONAME="IT_FUNCTION_PARAMETERS_DYNAMIC" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_FUNCTION_PARAMETERS"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_DYNAMIC_PARAM_REPID" SCONAME="EV_FUNCTION_DATA_COMPRESSED" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="XSTRING"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_DYNAMIC_PARAM_REPID" SCONAME="RT_FUNCTION_PARAMETERS_STATIC" VERSION="1" LANGU="F" DESCRIPT="Type de table paramètre d&apos;appel Statique" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTEC_T_FUNCTION_PARAMETERS"/>
   <exception CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_DYNAMIC_PARAM_REPID" SCONAME="ZCX_TASK" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD _convert_dynamic_param_repid.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : _CONVERT_DYNAMIC_PARAM_FUNC                       *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Convertis les données des paramètres &quot;dynamique&quot;  *
*                    en données &quot;statiques&quot;                            *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lot_table TYPE REF TO data.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_function_parameters_static TYPE ztec_s_function_parameters.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_abap_zip     TYPE REF TO cl_abap_zip,
    lo_cx_exception TYPE REF TO cx_root.

  DATA :
    lo_typedescr TYPE REF TO cl_abap_typedescr.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_parameter_data&gt; TYPE any.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
        lv_subrc TYPE sy-subrc.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE  : rt_function_parameters_static.
  CLEAR : ev_function_data_compressed.

  IF it_function_parameters_dynamic[] IS INITIAL.
    &quot; Rien à  traiter
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Pré-Traitement
  &quot; -----------------------------------------------------------

  IF NOT me-&gt;ms_task_data-data_compress_param IS INITIAL.
    &quot; Activation de la Compression globale ou Ligne par Ligne
    &quot;&quot;  --&gt; Création instance de Compression
    CREATE OBJECT lo_abap_zip.
    lo_abap_zip-&gt;support_unicode_names = abap_true.

  ENDIF.

  &quot; Récupération données du Programme
  READ TABLE zcl_task=&gt;ms_persistent_data-t_repid_selection_screen
  WITH TABLE KEY repid = me-&gt;ms_task_data-task_process-task_call_process-repid_name
       ASSIGNING FIELD-SYMBOL(&lt;lfs_s_repid_selection_screen&gt;).
  IF sy-subrc NE 0.
    &quot; Aucune correspondance
    &quot;&quot;  --&gt; Arrêt du Traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Transforme données en paramètre statique
  &quot; -----------------------------------------------------------

  &quot; Parcours l&apos;ensemble des paramètres &quot;dynamiques&quot;
  LOOP AT it_function_parameters_dynamic ASSIGNING FIELD-SYMBOL(&lt;lfs_s_function_parameters&gt;).

    CLEAR    : ls_function_parameters_static, lo_typedescr.
    UNASSIGN : &lt;lfs_parameter_data&gt;.

    &quot; Initialisation Nom du Paramètre
    ls_function_parameters_static-parameter_name = &lt;lfs_s_function_parameters&gt;-parameter_name.

    IF &lt;lfs_s_function_parameters&gt;-parameter_data IS BOUND.
      &quot; Initialisation pointeur sur les données
      ASSIGN &lt;lfs_s_function_parameters&gt;-parameter_data-&gt;* TO &lt;lfs_parameter_data&gt;.

    ENDIF.

    IF &lt;lfs_parameter_data&gt; IS ASSIGNED.
      &quot; Données transmises
      &quot;&quot;  --&gt; Récupération description des données
      lo_typedescr = cl_abap_typedescr=&gt;describe_by_data( &lt;lfs_parameter_data&gt; ).

    ELSE.
      &quot; Erreur assignation pointeur données
      &quot;&quot;  --&gt; Force la provocation d&apos;un DUMP
      MESSAGE x005(ztask) WITH me-&gt;ms_task_data-task_id &lt;lfs_s_function_parameters&gt;-parameter_name.

    ENDIF.

    IF &lt;lfs_s_function_parameters&gt;-parameter_name CS zif_task_constant=&gt;mc_parameter_name_repid_prefix.
      &quot; Paramètres d&apos;Appel
      CASE &lt;lfs_s_function_parameters&gt;-parameter_name.

        WHEN zif_task_constant=&gt;mc_parameter_name_variant.
          &quot; Variante
          &quot;&quot;  --&gt; Contrôle l&apos;existence de la Variante
          CALL FUNCTION &apos;RS_VARIANT_EXISTS&apos;
            EXPORTING
              report              = CONV rsvar-report( me-&gt;ms_task_data-task_process-task_call_process-repid_name )
              variant             = CONV rsvar-variant( &lt;lfs_parameter_data&gt; )
            IMPORTING
              r_c                 = lv_subrc
            EXCEPTIONS
              not_authorized      = 1
              no_report           = 2
              report_not_existent = 3
              report_not_supplied = 4
              error_message       = 5
              OTHERS              = 6.
          IF sy-subrc GT 1.
            &quot; Une erreur est survenue
            &quot;&quot;  --&gt; Lève une Exception
            RAISE EXCEPTION TYPE zcx_task
              EXPORTING
                textid = VALUE #( msgid = sy-msgid msgno = sy-msgno
                                  attr1 = sy-msgv1 attr2 = sy-msgv2
                                  attr3 = sy-msgv3 attr4 = sy-msgv4 ).

          ELSEIF lv_subrc NE 0.
            &quot; La Variante n&apos;existe pas
            RAISE EXCEPTION TYPE zcx_task
              EXPORTING
                textid = VALUE #( msgid = &apos;/ASU/GENERAL&apos; &quot;#EC NOTEXT
                                  msgno = 096 &quot;#EC NOTEXT
                                  attr1 = me-&gt;ms_task_data-task_process-task_call_process-repid_name
                                  attr2 = &lt;lfs_parameter_data&gt; ).
          ENDIF.

        WHEN OTHERS.
          &quot; Autres

      ENDCASE.

    ELSE.
      IF &lt;lfs_s_repid_selection_screen&gt;-no_data EQ abap_false.
        &quot; Valeurs Ecran de Sélection
        &quot;&quot;  --&gt; Contrôle et récupération Type de Paramètre
        READ TABLE &lt;lfs_s_repid_selection_screen&gt;-t_field_info WITH KEY name = &lt;lfs_s_function_parameters&gt;-parameter_name
                                                              ASSIGNING FIELD-SYMBOL(&lt;lfs_s_field_info&gt;)
                                                                 BINARY SEARCH.
        IF sy-subrc NE 0.
          &quot; Aucune correspondance
          &quot;&quot;  --&gt; Passe à l&apos;itération suivante
          CONTINUE.

        ENDIF.

        &quot;&quot;  --&gt; Initialisation données dépendantes
        ls_function_parameters_static-parameter_kind = &lt;lfs_s_field_info&gt;-kind.

      ENDIF.

    ENDIF.

    &quot; Initialisation type (ABAP) de données
    ls_function_parameters_static-value_kind = lo_typedescr-&gt;kind.

    &quot; Initialisation Type
    ls_function_parameters_static-value_type = lo_typedescr-&gt;absolute_name.

    TRY.
        &quot;&quot;  --&gt; Suivant son type (Table / Structure / Référence / Autres ...)
        CASE lo_typedescr-&gt;kind.

          WHEN cl_abap_typedescr=&gt;kind_elem.
            &quot; Elementaire
            &quot;&quot;  --&gt; Initialisation de la données
            ls_function_parameters_static-value_data = &lt;lfs_parameter_data&gt;.

          WHEN OTHERS.
            &quot; Cas structure complexe
            TRY.
                &quot;&quot;  --&gt; Initialisation des données sous format XML
                CALL TRANSFORMATION id
                             SOURCE data = &lt;lfs_parameter_data&gt;
                         RESULT XML ls_function_parameters_static-value_data_xml.

              CATCH cx_root INTO lo_cx_exception.        &quot;#EC CATCH_ALL
                &quot; Erreur conversion en XML
                &quot;&quot;  --&gt; Lève une exception
                RAISE EXCEPTION TYPE zcx_task
                  EXPORTING
                    previous = lo_cx_exception.

            ENDTRY.

            IF NOT me-&gt;ms_task_data-data_compress_param IS INITIAL.
              &quot; Compression des données activée
              IF NOT lo_abap_zip IS BOUND.
                &quot;&quot;  --&gt; Création instance Compression
                CREATE OBJECT lo_abap_zip.
                lo_abap_zip-&gt;support_unicode_names = abap_true.

              ENDIF.

              &quot;&quot;  --&gt; Ajout de la données dans dossier compression
              lo_abap_zip-&gt;add(
                  name    = &lt;lfs_s_function_parameters&gt;-parameter_name
                  content = ls_function_parameters_static-value_data_xml
              ).

              &quot;&quot;  --&gt; Suivant le type de compression
              CASE abap_true.

                WHEN me-&gt;ms_task_data-data_compress_param-data_compress_line_by_line.
                  &quot; Compression à la ligne
                  &quot;&quot;  --&gt; Récupération données compressées
                  ls_function_parameters_static-value_data_xml = lo_abap_zip-&gt;save( ).

                  &quot;&quot;  --&gt; Initialisation indicateur données compressées ligne à ligne
                  ls_function_parameters_static-value_is_compressed_local = abap_true.

                  &quot;&quot;  --&gt; Libération instance Compression
                  FREE : lo_abap_zip.

                WHEN me-&gt;ms_task_data-data_compress_param-data_compress_global.
                  &quot; Compression globale
                  &quot;&quot;  --&gt; Libération contenu données
                  FREE : ls_function_parameters_static-value_data_xml.

                  &quot;&quot;  --&gt; Initialisation indicateur données compressées globale
                  ls_function_parameters_static-value_is_compressed_global = abap_true.

                WHEN OTHERS.
                  &quot; Autres

              ENDCASE.      &quot;Fin test Type de Compression

            ENDIF.          &quot;Fin test Compression données active

        ENDCASE.            &quot;Fin test Type de Paramètre (DDIC)

      CATCH cx_root INTO lo_cx_exception.
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Lève l&apos;Exception
        RAISE EXCEPTION TYPE zcx_task
          EXPORTING
            previous = lo_cx_exception.

    ENDTRY.

    &quot; Ajout du paramètre
    INSERT ls_function_parameters_static INTO TABLE rt_function_parameters_static.

  ENDLOOP.

  &quot; -----------------------------------------------------------
  &quot; Post-Traitement
  &quot; -----------------------------------------------------------

  IF me-&gt;ms_task_data-data_compress_param-data_compress_global EQ abap_true.
    &quot; Donneés compressées au global
    &quot;&quot;  --&gt; Réstitution du dossier de compression
    ev_function_data_compressed = lo_abap_zip-&gt;save( ).

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_STATIC_PARAM_FUNC" VERSION="1" LANGU="F" DESCRIPT="Module Fonction - Conversion données Stat --&gt; Dyn" EXPOSURE="0" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_STATIC_PARAM_FUNC" SCONAME="IT_FUNCTION_PARAMETERS_STATIC" VERSION="1" LANGU="F" DESCRIPT="Type de table paramètre d&apos;appel Statique" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_T_FUNCTION_PARAMETERS"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_STATIC_PARAM_FUNC" SCONAME="IV_FUNCTION_DATA_COMPRESSED" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSTRING"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_STATIC_PARAM_FUNC" SCONAME="RT_FUNCTION_PARAMETERS_DYNAMIC" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_FUNCTION_PARAMETERS"/>
   <source>METHOD _CONVERT_STATIC_PARAM_FUNC.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : _CONVERT_STATIC_PARAM_FUNC                        *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Convertis les données des paramètres &quot;statiques&quot;  *
*                    en données &quot;dynamiques&quot;                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_function_parameters_dynamic TYPE zif_task_constant=&gt;ts_function_parameters.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_abap_zip TYPE REF TO cl_abap_zip.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
        lv_data_decompress TYPE xstring.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_value&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : rt_function_parameters_dynamic.

  IF it_function_parameters_static[] IS INITIAL.
    &quot; Rien à  traiter
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Pré-Traitement
  &quot; -----------------------------------------------------------

  IF NOT iv_function_data_compressed IS INITIAL.
    &quot; Données compressées
    &quot;&quot;  --&gt; Chargement dossier compressées
    CREATE OBJECT lo_abap_zip.
    lo_abap_zip-&gt;support_unicode_names = abap_true.
    lo_abap_zip-&gt;load(
      EXPORTING
        zip             = iv_function_data_compressed
      EXCEPTIONS
        zip_parse_error = 1
        OTHERS          = 2
    ).
    IF sy-subrc NE 0.
      &quot; Une erreur est survenue // Les données sont illisibles
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Conversion des données statiques en dynamique
  &quot; -----------------------------------------------------------

  LOOP AT it_function_parameters_static ASSIGNING FIELD-SYMBOL(&lt;lfs_s_function_parameters&gt;).

    CLEAR : ls_function_parameters_dynamic.

    &quot; Initialisation du Nom du paramètre
    ls_function_parameters_dynamic-parameter_name = &lt;lfs_s_function_parameters&gt;-parameter_name.

    &quot; Initialisation des données typées
    IF &lt;lfs_s_function_parameters&gt;-parameter_kind NE zif_task_constant=&gt;mc_parameter_kind_tables.
      &quot; Paramètre &lt;&gt; Table
      CREATE DATA ls_function_parameters_dynamic-parameter_data TYPE (&lt;lfs_s_function_parameters&gt;-value_type).

    ELSE.
      &quot; Paramètre type table
      CREATE DATA ls_function_parameters_dynamic-parameter_data TYPE STANDARD TABLE OF (&lt;lfs_s_function_parameters&gt;-value_type).

    ENDIF.

    &quot; Initialisation pointeur sur les données
    ASSIGN ls_function_parameters_dynamic-parameter_data-&gt;* TO &lt;lfs_value&gt;.

    IF &lt;lfs_s_function_parameters&gt;-value_is_compressed_global EQ abap_true
    OR NOT &lt;lfs_s_function_parameters&gt;-value_data_xml         IS INITIAL.
      &quot; Données &quot;complexe&quot; stockées sous forme XML
      &quot;&quot;  --&gt; Suivant méthode de compression
      CASE abap_true.

        WHEN &lt;lfs_s_function_parameters&gt;-value_is_compressed_local.
          &quot; Compression ligne à ligne
          &quot;&quot;  --&gt; Création instance compression
          CREATE OBJECT lo_abap_zip.
          lo_abap_zip-&gt;support_unicode_names = abap_true.

          &quot;&quot;  --&gt; Lecture dossier compressé
          lo_abap_zip-&gt;load(
            EXPORTING
              zip             = &lt;lfs_s_function_parameters&gt;-value_data_xml
            EXCEPTIONS
              zip_parse_error = 1
              OTHERS          = 2
          ).
          IF sy-subrc EQ 0.
            &quot; Aucune erreur
            &quot;&quot;  --&gt; Récupération données décompressées
            lo_abap_zip-&gt;get(
              EXPORTING
                index                   = 1
              IMPORTING
                content                 = lv_data_decompress
              EXCEPTIONS
                zip_index_error         = 1
                zip_decompression_error = 2
                OTHERS                  = 3
            ).

          ENDIF.
          IF sy-subrc NE 0.
            &quot; Une erreur est survenue
            &quot;&quot;  --&gt; Réinitialisation données
            CLEAR : lv_data_decompress.

          ENDIF.

        WHEN &lt;lfs_s_function_parameters&gt;-value_is_compressed_global.
          &quot; Compression globale
          &quot;&quot;  --&gt; Décompression des données
          lo_abap_zip-&gt;get(
            EXPORTING
              name                    = CONV string( &lt;lfs_s_function_parameters&gt;-parameter_name )
            IMPORTING
              content                 = lv_data_decompress
            EXCEPTIONS
              zip_index_error         = 1
              zip_decompression_error = 2
              OTHERS                  = 3
          ).
          IF sy-subrc NE 0.
            &quot; Une erreur est survenue
            &quot;&quot;  --&gt; Réinitialisation données
            CLEAR : lv_data_decompress.

          ENDIF.

        WHEN OTHERS.
          &quot; Autres
          &quot;&quot;  --&gt; Pas de décompression // Rien à faire
          lv_data_decompress = &lt;lfs_s_function_parameters&gt;-value_data_xml.

      ENDCASE.

      IF NOT lv_data_decompress IS INITIAL.
        &quot;&quot; --&gt; Restructuration des données
        CALL TRANSFORMATION id
                 SOURCE XML lv_data_decompress
                     RESULT data = &lt;lfs_value&gt;.

      ENDIF.

    ELSEIF NOT &lt;lfs_s_function_parameters&gt;-value_data IS INITIAL.
      &quot; Type Elémentaire
      &quot;&quot;  --&gt; Initialisation des données
      &lt;lfs_value&gt; = &lt;lfs_s_function_parameters&gt;-value_data.

    ELSE.                                                   &quot;#EC NEEDED
      &quot; Autre cas
      &quot;&quot;  --&gt; ToDo : Ajouter ici les autres cas

    ENDIF.

    &quot; Ajout de l&apos;entrée
    INSERT ls_function_parameters_dynamic INTO TABLE rt_function_parameters_dynamic.

  ENDLOOP.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_STATIC_PARAM_METH" VERSION="1" LANGU="F" DESCRIPT="Méthode - Conversion données Stat --&gt; Dyn" EXPOSURE="0" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_STATIC_PARAM_METH" SCONAME="IT_FUNCTION_PARAMETERS_STATIC" VERSION="1" LANGU="F" DESCRIPT="Type de table paramètre d&apos;appel Statique" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_T_FUNCTION_PARAMETERS"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_STATIC_PARAM_METH" SCONAME="IV_FUNCTION_DATA_COMPRESSED" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSTRING"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_STATIC_PARAM_METH" SCONAME="RT_FUNCTION_PARAMETERS_DYNAMIC" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_FUNCTION_PARAMETERS"/>
   <source>METHOD _convert_static_param_meth.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : _CONVERT_STATIC_PARAM_METH                        *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Convertis les données des paramètres &quot;statiques&quot;  *
*                    en données &quot;dynamiques&quot;                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_function_parameters_dynamic TYPE zif_task_constant=&gt;ts_function_parameters.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_abap_zip TYPE REF TO cl_abap_zip.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
        lv_data_decompress TYPE xstring.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_value&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : rt_function_parameters_dynamic.

  IF it_function_parameters_static[] IS INITIAL.
    &quot; Rien à  traiter
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Pré-Traitement
  &quot; -----------------------------------------------------------

  IF NOT iv_function_data_compressed IS INITIAL.
    &quot; Données compressées
    &quot;&quot;  --&gt; Chargement dossier compressées
    CREATE OBJECT lo_abap_zip.
    lo_abap_zip-&gt;support_unicode_names = abap_true.
    lo_abap_zip-&gt;load(
      EXPORTING
        zip             = iv_function_data_compressed
      EXCEPTIONS
        zip_parse_error = 1
        OTHERS          = 2
    ).
    IF sy-subrc NE 0.
      &quot; Une erreur est survenue // Les données sont illisibles
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Conversion des données statiques en dynamique
  &quot; -----------------------------------------------------------

  LOOP AT it_function_parameters_static ASSIGNING FIELD-SYMBOL(&lt;lfs_s_function_parameters&gt;).

    CLEAR : ls_function_parameters_dynamic.

    &quot; Initialisation du Nom du paramètre
    ls_function_parameters_dynamic-parameter_name = &lt;lfs_s_function_parameters&gt;-parameter_name.

    &quot; Initialisation des données typées
    CREATE DATA ls_function_parameters_dynamic-parameter_data TYPE (&lt;lfs_s_function_parameters&gt;-value_type).

    &quot; Initialisation pointeur sur les données
    ASSIGN ls_function_parameters_dynamic-parameter_data-&gt;* TO &lt;lfs_value&gt;.

    IF &lt;lfs_s_function_parameters&gt;-value_is_compressed_global EQ abap_true
    OR NOT &lt;lfs_s_function_parameters&gt;-value_data_xml         IS INITIAL.
      &quot; Données &quot;complexe&quot; stockées sous forme XML
      &quot;&quot;  --&gt; Suivant méthode de compression
      CASE abap_true.

        WHEN &lt;lfs_s_function_parameters&gt;-value_is_compressed_local.
          &quot; Compression ligne à ligne
          &quot;&quot;  --&gt; Création instance compression
          CREATE OBJECT lo_abap_zip.
          lo_abap_zip-&gt;support_unicode_names = abap_true.

          &quot;&quot;  --&gt; Lecture dossier compressé
          lo_abap_zip-&gt;load(
            EXPORTING
              zip             = &lt;lfs_s_function_parameters&gt;-value_data_xml
            EXCEPTIONS
              zip_parse_error = 1
              OTHERS          = 2
          ).
          IF sy-subrc EQ 0.
            &quot; Aucune erreur
            &quot;&quot;  --&gt; Récupération données décompressées
            lo_abap_zip-&gt;get(
              EXPORTING
                index                   = 1
              IMPORTING
                content                 = lv_data_decompress
              EXCEPTIONS
                zip_index_error         = 1
                zip_decompression_error = 2
                OTHERS                  = 3
            ).

          ENDIF.
          IF sy-subrc NE 0.
            &quot; Une erreur est survenue
            &quot;&quot;  --&gt; Réinitialisation données
            CLEAR : lv_data_decompress.

          ENDIF.

        WHEN &lt;lfs_s_function_parameters&gt;-value_is_compressed_global.
          &quot; Compression globale
          &quot;&quot;  --&gt; Décompression des données
          lo_abap_zip-&gt;get(
            EXPORTING
              name                    = CONV string( &lt;lfs_s_function_parameters&gt;-parameter_name )
            IMPORTING
              content                 = lv_data_decompress
            EXCEPTIONS
              zip_index_error         = 1
              zip_decompression_error = 2
              OTHERS                  = 3
          ).
          IF sy-subrc NE 0.
            &quot; Une erreur est survenue
            &quot;&quot;  --&gt; Réinitialisation données
            CLEAR : lv_data_decompress.

          ENDIF.

        WHEN OTHERS.
          &quot; Autres
          &quot;&quot;  --&gt; Pas de décompression // Rien à faire
          lv_data_decompress = &lt;lfs_s_function_parameters&gt;-value_data_xml.

      ENDCASE.

      IF NOT lv_data_decompress IS INITIAL.
        &quot;&quot; --&gt; Restructuration des données
        CALL TRANSFORMATION id
                 SOURCE XML lv_data_decompress
                     RESULT data = &lt;lfs_value&gt;.

      ENDIF.

    ELSEIF NOT &lt;lfs_s_function_parameters&gt;-value_data IS INITIAL.
      &quot; Type Elémentaire
      &quot;&quot;  --&gt; Initialisation des données
      &lt;lfs_value&gt; = &lt;lfs_s_function_parameters&gt;-value_data.

    ELSE.                                                   &quot;#EC NEEDED
      &quot; Autre cas
      &quot;&quot;  --&gt; ToDo : Ajouter ici les autres cas

    ENDIF.

    &quot; Ajout de l&apos;entrée
    INSERT ls_function_parameters_dynamic INTO TABLE rt_function_parameters_dynamic.

  ENDLOOP.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_STATIC_PARAM_REPID" VERSION="1" LANGU="F" DESCRIPT="Programme - Conversion données Stat --&gt; Dyn" EXPOSURE="0" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_STATIC_PARAM_REPID" SCONAME="IT_FUNCTION_PARAMETERS_STATIC" VERSION="1" LANGU="F" DESCRIPT="Type de table paramètre d&apos;appel Statique" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_T_FUNCTION_PARAMETERS"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_STATIC_PARAM_REPID" SCONAME="IV_FUNCTION_DATA_COMPRESSED" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSTRING"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="_CONVERT_STATIC_PARAM_REPID" SCONAME="RT_FUNCTION_PARAMETERS_DYNAMIC" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_FUNCTION_PARAMETERS"/>
   <source>METHOD _convert_static_param_repid.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : _CONVERT_STATIC_PARAM_REPID                       *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Convertis les données des paramètres &quot;statiques&quot;  *
*                    en données &quot;dynamiques&quot;                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_function_parameters_dynamic TYPE zif_task_constant=&gt;ts_function_parameters.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_abap_zip TYPE REF TO cl_abap_zip.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
        lv_data_decompress TYPE xstring.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_value&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : rt_function_parameters_dynamic.

  IF it_function_parameters_static[] IS INITIAL.
    &quot; Rien à  traiter
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Pré-Traitement
  &quot; -----------------------------------------------------------

  IF NOT iv_function_data_compressed IS INITIAL.
    &quot; Données compressées
    &quot;&quot;  --&gt; Chargement dossier compressées
    CREATE OBJECT lo_abap_zip.
    lo_abap_zip-&gt;support_unicode_names = abap_true.
    lo_abap_zip-&gt;load(
      EXPORTING
        zip             = iv_function_data_compressed
      EXCEPTIONS
        zip_parse_error = 1
        OTHERS          = 2
    ).
    IF sy-subrc NE 0.
      &quot; Une erreur est survenue // Les données sont illisibles
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Conversion des données statiques en dynamique
  &quot; -----------------------------------------------------------

  LOOP AT it_function_parameters_static ASSIGNING FIELD-SYMBOL(&lt;lfs_s_function_parameters&gt;).

    CLEAR : ls_function_parameters_dynamic.

    &quot; Initialisation du Nom du paramètre
    ls_function_parameters_dynamic-parameter_name = &lt;lfs_s_function_parameters&gt;-parameter_name.

    &quot; Initialisation des données typées
    CREATE DATA ls_function_parameters_dynamic-parameter_data TYPE (&lt;lfs_s_function_parameters&gt;-value_type).

    &quot; Initialisation pointeur sur les données
    ASSIGN ls_function_parameters_dynamic-parameter_data-&gt;* TO &lt;lfs_value&gt;.

    IF &lt;lfs_s_function_parameters&gt;-value_is_compressed_global EQ abap_true
    OR NOT &lt;lfs_s_function_parameters&gt;-value_data_xml         IS INITIAL.
      &quot; Données &quot;complexe&quot; stockées sous forme XML
      &quot;&quot;  --&gt; Suivant méthode de compression
      CASE abap_true.

        WHEN &lt;lfs_s_function_parameters&gt;-value_is_compressed_local.
          &quot; Compression ligne à ligne
          &quot;&quot;  --&gt; Création instance compression
          CREATE OBJECT lo_abap_zip.
          lo_abap_zip-&gt;support_unicode_names = abap_true.

          &quot;&quot;  --&gt; Lecture dossier compressé
          lo_abap_zip-&gt;load(
            EXPORTING
              zip             = &lt;lfs_s_function_parameters&gt;-value_data_xml
            EXCEPTIONS
              zip_parse_error = 1
              OTHERS          = 2
          ).
          IF sy-subrc EQ 0.
            &quot; Aucune erreur
            &quot;&quot;  --&gt; Récupération données décompressées
            lo_abap_zip-&gt;get(
              EXPORTING
                index                   = 1
              IMPORTING
                content                 = lv_data_decompress
              EXCEPTIONS
                zip_index_error         = 1
                zip_decompression_error = 2
                OTHERS                  = 3
            ).

          ENDIF.
          IF sy-subrc NE 0.
            &quot; Une erreur est survenue
            &quot;&quot;  --&gt; Réinitialisation données
            CLEAR : lv_data_decompress.

          ENDIF.

        WHEN &lt;lfs_s_function_parameters&gt;-value_is_compressed_global.
          &quot; Compression globale
          &quot;&quot;  --&gt; Décompression des données
          lo_abap_zip-&gt;get(
            EXPORTING
              name                    = CONV string( &lt;lfs_s_function_parameters&gt;-parameter_name )
            IMPORTING
              content                 = lv_data_decompress
            EXCEPTIONS
              zip_index_error         = 1
              zip_decompression_error = 2
              OTHERS                  = 3
          ).
          IF sy-subrc NE 0.
            &quot; Une erreur est survenue
            &quot;&quot;  --&gt; Réinitialisation données
            CLEAR : lv_data_decompress.

          ENDIF.

        WHEN OTHERS.
          &quot; Autres
          &quot;&quot;  --&gt; Pas de décompression // Rien à faire
          lv_data_decompress = &lt;lfs_s_function_parameters&gt;-value_data_xml.

      ENDCASE.

      IF NOT lv_data_decompress IS INITIAL.
        &quot;&quot; --&gt; Restructuration des données
        CALL TRANSFORMATION id
                 SOURCE XML lv_data_decompress
                     RESULT data = &lt;lfs_value&gt;.

      ENDIF.

    ELSEIF NOT &lt;lfs_s_function_parameters&gt;-value_data IS INITIAL.
      &quot; Type Elémentaire
      &quot;&quot;  --&gt; Initialisation des données
      &lt;lfs_value&gt; = &lt;lfs_s_function_parameters&gt;-value_data.

    ELSE.                                                   &quot;#EC NEEDED
      &quot; Autre cas
      &quot;&quot;  --&gt; ToDo : Ajouter ici les autres cas

    ENDIF.

    &quot; Ajout de l&apos;entrée
    INSERT ls_function_parameters_dynamic INTO TABLE rt_function_parameters_dynamic.

  ENDLOOP.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK" CMPNAME="__AT_END_OF_TASK" VERSION="1" LANGU="F" DESCRIPT="Traitement fin d&apos;une Tâche" EXPOSURE="0" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK" CMPNAME="__AT_END_OF_TASK" SCONAME="IT_TASK_RESULT" VERSION="1" LANGU="F" DESCRIPT="Type de table paramètre d&apos;appel Statique" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_T_FUNCTION_PARAMETERS" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TASK" CMPNAME="__AT_END_OF_TASK" SCONAME="IV_TASK_RESULT_DATA_COMPRESSED" VERSION="1" LANGU="F" DESCRIPT="Données compressées" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSTRING" PAROPTIONL="X"/>
   <source>METHOD __at_end_of_task.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __AT_END_OF_TASK                                  *
*&amp; Classe          : ZCL_TASK                                          *
*&amp; Description     : Traitement fin d&apos;une Tâche                        *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  IF NOT it_task_result[] IS INITIAL.
    &quot; -----------------------------------------------------------
    &quot; Conversion des paramètres statiques en dynamiques
    &quot; -----------------------------------------------------------

    &quot; Initialisation des paramètres de retour du MF
    me-&gt;ms_task_data-task_process-task_container-&gt;mt_function_parameters_output = me-&gt;convert_static_parameters(
      it_function_parameters_static = it_task_result
      iv_function_data_compressed   = iv_task_result_data_compressed
    ).

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Fin de la Tâche
  &quot; -----------------------------------------------------------

  me-&gt;task_stop( ).

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_TYPE_DEFINITION_CLUSTER" VERSION="1" LANGU="F" DESCRIPT="Définition de Type - Gestion Cluster - Exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_DYNAMIC_CHECK">
  <implementing CLSNAME="ZCX_TYPE_DEFINITION_CLUSTER" REFCLSNAME="IF_T100_MESSAGE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_TYPE_DEFINITION_CLUSTER" REFCLSNAME="CX_DYNAMIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_DYNAMIC_CHECK">
  <implementing CLSNAME="ZCX_TYPE_DEFINITION" REFCLSNAME="IF_T100_MESSAGE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_TYPE_DEFINITION" REFCLSNAME="CX_DYNAMIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_TASK_SHM" VERSION="1" LANGU="F" DESCRIPT="Tâche - SHM - Classe exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZTASK" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_DYNAMIC_CHECK">
  <implementing CLSNAME="ZCX_TASK_SHM" REFCLSNAME="IF_T100_MESSAGE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_TASK_SHM" REFCLSNAME="CX_DYNAMIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_TASK_MANAGER" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Manager Tâche" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZTASK" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_DYNAMIC_CHECK">
  <implementing CLSNAME="ZCX_TASK_MANAGER" REFCLSNAME="IF_T100_MESSAGE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_TASK_MANAGER" REFCLSNAME="CX_DYNAMIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_TASK_CALL" VERSION="1" LANGU="F" DESCRIPT="Tâche - Classe exception Appel" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZTASK" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_DYNAMIC_CHECK">
  <implementing CLSNAME="ZCX_TASK_CALL" REFCLSNAME="IF_T100_MESSAGE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_TASK_CALL" REFCLSNAME="CX_DYNAMIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_TASK" VERSION="1" LANGU="F" DESCRIPT="Classe Exception Tâche" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZTASK" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_DYNAMIC_CHECK">
  <implementing CLSNAME="ZCX_TASK" REFCLSNAME="IF_T100_MESSAGE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_TASK" REFCLSNAME="CX_DYNAMIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" VERSION="1" LANGU="F" DESCRIPT="Définition de type - SHM" CATEGORY="45" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" RSTAT="S" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CL_SHM_AREA">
  <friends CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" REFCLSNAME="CL_SHM_AREA" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros></localMacros>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="AREA_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of an Area Class" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="&apos;ZCL_TYPE_DEF_AREAHANDLE_AREA&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SHM_AREA_NAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ROOT" VERSION="1" LANGU="F" DESCRIPT="SHM: Model of a Data Class" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_TYPE_DEF_AREAHANDLE_ROOT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="_CLIENT_DEPENDENT" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="5 " ATTDECLTYP="2" ATTVALUE="ABAP_FALSE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="_LIFE_CONTEXT" VERSION="1" LANGU="F" DESCRIPT="Lifetime of an Area (Constants in CL_SHM_AREA)" EXPOSURE="0" STATE="1" EDITORDER="6 " ATTDECLTYP="2" ATTVALUE="CL_SHM_AREA=&gt;LIFE_CONTEXT_APPSERVER" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SHM_LIFE_CONTEXT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="_TRACE_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="(Internal) Flag: Trace Active?" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="1" ATTVALUE="ABAP_FALSE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="_TRACE_SERVICE" VERSION="1" LANGU="F" DESCRIPT="(Internal) Reference to Trace Class" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="3" TYPE="IF_SHM_TRACE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="_TRANSACTIONAL" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="2" ATTVALUE="ABAP_FALSE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="_VERSION_" VERSION="1" LANGU="F" DESCRIPT="(internal)" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="22" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" REFCLSNAME="CL_SHM_AREA" VERSION="1" STATE="1">
   <redefinition CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" REFCLSNAME="CL_SHM_AREA" VERSION="1" MTDNAME="GET_ROOT" EXPOSURE="0"/>
  </inheritance>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" VERSION="1" LANGU="F" DESCRIPT="Request a Read Lock" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="HANDLE" VERSION="1" LANGU="F" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TYPE_DEF_AREAHANDLE_AREA"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_INCONSISTENT" VERSION="1" LANGU="F" DESCRIPT="Different Definitions Between Program and Area" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_NO_ACTIVE_VERSION" VERSION="1" LANGU="F" DESCRIPT="No active version exists for an attach" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_READ_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Request for a Second Read Lock" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="5 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="A Change Lock Is Already Active" MTDTYPE="0" EDITORDER="6 "/>
   <source>method ATTACH_FOR_READ.

  DATA:
    l_attributes       TYPE shma_attributes,
    l_root             TYPE REF TO object,
    l_cx               TYPE REF TO cx_root,
    l_client           TYPE shm_client,
    l_client_supplied  TYPE abap_bool. &quot;#EC NEEDED

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.


  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_read = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

*   try sneak mode first
    handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                      sneak_mode   = abap_true
                                      life_context = _life_context
                            IMPORTING root         = l_root ).

    IF l_root IS INITIAL.
*     no root object returned, sneak mode was not successful.
*     -&gt; read area properties from database and try again.
      cl_shm_service=&gt;initialize(
        EXPORTING area_name       = handle-&gt;area_name
                  client          = l_client
        IMPORTING attributes      = l_attributes
      ).

      handle-&gt;properties = l_attributes-properties.
      handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                        sneak_mode   = abap_false
                                        life_context = _life_context
                              IMPORTING root         = l_root ).

    ENDIF.

    handle-&gt;root ?= l_root.
*   &lt;

  ELSE.

    TRY.

*       &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                          sneak_mode   = abap_true
                                          life_context = _life_context
                                IMPORTING root         = l_root ).

        IF l_root IS INITIAL.
*         no root object returned, sneak mode was not successful.
*         -&gt; read area properties from database and try again.
          cl_shm_service=&gt;initialize(
            EXPORTING area_name       = handle-&gt;area_name
                      client          = l_client
            IMPORTING attributes      = l_attributes
          ).

          handle-&gt;properties = l_attributes-properties.
          handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                            sneak_mode   = abap_false
                                            life_context = _life_context
                                  IMPORTING root         = l_root ).

        ENDIF.
        handle-&gt;root ?= l_root.

*       &lt;
        _trace_service-&gt;trin_attach_for_read(
          area_name = area_name
          inst_name = inst_name
          client    = l_client ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_read(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" VERSION="1" LANGU="F" DESCRIPT="Request a Change Lock" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="ATTACH_MODE" VERSION="1" LANGU="F" DESCRIPT="Mode of ATTACH (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_ATTACH_MODE" PARVALUE="CL_SHM_AREA=&gt;ATTACH_MODE_DEFAULT"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="WAIT_TIME" VERSION="1" LANGU="F" DESCRIPT="Maximum Wait Time (in Milliseconds)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="0"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="HANDLE" VERSION="1" LANGU="F" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TYPE_DEF_AREAHANDLE_AREA"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_INCONSISTENT" VERSION="1" LANGU="F" DESCRIPT="Different Definitions Between Program and Area" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_NO_ACTIVE_VERSION" VERSION="1" LANGU="F" DESCRIPT="No active version exists for an attach" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_VERSION_LIMIT_EXCEEDED" VERSION="1" LANGU="F" DESCRIPT="No Additional Versions Available" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="A write lock is already active" MTDTYPE="0" EDITORDER="5 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Passed Parameter Has Incorrect Value" MTDTYPE="0" EDITORDER="6 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_PENDING_LOCK_REMOVED" VERSION="1" LANGU="F" DESCRIPT="Shared Objects: Waiting Lock Was Deleted" MTDTYPE="0" EDITORDER="7 "/>
   <source>method ATTACH_FOR_UPDATE.

  DATA:
    l_attributes             TYPE shma_attributes,
    l_root                   TYPE REF TO object,
    l_cx                     TYPE REF TO cx_root,
    l_client                 TYPE shm_client,
    l_client_supplied        TYPE abap_bool, &quot;#EC NEEDED
    l_wait_time              TYPE i,
    l_wait_time_per_loop     TYPE i,
    l_wait_time_per_loop_sec TYPE f.

  l_wait_time = wait_time.

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.


  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_upd = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

    cl_shm_service=&gt;initialize(
      EXPORTING area_name    = handle-&gt;area_name
                client       = l_client
      IMPORTING attributes   = l_attributes
    ).

    handle-&gt;properties = l_attributes-properties.

    handle-&gt;_attach_update70(
      EXPORTING area_name = handle-&gt;area_name
                mode      = attach_mode
      IMPORTING root      = l_root
      CHANGING  wait_time = l_wait_time ).

    IF abap_true = l_attributes-properties-has_versions AND
       handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
      handle-&gt;_attach_update70(
        EXPORTING area_name = handle-&gt;area_name
                  mode      = attach_mode
        IMPORTING root      = l_root
        CHANGING  wait_time = l_wait_time ).
    ENDIF.

    IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
       handle-&gt;_lock IS INITIAL.

      l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
      IF l_wait_time_per_loop &lt; 2000.
        l_wait_time_per_loop = 2000.
      ELSEIF l_wait_time_per_loop &gt; 300000.
        l_wait_time_per_loop = 300000.
      ENDIF.

      l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

      WHILE handle-&gt;_lock IS INITIAL.

        IF l_wait_time_per_loop &gt; l_wait_time.
          l_wait_time_per_loop = l_wait_time.
          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
        ENDIF.

        WAIT UP TO l_wait_time_per_loop_sec SECONDS.
        l_wait_time = l_wait_time - l_wait_time_per_loop.

        handle-&gt;_attach_update70(
          EXPORTING area_name = handle-&gt;area_name
                    mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
          IMPORTING root      = l_root
          CHANGING  wait_time = l_wait_time ).

        IF abap_true = l_attributes-properties-has_versions AND
           handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
          handle-&gt;_attach_update70(
            EXPORTING area_name = handle-&gt;area_name
                      mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
            IMPORTING root      = l_root
            CHANGING  wait_time = l_wait_time ).
        ENDIF.

      ENDWHILE.

    ENDIF.

    handle-&gt;root ?= l_root.

*   &lt;

  ELSE.

    TRY.

*       &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        cl_shm_service=&gt;initialize(
          EXPORTING area_name    = handle-&gt;area_name
                    client       = l_client
          IMPORTING attributes   = l_attributes
        ).

        handle-&gt;properties = l_attributes-properties.

        handle-&gt;_attach_update70(
          EXPORTING area_name = handle-&gt;area_name
                    mode      = attach_mode
          IMPORTING root      = l_root
          CHANGING  wait_time = l_wait_time ).

        IF abap_true = l_attributes-properties-has_versions AND
           handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
          handle-&gt;_attach_update70(
            EXPORTING area_name = handle-&gt;area_name
                      mode      = attach_mode
            IMPORTING root      = l_root
            CHANGING  wait_time = l_wait_time ).
        ENDIF.

        IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
           handle-&gt;_lock IS INITIAL.

          l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
          IF l_wait_time_per_loop &lt; 2000.
            l_wait_time_per_loop = 2000.
          ELSEIF l_wait_time_per_loop &gt; 300000.
            l_wait_time_per_loop = 300000.
          ENDIF.

          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

          WHILE handle-&gt;_lock IS INITIAL.

            IF l_wait_time_per_loop &gt; l_wait_time.
              l_wait_time_per_loop = l_wait_time.
              l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
            ENDIF.

            WAIT UP TO l_wait_time_per_loop_sec SECONDS.
            l_wait_time = l_wait_time - l_wait_time_per_loop.

            handle-&gt;_attach_update70(
              EXPORTING
                area_name = handle-&gt;area_name
                mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
              IMPORTING
                root      = l_root
              CHANGING
                wait_time = l_wait_time ).

            IF abap_true = l_attributes-properties-has_versions AND
               handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
              handle-&gt;_attach_update70(
                EXPORTING
                  area_name = handle-&gt;area_name
                  mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
                IMPORTING
                  root      = l_root
                CHANGING
                  wait_time = l_wait_time ).
            ENDIF.

          ENDWHILE.

        ENDIF.

        handle-&gt;root ?= l_root.

*       &lt;
        _trace_service-&gt;trin_attach_for_update(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_update(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" VERSION="1" LANGU="F" DESCRIPT="Request a Write Lock" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="ATTACH_MODE" VERSION="1" LANGU="F" DESCRIPT="Mode of ATTACH (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_ATTACH_MODE" PARVALUE="CL_SHM_AREA=&gt;ATTACH_MODE_DEFAULT"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="WAIT_TIME" VERSION="1" LANGU="F" DESCRIPT="Maximum Wait Time (in Milliseconds)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="0"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="HANDLE" VERSION="1" LANGU="F" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TYPE_DEF_AREAHANDLE_AREA"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_VERSION_LIMIT_EXCEEDED" VERSION="1" LANGU="F" DESCRIPT="No Additional Versions Available" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="A write lock is already active" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Passed Parameter Has Incorrect Value" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_PENDING_LOCK_REMOVED" VERSION="1" LANGU="F" DESCRIPT="Shared Objects: Waiting Lock Was Deleted" MTDTYPE="0" EDITORDER="5 "/>
   <source>method ATTACH_FOR_WRITE.

  DATA:
    l_attributes             TYPE shma_attributes,
    l_cx                     TYPE REF TO cx_root,
    l_client                 TYPE shm_client,
    l_client_supplied        TYPE abap_bool, &quot;#EC NEEDED
    l_wait_time              TYPE i,
    l_wait_time_per_loop     TYPE i,
    l_wait_time_per_loop_sec TYPE f.

  l_wait_time = wait_time.

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.


  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_write = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

    cl_shm_service=&gt;initialize(
      EXPORTING area_name    = handle-&gt;area_name
                client       = l_client
      IMPORTING attributes   = l_attributes
    ).

    handle-&gt;properties = l_attributes-properties.

    handle-&gt;_attach_write70(
      EXPORTING
        area_name = handle-&gt;area_name
        mode      = attach_mode
      CHANGING
        wait_time = l_wait_time ).

    IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
       handle-&gt;_lock IS INITIAL.

      l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
      IF l_wait_time_per_loop &lt; 2000.
        l_wait_time_per_loop = 2000.
      ELSEIF l_wait_time_per_loop &gt; 300000.
        l_wait_time_per_loop = 300000.
      ENDIF.

      l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

      WHILE handle-&gt;_lock IS INITIAL.

        IF l_wait_time_per_loop &gt; l_wait_time.
          l_wait_time_per_loop = l_wait_time.
          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
        ENDIF.

        WAIT UP TO l_wait_time_per_loop_sec SECONDS.
        l_wait_time = l_wait_time - l_wait_time_per_loop.

        handle-&gt;_attach_write70(
          EXPORTING
            area_name = handle-&gt;area_name
            mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
          CHANGING
            wait_time = l_wait_time ).

      ENDWHILE.

    ENDIF.

*   &lt;

  ELSE.

    TRY.

*     &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        cl_shm_service=&gt;initialize(
          EXPORTING area_name    = handle-&gt;area_name
                    client       = l_client
          IMPORTING attributes   = l_attributes
        ).

        handle-&gt;properties = l_attributes-properties.

        handle-&gt;_attach_write70(
          EXPORTING
            area_name = handle-&gt;area_name
            mode      = attach_mode
          CHANGING
            wait_time = l_wait_time ).

        IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
           handle-&gt;_lock IS INITIAL.

          l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
          IF l_wait_time_per_loop &lt; 2000.
            l_wait_time_per_loop = 2000.
          ELSEIF l_wait_time_per_loop &gt; 300000.
            l_wait_time_per_loop = 300000.
          ENDIF.

          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

          WHILE handle-&gt;_lock IS INITIAL.

            IF l_wait_time_per_loop &gt; l_wait_time.
              l_wait_time_per_loop = l_wait_time.
              l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
            ENDIF.

            WAIT UP TO l_wait_time_per_loop_sec SECONDS.
            l_wait_time = l_wait_time - l_wait_time_per_loop.

            handle-&gt;_attach_write70(
              EXPORTING
                area_name = handle-&gt;area_name
                mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
              CHANGING
                wait_time = l_wait_time ).

          ENDWHILE.

        ENDIF.

*     &lt;

        _trace_service-&gt;trin_attach_for_write(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
        ).
      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_write(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="BUILD" VERSION="1" LANGU="F" DESCRIPT="Direct Call of Area Constructor" EXPOSURE="2" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="BUILD" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="BUILD" SCONAME="CX_SHMA_NOT_CONFIGURED" VERSION="1" LANGU="F" DESCRIPT="SHM Administration: Area Property Is Not Configured" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="BUILD" SCONAME="CX_SHMA_INCONSISTENT" VERSION="1" LANGU="F" DESCRIPT="SHM Administration: Inconsistent Attribute Combination" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="BUILD" SCONAME="CX_SHM_BUILD_FAILED" VERSION="1" LANGU="F" DESCRIPT="Constructor Run Failed" MTDTYPE="0" EDITORDER="3 "/>
   <source>method BUILD.

  DATA:
    l_cls_name TYPE shm_auto_build_class_name,
    l_cx TYPE REF TO cx_root.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-build = abap_false.

*   &gt;
    l_cls_name =
      cl_shm_service=&gt;get_auto_build_class_name( area_name ).

    CALL METHOD (l_cls_name)=&gt;if_shm_build_instance~build
      EXPORTING
        inst_name = inst_name.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        l_cls_name =
          cl_shm_service=&gt;get_auto_build_class_name( area_name ).

        CALL METHOD (l_cls_name)=&gt;if_shm_build_instance~build
          EXPORTING
            inst_name = inst_name.
*       &lt;
        _trace_service-&gt;trin_build(
          area_name         = area_name
          inst_name         = inst_name
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_build(
          area_name         = area_name
          inst_name         = inst_name
          cx                = l_cx
        ).
    ENDTRY.

  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="CLASS_CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CLASS_CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <source>method CLASS_CONSTRUCTOR.

* TRACE { DO NOT REMOVE THIS LINE !
  _trace_active = abap_false.
  TRY.
      _trace_service =
        cl_shm_service=&gt;trace_get_service( area_name ).
      IF NOT _trace_service IS INITIAL.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      ENDIF.
    CATCH cx_root. &quot;#EC NO_HANDLER
                   &quot;#EC CATCH_ALL
  ENDTRY.
* TRACE } DO NOT REMOVE THIS LINE !

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="DETACH_AREA" VERSION="1" LANGU="F" DESCRIPT="Release all locks on all instances" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="DETACH_AREA" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <source>method DETACH_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.


* &gt;
  rc = _detach_area71( area_name        = area_name
                       client           = l_client
                       client_supplied  = l_client_supplied
                       client_dependent = _client_dependent
                       life_context     = _life_context
       ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-detach_area = abap_true.
      _trace_service-&gt;trin_detach_area(
        area_name = area_name
        client    = l_client
        rc        = rc
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_AREA" VERSION="1" LANGU="F" DESCRIPT="Delete all instances" EXPOSURE="2" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_AREA" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="F" DESCRIPT="Writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_AREA" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_AREA" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method FREE_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.


* &gt;
  rc = _free_area71( area_name         = area_name
                     client            = l_client
                     client_supplied   = l_client_supplied
                     client_dependent  = _client_dependent
                     transactional     = _transactional
                     terminate_changer = terminate_changer
                     affect_server     = affect_server
                     life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-free_area = abap_true.
      _trace_service-&gt;trin_free_area(
      area_name         = area_name
      client            = l_client
      terminate_changer = terminate_changer
      affect_server     = affect_server
      rc                = rc
    ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="Deletion of an Instance" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_INSTANCE" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_INSTANCE" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="F" DESCRIPT="Writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_INSTANCE" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="FREE_INSTANCE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method FREE_INSTANCE.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.


* &gt;
  rc = _free_instance71( area_name         = area_name
                         inst_name         = inst_name
                         client            = l_client
                         client_supplied   = l_client_supplied
                         client_dependent  = _client_dependent
                         transactional     = _transactional
                         terminate_changer = terminate_changer
                         affect_server     = affect_server
                         life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-free_instance = abap_true.
      _trace_service-&gt;trin_free_instance(
        area_name         = area_name
        inst_name         = inst_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="GET_GENERATOR_VERSION" VERSION="1" LANGU="F" DESCRIPT="Query Generator Version" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="GET_GENERATOR_VERSION" SCONAME="GENERATOR_VERSION" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
   <source>method GET_GENERATOR_VERSION.
  generator_version = _version_.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="GET_INSTANCE_INFOS" VERSION="1" LANGU="F" DESCRIPT="Returns the names of all instances" EXPOSURE="2" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="GET_INSTANCE_INFOS" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance in an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="GET_INSTANCE_INFOS" SCONAME="INFOS" VERSION="1" LANGU="F" DESCRIPT="Overview of all Instances of an SHM Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_INST_INFOS"/>
   <source>method GET_INSTANCE_INFOS.

  DATA:
    l_client             TYPE shm_client,
    l_client_supplied    TYPE abap_bool VALUE abap_false,
    l_inst_name_supplied TYPE abap_bool VALUE abap_false.


  IF inst_name IS SUPPLIED.
    l_inst_name_supplied = abap_true.
  ENDIF.

* &gt;
  TRY.
      CALL METHOD (&apos;_GET_INSTANCE_INFOS804&apos;)
        EXPORTING
          area_name          = area_name
          client             = l_client
          client_supplied    = l_client_supplied
          client_dependent   = _client_dependent
          life_context       = _life_context
          inst_name          = inst_name
          inst_name_supplied = l_inst_name_supplied
        RECEIVING
          infos              = infos.
    CATCH cx_sy_dyn_call_illegal_method.
*     New kernel and/or new basis SP missing -&gt; use slow fallback
      infos = _get_instance_infos71(
                area_name        = area_name
                client           = l_client
                client_supplied  = l_client_supplied
                client_dependent = _client_dependent
                life_context     = _life_context
              ).
      IF abap_true = l_inst_name_supplied.
        DELETE infos WHERE name &lt;&gt; inst_name.
      ENDIF.
  ENDTRY.
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-get_instance_inf = abap_true.
      _trace_service-&gt;trin_get_instance_infos(
        area_name         = area_name
        client            = l_client
        infos             = infos
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="CL_SHM_AREA" CMPNAME="GET_ROOT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method GET_ROOT.

  DATA:
    l_cx        TYPE REF TO cx_root,
    l_area_name TYPE string,
    l_inst_name TYPE string,
    l_client    TYPE string.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-get_root = abap_false.

*   &gt;
    IF is_valid( ) = abap_false.
      l_area_name = me-&gt;area_name.
      l_inst_name = me-&gt;inst_name.
      l_client    = me-&gt;client.
      RAISE EXCEPTION TYPE cx_shm_already_detached
        EXPORTING
          area_name = l_area_name
          inst_name = l_inst_name
          client    = l_client.
    ENDIF.
    root = me-&gt;root.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        IF is_valid( ) = abap_false.
          l_area_name = me-&gt;area_name.
          l_inst_name = me-&gt;inst_name.
          l_client    = me-&gt;client.
          RAISE EXCEPTION TYPE cx_shm_already_detached
            EXPORTING
              area_name = l_area_name
              inst_name = l_inst_name
              client    = l_client.
        ENDIF.
        root = me-&gt;root.
*       &lt;

        _trace_service-&gt;trin_get_root(
          area_name = area_name
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_get_root(
          area_name = area_name
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_AREA" VERSION="1" LANGU="F" DESCRIPT="Active versions of all instances will be set to obsolete" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="F" DESCRIPT="Active writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method INVALIDATE_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.


* &gt;
  rc = _invalidate_area71( area_name         = area_name
                           client            = l_client
                           client_supplied   = l_client_supplied
                           client_dependent  = _client_dependent
                           transactional     = _transactional
                           terminate_changer = terminate_changer
                           affect_server     = affect_server
                           life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-invalidate_area = abap_true.
      _trace_service-&gt;trin_invalidate_area(
        area_name         = area_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="Active version of one instance will be set to obsolete" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="F" DESCRIPT="Active writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method INVALIDATE_INSTANCE.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool value abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.


* &gt;
  rc = _invalidate_instance71(
    area_name         = area_name
    inst_name         = inst_name
    client            = l_client
    client_supplied   = l_client_supplied
    client_dependent  = _client_dependent
    transactional     = _transactional
    terminate_changer = terminate_changer
    affect_server     = affect_server
    life_context      = _life_context
  ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-invalidate_inst = abap_true.
      _trace_service-&gt;trin_invalidate_instance(
        area_name         = area_name
        inst_name         = inst_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="SET_ROOT" VERSION="1" LANGU="F" DESCRIPT="Sets Root Objects" EXPOSURE="2" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="SET_ROOT" SCONAME="ROOT" VERSION="1" LANGU="F" DESCRIPT="Root object" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_TYPE_DEF_AREAHANDLE_ROOT"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="SET_ROOT" SCONAME="CX_SHM_INITIAL_REFERENCE" VERSION="1" LANGU="F" DESCRIPT="Initial Reference Passed" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_AREA" CMPNAME="SET_ROOT" SCONAME="CX_SHM_WRONG_HANDLE" VERSION="1" LANGU="F" DESCRIPT="Incorrect Handle" MTDTYPE="0" EDITORDER="2 "/>
   <source>method SET_ROOT.

  DATA:
    l_cx TYPE REF TO cx_root.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-set_root = abap_false.

*   &gt;
    _set_root( root ).
    me-&gt;root = root.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        _set_root( root ).
        me-&gt;root = root.
*       &lt;
        _trace_service-&gt;trin_set_root(
          area_name         = area_name
          inst_name         = inst_name
          root              = root
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_set_root(
          area_name         = area_name
          inst_name         = inst_name
          root              = root
          cx                = l_cx
        ).
    ENDTRY.

  ENDIF.

  endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" VERSION="1" LANGU="F" DESCRIPT="Définition de Type - Gestion Cluster" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="TY_DEFINITION_TYPE_ID" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="7 " SRCCOLUMN2="33 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_definition_type_id,
      id TYPE zclust_type_def-srtfd,
      type TYPE string,
    END OF   ty_definition_type_id
"/>
  <types CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="TY_T_DEFINITION_TYPE_ID" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="4 " SRCROW2="10 " SRCCOLUMN2="54 " TYPESRC_LENG="0 " TYPESRC="ty_t_definition_type_id TYPE SORTED TABLE OF ty_definition_type_id
        WITH NON-UNIQUE KEY primary_key COMPONENTS type
"/>
  <types CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="TY_COMPONENTS_INTERN" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="4 " SRCROW2="14 " SRCCOLUMN2="32 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_components_intern,
      name         TYPE string,
      type         TYPE string,
      position     TYPE int4,
      subtype_guid TYPE sysuuid_c32,
    END OF   ty_components_intern
"/>
  <types CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="TY_T_COMPONENTS_INTERN" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="16 " SRCCOLUMN1="4 " SRCROW2="17 " SRCCOLUMN2="66 " TYPESRC_LENG="0 " TYPESRC="ty_t_components_intern TYPE STANDARD TABLE OF ty_components_intern
                    WITH NON-UNIQUE KEY primary_key COMPONENTS name
"/>
  <types CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="TY_TYPE_DEFINITION" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="19 " SRCCOLUMN1="4 " SRCROW2="29 " SRCCOLUMN2="30 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_type_definition,
      __type_intern               TYPE string,
      type                        TYPE string,
      kind                        TYPE abap_typecategory,
      table_kind                  TYPE abap_tablekind,
      table_key                   TYPE abap_table_keydescr_tab,
      t_components_intern         TYPE ty_t_components_intern,
      rowkind                     TYPE typekind,
      __type_intern_parent        TYPE string,
      __type_intern_parent_higher TYPE string,
    END OF   ty_type_definition
"/>
  <types CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="TY_T_TYPE_DEFINITION" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="31 " SRCCOLUMN1="4 " SRCROW2="33 " SRCCOLUMN2="109 " TYPESRC_LENG="0 " TYPESRC="ty_t_type_definition TYPE SORTED TABLE OF ty_type_definition
                                  WITH UNIQUE KEY primary_key COMPONENTS __type_intern
                                  WITH NON-UNIQUE SORTED KEY second_key COMPONENTS __type_intern_parent_higher
"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="MT_TYPE_DEFINITION_ID" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_T_DEFINITION_TYPE_ID" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="DEFINITION_ADD" VERSION="1" LANGU="F" DESCRIPT="Cluster - Définition Type - Ajout" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="DEFINITION_ADD" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="DEFINITION_ADD" SCONAME="IT_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition de Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_TYPE_DEFINITION"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="DEFINITION_ADD" SCONAME="RV_GUID" VERSION="1" LANGU="F" DESCRIPT="Définition de Type - ID Cluster" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTYPE_DEFINITION_GUID"/>
   <exception CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="DEFINITION_ADD" SCONAME="ZCX_TYPE_DEFINITION_CLUSTER" VERSION="1" LANGU="F" DESCRIPT="Définition de Type - Gestion Cluster - Exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD definition_add.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_ADD                                    *
*&amp; Classe          : ZCL_TYPE_DEFINITION_CLUSTER                       *
*&amp; Description     : Ajout définition de Type                          *
*                    dans Cluster &quot;ZCLUST_TYPE_DEF&quot;                    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle
  &quot; -----------------------------------------------------------

  IF iv_type IS INITIAL
  OR it_type_definition[] IS INITIAL.
    &quot; Aucune données récupérées
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Ajout de la Définition du Type dans le Cluster
      &quot; -----------------------------------------------------------

      &quot; Ajout de la Définition du Type
      rv_guid = zcl_type_definition_cluster=&gt;__definition_add(
          iv_type            = iv_type
          it_type_definition = it_type_definition
      ).

    CATCH zcx_type_definition_cluster INTO DATA(lo_cx_exception).
      &quot; Erreur conversion en XML
      &quot;&quot;  --&gt; Lève une exception
      RAISE EXCEPTION TYPE zcx_type_definition_cluster
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="DEFINITION_DEL" VERSION="1" LANGU="F" DESCRIPT="Cluster - Définition Type - Suppression" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="DEFINITION_DEL" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="DEFINITION_DEL" SCONAME="RV_DELETED" VERSION="1" LANGU="F" DESCRIPT="Supprimé du Cluster ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN"/>
   <exception CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="DEFINITION_DEL" SCONAME="ZCX_TYPE_DEFINITION_CLUSTER" VERSION="1" LANGU="F" DESCRIPT="Définition de Type - Gestion Cluster - Exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD definition_del.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_DEL                                    *
*&amp; Classe          : ZCL_TYPE_DEFINITION_CLUSTER                       *
*&amp; Description     : Suppression définition de Type Stocké             *
*                    dans Cluster &quot;ZCLUST_TYPE_DEF&quot;                    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Suppression de la Définition du Type dans le Cluster
      &quot; -----------------------------------------------------------

      &quot; Suppression de la Définition du Type
      rv_deleted = zcl_type_definition_cluster=&gt;__definition_del(
          iv_guid = zcl_type_definition_cluster=&gt;__definition_id_get( iv_type )
      ).

    CATCH zcx_type_definition_cluster INTO DATA(lo_cx_exception).
      &quot; Erreur conversion en XML
      &quot;&quot;  --&gt; Lève une exception
      RAISE EXCEPTION TYPE zcx_type_definition_cluster
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="DEFINITION_GET" VERSION="1" LANGU="F" DESCRIPT="Cluster - Définition Type - Récupération" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="DEFINITION_GET" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="DEFINITION_GET" SCONAME="RT_DEFINITION_TYPE" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_T_TYPE_DEFINITION"/>
   <exception CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="DEFINITION_GET" SCONAME="ZCX_TYPE_DEFINITION_CLUSTER" VERSION="1" LANGU="F" DESCRIPT="Définition de Type - Gestion Cluster - Exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD definition_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_GET                                    *
*&amp; Classe          : ZCL_TYPE_DEFINITION_CLUSTER                       *
*&amp; Description     : Récupération définition de Type Stocké            *
*                    dans Cluster &quot;ZCLUST_TYPE_DEF&quot;                    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Charge la définition depuis le Cluster
      &quot; -----------------------------------------------------------

      &quot; Récupération de la Définition du Type
      rt_definition_type = zcl_type_definition_cluster=&gt;__definition_get(
        iv_guid = zcl_type_definition_cluster=&gt;__definition_id_get( iv_type )
      ).

    CATCH zcx_type_definition_cluster INTO DATA(lo_cx_exception).
      &quot; Une erreur est survenue lors de la récupération du Type
      &quot;&quot;  --&gt; Lève une Exception
      RAISE EXCEPTION TYPE zcx_type_definition_cluster
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="__DEFINITION_ADD" VERSION="1" LANGU="F" DESCRIPT="Internal Use : Cluster - Définition Type - Ajout" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="__DEFINITION_ADD" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="__DEFINITION_ADD" SCONAME="IT_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition de Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_TYPE_DEFINITION"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="__DEFINITION_ADD" SCONAME="RV_GUID" VERSION="1" LANGU="F" DESCRIPT="Définition de Type - ID Cluster" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTYPE_DEFINITION_GUID"/>
   <exception CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="__DEFINITION_ADD" SCONAME="ZCX_TYPE_DEFINITION_CLUSTER" VERSION="1" LANGU="F" DESCRIPT="Définition de Type - Gestion Cluster - Exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD __definition_add.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __DEFINITION_ADD                                  *
*&amp; Classe          : ZCL_TYPE_DEFINITION_CLUSTER                       *
*&amp; Description     : Ajout définition de Type                          *
*                    dans Cluster &quot;ZCLUST_TYPE_DEF&quot;                    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_textid             TYPE scx_t100key,
    ls_clust_type_def     TYPE zclust_type_def,
    ls_type_definition_id TYPE ty_definition_type_id.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_cx_exception TYPE REF TO cx_root.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_type_definition_xml     TYPE xstring,
    lv_type_definition_xml_zip TYPE xstring.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle
  &quot; -----------------------------------------------------------

  IF  iv_type IS INITIAL
  AND it_type_definition[] IS INITIAL.
    &quot; Aucune données à ajouter dans le Cluster
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Sérialization du Type et Compression
      &quot; -----------------------------------------------------------

      &quot; Sérialization de la définition du type
      CALL TRANSFORMATION id
                   SOURCE data = it_type_definition
               RESULT XML lv_type_definition_xml.

    CATCH cx_root INTO lo_cx_exception.
      &quot; Erreur conversion en XML
      &quot;&quot;  --&gt; Lève une exception
      RAISE EXCEPTION TYPE zcx_type_definition_cluster
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Compression de la définition du Type
      &quot; -----------------------------------------------------------

      &quot; Création nouvelle instance
      DATA(lo_abap_zip) = NEW cl_abap_zip( ).
      lo_abap_zip-&gt;support_unicode_names = abap_true.

      &quot; Ajout du Type
      lo_abap_zip-&gt;add(
          name    = CONV string( iv_type )
          content = lv_type_definition_xml
      ).

      &quot; Compression
      lv_type_definition_xml_zip = lo_abap_zip-&gt;save( ).

      &quot; Initialisation indiquant que les données sont compressées
      ls_clust_type_def-is_compressed = abap_true.

    CATCH cx_root.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Utilisation de la version non compressées des données
      CLEAR : ls_clust_type_def-is_compressed.
      lv_type_definition_xml_zip = lv_type_definition_xml.

  ENDTRY.

  IF NOT lv_type_definition_xml_zip IS INITIAL.
    &quot; -----------------------------------------------------------
    &quot; Charge la définition dans le Cluster
    &quot; -----------------------------------------------------------

    &quot; Initialisation données
    ls_clust_type_def-mandt     = sy-mandt.
    ls_clust_type_def-uname     = sy-uname.
    ls_clust_type_def-type_def  = ls_type_definition_id-type = iv_type.
    ls_clust_type_def-data_size = xstrlen( lv_type_definition_xml_zip ).
    GET TIME STAMP FIELD ls_clust_type_def-timestamp.

    TRY.
        &quot; Génération ID Unique
        ls_type_definition_id-id = ls_clust_type_def-srtfd = rv_guid = cl_system_uuid=&gt;create_uuid_c32_static( ).

      CATCH cx_uuid_error.
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Génération nombre aléatoire
        ls_type_definition_id-id = ls_clust_type_def-srtfd = rv_guid = cl_abap_random=&gt;seed( ).

    ENDTRY.

    &quot; Ajout du lien entre le Type et l&apos;ID
    INSERT ls_type_definition_id INTO TABLE zcl_type_definition_cluster=&gt;mt_type_definition_id.

    TRY.
        &quot; Export de la définition du Type
        EXPORT type_definition_xml = lv_type_definition_xml_zip
            TO DATABASE zclust_type_def(td)
                   FROM ls_clust_type_def
                     ID ls_clust_type_def-srtfd.

      CATCH cx_root INTO lo_cx_exception.
        &quot; Erreur conversion en XML
        &quot;&quot;  --&gt; Lève une exception
        RAISE EXCEPTION TYPE zcx_type_definition_cluster
          EXPORTING
            previous = lo_cx_exception.

    ENDTRY.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="__DEFINITION_DEL" VERSION="1" LANGU="F" DESCRIPT="Internal Use : Cluster - Définition Type - Suppression" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="__DEFINITION_DEL" SCONAME="IV_GUID" VERSION="1" LANGU="F" DESCRIPT="Définition de Type - ID Cluster" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTYPE_DEFINITION_GUID"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="__DEFINITION_DEL" SCONAME="RV_DELETED" VERSION="1" LANGU="F" DESCRIPT="Supprimé du Cluster ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN"/>
   <exception CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="__DEFINITION_DEL" SCONAME="ZCX_TYPE_DEFINITION_CLUSTER" VERSION="1" LANGU="F" DESCRIPT="Définition de Type - Gestion Cluster - Exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD __DEFINITION_DEL.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __DEFINITION_DEL                                  *
*&amp; Classe          : ZCL_TYPE_DEFINITION_CLUSTER                       *
*&amp; Description     : Suppression définition de Type Stocké             *
*                    dans Cluster &quot;ZCLUST_TYPE_DEF&quot;                    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Suppression de la définition du Type
      &quot; -----------------------------------------------------------

      &quot; Suppression de la Définition du Type dans Cluster
      DELETE FROM DATABASE zclust_type_def(td) ID iv_guid.
      rv_deleted = xsdbool( sy-subrc EQ 0 ).

      &quot; Suppression du lien Type --&gt; ID
      DELETE zcl_type_definition_cluster=&gt;mt_type_definition_id WHERE id EQ iv_guid.

    CATCH cx_root INTO DATA(lo_cx_exception).
      &quot; Une erreur est survenue lors de la suppression
      RAISE EXCEPTION TYPE zcx_type_definition
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="__DEFINITION_GET" VERSION="1" LANGU="F" DESCRIPT="Internal Use : Cluster - Définition Type - Récupération" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="__DEFINITION_GET" SCONAME="IV_GUID" VERSION="1" LANGU="F" DESCRIPT="Définition de Type - ID Cluster" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTYPE_DEFINITION_GUID"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="__DEFINITION_GET" SCONAME="RT_DEFINITION_TYPE" VERSION="1" LANGU="F" DESCRIPT="Définition de Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_T_TYPE_DEFINITION"/>
   <exception CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="__DEFINITION_GET" SCONAME="ZCX_TYPE_DEFINITION_CLUSTER" VERSION="1" LANGU="F" DESCRIPT="Définition de Type - Gestion Cluster - Exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD __DEFINITION_GET.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __DEFINITION_GET                                  *
*&amp; Classe          : ZCL_TYPE_DEFINITION_CLUSTER                       *
*&amp; Description     : Récupération définition de Type Stocké            *
*                    dans Cluster &quot;ZCLUST_TYPE_DEF&quot;                    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_textid         TYPE scx_t100key,
    ls_clust_type_def TYPE zclust_type_def.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_cx_exception TYPE REF TO cx_root.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_type_definition_xml TYPE xstring.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Charge la définition depuis le Cluster
      &quot; -----------------------------------------------------------

      &quot; Import de la définition du Type
      IMPORT type_definition_xml = lv_type_definition_xml
        FROM DATABASE zclust_type_def(td)
                   TO ls_clust_type_def
                   ID iv_guid.
      IF sy-subrc NE 0.
        &quot; Le Type n&apos;existe pas
        &quot;&quot;  --&gt; Arrêt du traitement
        RETURN.

      ENDIF.

      IF ls_clust_type_def-is_compressed EQ abap_true.
        &quot; -----------------------------------------------------------
        &quot; Décompression de la définition du Type
        &quot; -----------------------------------------------------------

        &quot; Création nouvelle instance
        DATA(lo_abap_zip) = NEW cl_abap_zip( ).
        lo_abap_zip-&gt;support_unicode_names = abap_true.

        &quot; Chargement dossier compressée
        lo_abap_zip-&gt;load(
          EXPORTING
            zip             = lv_type_definition_xml
          EXCEPTIONS
            zip_parse_error = 1
            OTHERS          = 2
        ).
        IF sy-subrc EQ 0.
          &quot; Décompression
          lo_abap_zip-&gt;get(
            EXPORTING
              index                   = 1
            IMPORTING
              content                 = lv_type_definition_xml
            EXCEPTIONS
              zip_index_error         = 1
              zip_decompression_error = 2
              OTHERS                  = 3
          ).

        ENDIF.
        IF sy-subrc NE 0.
          &quot; Une erreur est survenue
          &quot;&quot;  --&gt; Lève une exception
          ls_textid-msgid = sy-msgid.
          ls_textid-msgno = sy-msgno.
          ls_textid-attr1 = sy-msgv1. ls_textid-attr2 = sy-msgv2.
          ls_textid-attr1 = sy-msgv3. ls_textid-attr2 = sy-msgv3.
          RAISE EXCEPTION TYPE zcx_type_definition_cluster
            EXPORTING
              textid = ls_textid.

        ENDIF.

      ENDIF.

      &quot; -----------------------------------------------------------
      &quot; Désérialization du Type
      &quot; -----------------------------------------------------------

      &quot; Désérialization du Type
      CALL TRANSFORMATION id
               SOURCE XML lv_type_definition_xml
                   RESULT data = rt_definition_type.

    CATCH cx_root INTO lo_cx_exception.
      &quot; Une erreur est survenue lors de la récupération du Type
      &quot;&quot;  --&gt; Lève une Exception
      RAISE EXCEPTION TYPE zcx_type_definition_cluster
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="__DEFINITION_ID_GET" VERSION="1" LANGU="F" DESCRIPT="Internal Use : Cluster - Définition Type - ID - Récupération" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="__DEFINITION_ID_GET" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="__DEFINITION_ID_GET" SCONAME="RV_GUID" VERSION="1" LANGU="F" DESCRIPT="GUID Définition Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SYSUUID_C32"/>
   <exception CLSNAME="ZCL_TYPE_DEFINITION_CLUSTER" CMPNAME="__DEFINITION_ID_GET" SCONAME="ZCX_TYPE_DEFINITION_CLUSTER" VERSION="1" LANGU="F" DESCRIPT="Définition de Type - Gestion Cluster - Exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD __definition_id_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __DEFINITION_ID_GET                               *
*&amp; Classe          : ZCL_TYPE_DEFINITION_CLUSTER                       *
*&amp; Description     : Récupération ID Définition de Type Stocké         *
*                    dans Cluster &quot;ZCLUST_TYPE_DEF&quot;                    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_textid             TYPE scx_t100key,
    ls_type_definition_id TYPE ty_definition_type_id.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération ID Type
  &quot; -----------------------------------------------------------

  TRY.
      &quot; Récupération ID Type (Buffer)
      rv_guid = zcl_type_definition_cluster=&gt;mt_type_definition_id[ type = iv_type ]-id.

    CATCH cx_sy_itab_line_not_found.
      &quot; Aucune correspondance
      &quot;&quot;  --&gt; Recherche en DB
      SELECT SINGLE srtfd, type_def FROM zclust_type_def
                                   WHERE type_def EQ @iv_type
                                    INTO @ls_type_definition_id.
      IF sy-subrc NE 0.
        &quot; Aucune correspondance en DB
        &quot;&quot;  --&gt; Lève une Exception
        ls_textid-msgid = &apos;CACSBAS&apos;.                        &quot;#EC NOTEXT
        ls_textid-msgno = 303.
        ls_textid-attr1 = iv_type.
        RAISE EXCEPTION TYPE zcx_type_definition_cluster
          EXPORTING
            textid = ls_textid.

      ELSE.
        &quot; Correspondance trouvée en DB
        &quot;&quot;  --&gt; Ajout dans la table Buffer
        INSERT ls_type_definition_id INTO TABLE zcl_type_definition_cluster=&gt;mt_type_definition_id.

        &quot; Retourne l&apos;ID
        rv_guid = ls_type_definition_id-id.

      ENDIF.

  ENDTRY.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_CONTAINER" VERSION="1" LANGU="F" DESCRIPT="Container - Paramètre d&apos;appel" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <friends CLSNAME="ZCL_TASK_CONTAINER" REFCLSNAME="ZCL_TASK" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <friends CLSNAME="ZCL_TASK_CONTAINER" REFCLSNAME="ZCL_TASK_MANAGER" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_TASK_CONTAINER" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <attribute CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="MT_ATTACHED_DATA" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_TASK_ATTACHED_DATA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="MT_FUNCTION_PARAMETERS" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_FUNCTION_PARAMETERS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="MT_FUNCTION_PARAMETERS_OUTPUT" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_FUNCTION_PARAMETERS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="ATTACHED_DATA_ADD" VERSION="1" LANGU="F" DESCRIPT="Données contextuelle - Ajout" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="ATTACHED_DATA_ADD" SCONAME="IV_NAME" VERSION="1" LANGU="F" DESCRIPT="Donnée contextuelle - Nom" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="ATTACHED_DATA_ADD" SCONAME="IX_DATA" VERSION="1" LANGU="F" DESCRIPT="Donnée contextuelle - Valeur" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <source>METHOD attached_data_add.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : ATTACHED_DATA_ADD                                 *
*&amp; Classe          : ZCL_TASK_CONTAINER                                *
*&amp; Description     : Ajout de données contextuelles                    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_attached_data TYPE zif_task_constant=&gt;ts_task_attached_data.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
                 &lt;lfs_data&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Ajout /Modification données contextuelle
  &quot; -----------------------------------------------------------

  &quot; Récupération données contextuelles
  READ TABLE me-&gt;mt_attached_data WITH TABLE KEY name = iv_name
                                       ASSIGNING FIELD-SYMBOL(&lt;lfs_s_attached_data&gt;).
  IF sy-subrc NE 0.
    &quot; Aucune correspondance
    &quot;&quot;  --&gt; Initialisation données
    ls_attached_data-name = iv_name.

    &quot;&quot;  --&gt; Ajout de l&apos;entrée
    INSERT ls_attached_data INTO TABLE me-&gt;mt_attached_data ASSIGNING &lt;lfs_s_attached_data&gt;.

  ENDIF.

  IF ix_data IS SUPPLIED.
    &quot; Initialisation des données
    TRY.
        &quot;&quot;  --&gt; Création données typées
        CREATE DATA &lt;lfs_s_attached_data&gt;-data LIKE ix_data.
        IF sy-subrc EQ 0.
          &quot;&quot;  --&gt; Initialisation pointeur sur les données du Container
          ASSIGN &lt;lfs_s_attached_data&gt;-data-&gt;* TO &lt;lfs_data&gt;.

        ENDIF.
        IF sy-subrc EQ 0.
          &quot;&quot;  --&gt; Initialisation des données contextuelles
          &lt;lfs_data&gt; = ix_data.

        ENDIF.

      CATCH cx_root.
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Suppression de l&apos;entrée
        DELETE TABLE me-&gt;mt_attached_data FROM &lt;lfs_s_attached_data&gt;.

    ENDTRY.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="ATTACHED_DATA_DELETE" VERSION="1" LANGU="F" DESCRIPT="Données contextuelle - Suppression" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="ATTACHED_DATA_DELETE" SCONAME="IV_NAME" VERSION="1" LANGU="F" DESCRIPT="Donnée contextuelle - Nom" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="ATTACHED_DATA_DELETE" SCONAME="RV_DELETED" VERSION="1" LANGU="F" DESCRIPT="Données contextuelles supprimées" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN"/>
   <source>METHOD attached_data_delete.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : ATTACHED_DATA_DELETE                              *
*&amp; Classe          : ZCL_TASK_CONTAINER                                *
*&amp; Description     : Suppression données contextuelles                 *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Suppression des données contextuelles
  &quot; -----------------------------------------------------------

  &quot; Suppression des données
  DELETE me-&gt;mt_attached_data WHERE name EQ iv_name.
  rv_deleted = xsdbool( sy-subrc EQ 0 ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="ATTACHED_DATA_GET" VERSION="1" LANGU="F" DESCRIPT="Données contextuelle - Récupération" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="ATTACHED_DATA_GET" SCONAME="IV_NAME" VERSION="1" LANGU="F" DESCRIPT="Donnée contextuelle - Nom" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="ATTACHED_DATA_GET" SCONAME="EX_DATA" VERSION="1" LANGU="F" DESCRIPT="Donnée contextuelle - Données (Valeurs)" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="ATTACHED_DATA_GET" SCONAME="RO_DATA" VERSION="1" LANGU="F" DESCRIPT="Donnée contextuelle - Données (Référence)" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="DATA"/>
   <source>METHOD attached_data_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : ATTACHED_DATA_GET                                 *
*&amp; Classe          : ZCL_TASK_CONTAINER                                *
*&amp; Description     : Récupération données contextuelles                *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
                 &lt;lfs_data&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR : ex_data.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Retourne les données contextuelles
      &quot; -----------------------------------------------------------

      ro_data = me-&gt;mt_attached_data[ name = iv_name ]-data.

      IF ex_data IS SUPPLIED.
        &quot; Retourne les données (Valeurs)
        ASSIGN ro_data-&gt;* TO &lt;lfs_data&gt;.
        IF sy-subrc EQ 0.
          &quot; Transmet les données (Valeurs)
          ex_data = &lt;lfs_data&gt;.

        ENDIF.

      ENDIF.

    CATCH cx_sy_itab_line_not_found.
      &quot; Aucune correspondance
      FREE : ex_data, ro_data.

    CATCH cx_root.
      &quot; Erreur format données
      FREE : ex_data, ro_data.
      RETURN.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CONSTRUCTOR" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="CONSTRUCTOR" SCONAME="IT_FUNCTION_PARAMETERS" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_FUNCTION_PARAMETERS" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="CONSTRUCTOR" SCONAME="IT_ATTACHED_DATA" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_TASK_CONSTANT=&gt;TT_TASK_ATTACHED_DATA" PAROPTIONL="X"/>
   <source>METHOD constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_TASK_CONTAINER                                *
*&amp; Description     : Création du Container                             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Initialisation des attributs
  &quot; -----------------------------------------------------------

  IF it_function_parameters IS SUPPLIED.
    &quot; Initialisation des paramètres d&apos;appel
    me-&gt;mt_function_parameters[] = it_function_parameters[].

  ENDIF.

  IF it_attached_data IS SUPPLIED.
    &quot; Initialisation des données contextuelles
    me-&gt;mt_attached_data[] = it_attached_data[].

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="COPY_GET" VERSION="1" LANGU="F" DESCRIPT="Retourne une copie de l&apos;instance" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="COPY_GET" SCONAME="RO_TASK_CONTAINER" VERSION="1" LANGU="F" DESCRIPT="Container paramètres d&apos;appel" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK_CONTAINER"/>
   <source>METHOD copy_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : COPY_GET                                          *
*&amp; Classe          : ZCL_TASK_CONTAINER                                *
*&amp; Description     : Création Copie du Container                       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Création nouvelle instance avec les mêmes paramètres
  &quot; -----------------------------------------------------------

  CREATE OBJECT ro_task_container
    EXPORTING
      it_attached_data       = me-&gt;mt_attached_data
      it_function_parameters = me-&gt;mt_function_parameters.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="FUNCTION_PARAMETER_ADD" VERSION="1" LANGU="F" DESCRIPT="Données contextuelle - Ajout" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="FUNCTION_PARAMETER_ADD" SCONAME="IV_PARAMETER_NAME" VERSION="1" LANGU="F" DESCRIPT="Paramètre d&apos;appel - Nom" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="FUNCTION_PARAMETER_ADD" SCONAME="IX_PARAMETER_DATA" VERSION="1" LANGU="F" DESCRIPT="Paramètre d&apos;appel - Valeur" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="FUNCTION_PARAMETER_ADD" SCONAME="IV_TYPE_FOR_NONE_DDIC_PARAM" VERSION="1" LANGU="F" DESCRIPT="Type paramètre d&apos;appel (type local / générique uniquement)" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE" PAROPTIONL="X"/>
   <source>METHOD function_parameter_add.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : FUNCTION_PARAMETER_ADD                            *
*&amp; Classe          : ZCL_TASK_CONTAINER                                *
*&amp; Description     : Ajout de paramètres d&apos;appel                       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_function_parameters TYPE zif_task_constant=&gt;ts_function_parameters.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
                 &lt;lfs_parameter_data&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Ajout / Modification paramètre d&apos;appel
  &quot; -----------------------------------------------------------

  &quot; Récupération du Paramètre
  READ TABLE me-&gt;mt_function_parameters WITH TABLE KEY parameter_name = iv_parameter_name
                                             ASSIGNING FIELD-SYMBOL(&lt;lfs_s_function_parameters&gt;).
  IF sy-subrc NE 0.
    &quot; Aucune correspondance
    &quot;&quot;  --&gt; Initialisation données
    ls_function_parameters-parameter_name               = iv_parameter_name.
    ls_function_parameters-type_for_none_ddic_parameter = iv_type_for_none_ddic_param.

    &quot;&quot;  --&gt; Ajout de l&apos;entrée
    INSERT ls_function_parameters INTO TABLE me-&gt;mt_function_parameters ASSIGNING &lt;lfs_s_function_parameters&gt;.

  ENDIF.

  IF ix_parameter_data IS SUPPLIED.
    &quot; Initialisation des données
    TRY.
        &quot;&quot;  --&gt; Création données typées
        CREATE DATA &lt;lfs_s_function_parameters&gt;-parameter_data LIKE ix_parameter_data.
        IF sy-subrc EQ 0.
          &quot;&quot;  --&gt; Initialisation pointeur sur les données du Container
          ASSIGN &lt;lfs_s_function_parameters&gt;-parameter_data-&gt;* TO &lt;lfs_parameter_data&gt;.

        ENDIF.
        IF sy-subrc EQ 0.
          &quot;&quot;  --&gt; Initialisation des données du Paramètre
          &lt;lfs_parameter_data&gt; = ix_parameter_data.

        ENDIF.

      CATCH cx_root.
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Suppression du Paramètre
        DELETE TABLE me-&gt;mt_function_parameters FROM &lt;lfs_s_function_parameters&gt;.

    ENDTRY.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="FUNCTION_PARAMETER_DELETE" VERSION="1" LANGU="F" DESCRIPT="Paramètre d&apos;appel - Suppression" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="FUNCTION_PARAMETER_DELETE" SCONAME="IV_PARAMETER_NAME" VERSION="1" LANGU="F" DESCRIPT="Paramètre d&apos;appel - Nom" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="FUNCTION_PARAMETER_DELETE" SCONAME="RV_DELETED" VERSION="1" LANGU="F" DESCRIPT="Paramètre supprimé" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN"/>
   <source>METHOD function_parameter_delete.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : FUNCTION_PARAMETER_DELETE                         *
*&amp; Classe          : ZCL_TASK_CONTAINER                                *
*&amp; Description     : Suppression de paramètres d&apos;appel                 *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Suppression des données contextuelles
  &quot; -----------------------------------------------------------

  &quot; Suppression des données
  DELETE me-&gt;mt_function_parameters WHERE parameter_name EQ iv_parameter_name.
  rv_deleted = xsdbool( sy-subrc EQ 0 ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="FUNCTION_PARAMETER_GET" VERSION="1" LANGU="F" DESCRIPT="Paramètre d&apos;appel - Récupération" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="FUNCTION_PARAMETER_GET" SCONAME="IV_PARAMETER_NAME" VERSION="1" LANGU="F" DESCRIPT="Paramètre d&apos;appel - Nom" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="FUNCTION_PARAMETER_GET" SCONAME="EX_PARAMETER_DATA" VERSION="1" LANGU="F" DESCRIPT="Paramètre d&apos;appel - Données (Valeur)" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="FUNCTION_PARAMETER_GET" SCONAME="RO_PARAMETER_DATA_REF" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="DATA"/>
   <source>METHOD function_parameter_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : FUNCTION_PARAMETER_GET                            *
*&amp; Classe          : ZCL_TASK_CONTAINER                                *
*&amp; Description     : Récupération de paramètres d&apos;appel                *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
                 &lt;lfs_parameter_data&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR : ex_parameter_data.

  &quot; -----------------------------------------------------------
  &quot; Retourne les données du Paramètre
  &quot; -----------------------------------------------------------

  TRY.
      &quot; Récupération entrée correspondante au Paramètre
      READ TABLE me-&gt;mt_function_parameters WITH TABLE KEY parameter_name = iv_parameter_name
                                                 ASSIGNING FIELD-SYMBOL(&lt;lfs_s_function_parameters&gt;).

      IF ex_parameter_data IS SUPPLIED.
        &quot; Initialisation pointeur sur les données
        ASSIGN &lt;lfs_s_function_parameters&gt;-parameter_data-&gt;* TO &lt;lfs_parameter_data&gt;.
        IF sy-subrc EQ 0.
          &quot;&quot;  --&gt; Retourne les données (Valeurs)
          ex_parameter_data = &lt;lfs_parameter_data&gt;.

        ENDIF.

      ENDIF.

      &quot; Retourne les données sous forme de référence
      ro_parameter_data_ref = &lt;lfs_s_function_parameters&gt;-parameter_data.

    CATCH cx_root.
      &quot; Erreur format données
      FREE : ex_parameter_data.
      RETURN.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="RESET" VERSION="1" LANGU="F" DESCRIPT="Réinitialisation" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="RESET" SCONAME="IV_ALL" VERSION="1" LANGU="F" DESCRIPT="Réinitialisation de tous les attributs" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="RESET" SCONAME="IV_FUNCTION_PARAMETER" VERSION="1" LANGU="F" DESCRIPT="Réinitialisation paramètre d&apos;appel" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_CONTAINER" CMPNAME="RESET" SCONAME="IV_ATTACHED_DATA" VERSION="1" LANGU="F" DESCRIPT="Réintiialisation données contextuelles" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <source>METHOD reset.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : RESET                                             *
*&amp; Classe          : ZCL_TASK_CONTAINER                                *
*&amp; Description     : Réinitialisation du Container                     *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *


***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Réinitialisation des attributs
  &quot; -----------------------------------------------------------

  IF iv_all           EQ abap_true
  OR iv_attached_data EQ abap_true.
    &quot; Réinitialisation données contextuelles
    FREE : me-&gt;mt_attached_data.

  ENDIF.

  IF iv_all                EQ abap_true
  OR iv_function_parameter EQ abap_true.
    &quot; Réinitialisation données d&apos;appel
    FREE : me-&gt;mt_function_parameters.

  ENDIF.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_TRACE" VERSION="1" LANGU="F" DESCRIPT="Tâche - Trace exécution" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZTASK" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_TASK_TRACE" CMPNAME="TT_ZTASK_TRACE_H" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="4 " SRCCOLUMN2="107 " TYPESRC_LENG="0 " TYPESRC="tt_ZTASK_TRACE_H TYPE SORTED TABLE OF ZTASK_TRACE_H WITH UNIQUE KEY PRIMARY_KEY COMPONENTS task_trace_id
"/>
  <friends CLSNAME="ZCL_TASK_TRACE" REFCLSNAME="ZCL_TASK_MANAGER" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeClasDef CLSNAME="ZCL_TASK_TRACE" TYPEGROUP="ZCL_TASK_PARAM" VERSION="1" TPUTYPE="1" IMPLICIT="X"/>
  <attribute CLSNAME="ZCL_TASK_TRACE" CMPNAME="MT_ZTASK_TRACE" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_TASK_TRACE=&gt;TT_ZTASK_TRACE_H" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_TRACE" CMPNAME="MT_ZTASK_TRACE_TMP" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_TASK_TRACE=&gt;TT_ZTASK_TRACE_H" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_TRACE" CMPNAME="MV_TRACE_MEMORY" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZTRACE_MEM_XFELD" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_TRACE" CMPNAME="MV_TRACE_MEMORY_TMP" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZTRACE_MEM_XFELD" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TASK_TRACE" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CONSTRUCTOR" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="CONSTRUCTOR" SCONAME="IV_TRACE_MEMORY" VERSION="1" LANGU="F" DESCRIPT="Activation Trace mémoire" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTRACE_MEM_XFELD" PAROPTIONL="X"/>
   <source>METHOD constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_TASK_TRACE                                    *
*&amp; Description     : Constructeur instance Trace d&apos;exécution des Tâches*
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Initialisation variable locale
  &quot; -----------------------------------------------------------

  me-&gt;mv_trace_memory = iv_trace_memory.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_ADD" VERSION="1" LANGU="F" DESCRIPT="Trace - Ajout de la Trace" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_ADD" SCONAME="IV_TASK_TRACE_ID" VERSION="1" LANGU="F" DESCRIPT="ID Trace Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYSUUID_C32"/>
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_ADD" SCONAME="IV_LOG_IMMEDIATE" VERSION="1" LANGU="F" DESCRIPT="Trace - Enregistrement immédiat" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <source>METHOD task_trace_add.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_TRACE_ADD                                    *
*&amp; Classe          : ZCL_TASK_TRACE                                    *
*&amp; Description     : Ajotu de la Trace d&apos;exécution                     *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération de l&apos;entrée correspondante
  &quot; -----------------------------------------------------------

  READ TABLE me-&gt;mt_ztask_trace_tmp WITH TABLE KEY task_trace_id = iv_task_trace_id
                                         ASSIGNING FIELD-SYMBOL(&lt;lfs_s_ztask_trace_tmp&gt;).
  IF sy-subrc NE 0.
    &quot; Aucune correspondance
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Ajout de la Trace dans table définitive
  &quot; -----------------------------------------------------------

  &quot; Ajout de l&apos;entrée dans table définitive
  INSERT &lt;lfs_s_ztask_trace_tmp&gt; INTO TABLE me-&gt;mt_ztask_trace.

  &quot; Suppression de l&apos;entrée dans table temporaire
  DELETE TABLE me-&gt;mt_ztask_trace_tmp FROM &lt;lfs_s_ztask_trace_tmp&gt;.

  IF iv_log_immediate EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Enregistrement en DB
    &quot; -----------------------------------------------------------

    me-&gt;task_trace_save_to_db( ).

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_GET_PARAM" VERSION="1" LANGU="F" DESCRIPT="Trace - Récupération configuration" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_GET_PARAM" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement à lancer" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_CALL_PROCESS"/>
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_GET_PARAM" SCONAME="RS_TRACE_PARAM" VERSION="1" LANGU="F" DESCRIPT="Tâche - Paramètre de Trace" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTEC_S_TASK_TRACE_PARAM"/>
   <source>METHOD task_trace_get_param.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_TRACE_GET_PARAM                              *
*&amp; Classe          : ZCL_TASK_TRACE                                    *
*&amp; Description     : Récupération configuration Trace                  *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération entrée correpsondante
  &quot; -----------------------------------------------------------

  &quot; Récupération de la configuration de Trace
  MOVE-CORRESPONDING zcl_task_param=&gt;task_param_get( is_task_call_process ) TO rs_trace_param.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_IS_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Trace - Trace Active sur MF ?" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_IS_ACTIVE" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement à lancer" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_CALL_PROCESS"/>
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_IS_ACTIVE" SCONAME="RV_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Trace Active" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG"/>
   <source>METHOD task_trace_is_active.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_TRACE_IS_ACTIVE                              *
*&amp; Classe          : ZCL_TASK_TRACE                                    *
*&amp; Description     : Trace Active sur MF ?                             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération entrée correpsondante
  &quot; -----------------------------------------------------------

  &quot; Retourne l&apos;indicateur d&apos;activation de la Trace sur le MF
  rv_active = zcl_task_param=&gt;task_param_get( is_task_call_process )-trace_active.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_SAVE_TO_DB" VERSION="1" LANGU="F" DESCRIPT="Trace - Sauvegarde les Traces d&apos;exécution" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_SAVE_TO_DB" SCONAME="RV_SUBRC" VERSION="1" LANGU="F" DESCRIPT="Zone système ABAP : code retour des instructions ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <source>METHOD task_trace_save_to_db.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : SAVE_TO_DB                                        *
*&amp; Classe          : ZCL_TASK_TRACE                                    *
*&amp; Description     : Sauvegarde Trace d&apos;exéuction en DB                *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Sauvegarde les données en DB
  &quot; -----------------------------------------------------------

  &quot; Sauvegarde les données en DB
  CALL FUNCTION &apos;Z_TASK_TRACE_SAVE_TO_DB&apos;
    EXPORTING
      it_ztask_trace = CONV ztask_trace_h_t( me-&gt;mt_ztask_trace )
    IMPORTING
      ev_subrc       = rv_subrc.

  IF rv_subrc IS INITIAL.
    &quot; Suppression des données
    FREE : me-&gt;mt_ztask_trace.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_START" VERSION="1" LANGU="F" DESCRIPT="Trace - Début" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_START" SCONAME="IV_TASK_MANAGER_ID" VERSION="1" LANGU="F" DESCRIPT="ID Manager de Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYSUUID_C32"/>
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_START" SCONAME="IV_TASK_ID" VERSION="1" LANGU="F" DESCRIPT="ID Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYSUUID_C32"/>
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_START" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement à lancer" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_CALL_PROCESS"/>
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_START" SCONAME="IV_TRACE_MEMORY" VERSION="1" LANGU="F" DESCRIPT="Trace - Activation Trace mémoire" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTRACE_MEM_XFELD" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_START" SCONAME="RV_TASK_TRACE_ID" VERSION="1" LANGU="F" DESCRIPT="ID Trace Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SYSUUID_C32"/>
   <source>METHOD task_trace_start.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_TRACE_START                                  *
*&amp; Classe          : ZCL_TASK_TRACE                                    *
*&amp; Description     : Début de la Trace d&apos;exécution                     *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_abap_callstack TYPE abap_callstack.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_task_trace_h TYPE ztask_trace_h.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Création nouvelle entrée exécution
  &quot; -----------------------------------------------------------

  &quot; Initialisation
  ls_task_trace_h-mandt           = sy-mandt.
  ls_task_trace_h-uname           = sy-uname.
  ls_task_trace_h-task_id         = iv_task_id.
  ls_task_trace_h-funcname        = is_task_call_process-function_name.
  ls_task_trace_h-repidname       = is_task_call_process-repid_name.
  ls_task_trace_h-classname       = is_task_call_process-class_name.
  ls_task_trace_h-methodname      = is_task_call_process-method_name.
  ls_task_trace_h-task_manager_id = iv_task_manager_id.
  GET RUN TIME FIELD   ls_task_trace_h-runtime_beg.
  GET TIME STAMP FIELD ls_task_trace_h-timestamp_beg.

  &quot; Récupération Pile d&apos;Appel
  CALL FUNCTION &apos;SYSTEM_CALLSTACK&apos;
    EXPORTING
      max_level = 4 &quot;Appelant du Manager -&gt; TASK_START_NEW #EC NOTEXT
    IMPORTING
      callstack = lt_abap_callstack.

  TRY.
      &quot; Initialisation données Appelant
      MOVE-CORRESPONDING lt_abap_callstack[ lines( lt_abap_callstack ) ] TO ls_task_trace_h.

    CATCH cx_sy_itab_line_not_found.
      &quot; Aucune correspondance

  ENDTRY.

  TRY.
      &quot; Génération ID unique de Trace
      ls_task_trace_h-task_trace_id = cl_system_uuid=&gt;create_uuid_c32_static( ).

    CATCH cx_uuid_error.
      &quot; Erreur de la génération de l&apos;ID
      &quot;&quot;  --&gt; Utilisation nombre aléatoire
      ls_task_trace_h-task_trace_id = cl_abap_random=&gt;seed( ).

  ENDTRY.

  &quot; Ajout de l&apos;entrée dans table temporaire
  INSERT ls_task_trace_h INTO TABLE me-&gt;mt_ztask_trace_tmp.

  IF iv_trace_memory     EQ abap_true
  OR me-&gt;mv_trace_memory EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Trace consommation mémoire
    &quot; -----------------------------------------------------------

    &quot; Mesure utilisation mémoire
    cl_abap_memory_utilities=&gt;get_total_used_size( IMPORTING size = ls_task_trace_h-mem_before ).

    IF me-&gt;mv_trace_memory EQ abap_false AND iv_trace_memory EQ abap_true.
      &quot; Initialisation Indicateur temporaire de mesure mémoire
      me-&gt;mv_trace_memory_tmp = abap_true.

    ENDIF.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Retourne l&apos;ID de Trace
  &quot; -----------------------------------------------------------

  rv_task_trace_id = ls_task_trace_h-task_trace_id.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_STOP" VERSION="1" LANGU="F" DESCRIPT="Trace - Fin" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_STOP" SCONAME="IV_TASK_TRACE_ID" VERSION="1" LANGU="F" DESCRIPT="ID Trace Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYSUUID_C32"/>
   <parameter CLSNAME="ZCL_TASK_TRACE" CMPNAME="TASK_TRACE_STOP" SCONAME="IV_LOG_IMMEDIATE" VERSION="1" LANGU="F" DESCRIPT="Trace - Enregistrement immédiat" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <source>METHOD task_trace_stop.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_TRACE_STOP                                   *
*&amp; Classe          : ZCL_TASK_TRACE                                    *
*&amp; Description     : Fin de la Trace d&apos;exécution                       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération de l&apos;entrée correspondante
  &quot; -----------------------------------------------------------

  READ TABLE me-&gt;mt_ztask_trace_tmp WITH TABLE KEY task_trace_id = iv_task_trace_id
                                         ASSIGNING FIELD-SYMBOL(&lt;lfs_s_ztask_trace_tmp&gt;).
  IF sy-subrc NE 0.
    &quot; Aucune correspondance
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Initialisation données fin d&apos;exécution de la Tâche
  &quot; -----------------------------------------------------------

  &quot; Initialisation Temps fin
  GET RUN TIME FIELD   &lt;lfs_s_ztask_trace_tmp&gt;-runtime_end.
  GET TIME STAMP FIELD &lt;lfs_s_ztask_trace_tmp&gt;-timestamp_end.

  &quot; Initialisation durée d&apos;exécution
  &lt;lfs_s_ztask_trace_tmp&gt;-runtime_exec = &lt;lfs_s_ztask_trace_tmp&gt;-runtime_end - &lt;lfs_s_ztask_trace_tmp&gt;-runtime_beg.

  IF me-&gt;mv_trace_memory     EQ abap_true
  OR me-&gt;mv_trace_memory_tmp EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Initialisation Empreinte mémoire
    &quot; -----------------------------------------------------------

    &quot; Mesure mémoire après exécution
    cl_abap_memory_utilities=&gt;get_total_used_size( IMPORTING size = &lt;lfs_s_ztask_trace_tmp&gt;-mem_after ).

    &quot; Calcul Empreinte mémoire utilisée
    &lt;lfs_s_ztask_trace_tmp&gt;-mem_allocated = &lt;lfs_s_ztask_trace_tmp&gt;-mem_after - &lt;lfs_s_ztask_trace_tmp&gt;-mem_before.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Ajout de la Trace dans table définitive
  &quot; -----------------------------------------------------------

  me-&gt;task_trace_add(
    iv_task_trace_id = iv_task_trace_id
    iv_log_immediate = iv_log_immediate
  ).

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="SHM - Classe utilitaire Définition de Type" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeClasDef CLSNAME="ZCL_TYPE_DEFINITION" TYPEGROUP="CL_SHM_AREA" VERSION="1" TPUTYPE="1" IMPLICIT="X"/>
  <attribute CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="MO_ATTACH_READ" VERSION="1" LANGU="F" DESCRIPT="Area pour définition de Type" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_TYPE_DEF_AREAHANDLE_AREA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="MO_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="SHM - Classe utilitaire Définition de Type" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_TYPE_DEFINITION" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CONSTRUCTOR" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <exception CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="CONSTRUCTOR" SCONAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" MTDTYPE="2" EDITORDER="1 "/>
   <source>METHOD constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_TYPE_DEFINITION                               *
*&amp; Description     : Création instance pour utilisation SHM Déf. Type  *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception  TYPE REF TO cx_root,
    lo_attach_write  TYPE REF TO zcl_type_def_areahandle_area,
    lo_type_def_root TYPE REF TO zcl_type_def_areahandle_root.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
        lv_retry_count TYPE i.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : zcl_type_definition=&gt;mo_instance.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Récupération version courante
      &quot; -----------------------------------------------------------

      &quot; Lecture de la version courante
      me-&gt;mo_attach_read = zcl_type_def_areahandle_area=&gt;attach_for_read( ).

    CATCH cx_shm_no_active_version INTO lo_cx_exception.
      &quot; Aucune version existante
      TRY.
          &quot;&quot;  --&gt; Création instance d&apos;écriture
          lo_attach_write = zcl_type_def_areahandle_area=&gt;attach_for_write( ).

          &quot;&quot;  --&gt; Création d&apos;une nouvelle version
          CREATE OBJECT lo_type_def_root AREA HANDLE lo_attach_write.

          &quot;&quot;  --&gt; Initialisation de la version
          lo_attach_write-&gt;set_root( lo_type_def_root ).

          &quot;&quot;  --&gt; Sauvegarde la version
          lo_attach_write-&gt;detach_commit( ).

          &quot;&quot;  --&gt; Récupère l&apos;instance de lecture
          me-&gt;mo_attach_read = zcl_type_def_areahandle_area=&gt;attach_for_read( ).

        CATCH cx_root INTO lo_cx_exception.
          &quot; Une erreur est survenue
          &quot;&quot;  --&gt; Lève l&apos;exception
          WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
          RAISE EXCEPTION TYPE zcx_type_definition
            EXPORTING
              previous = lo_cx_exception.

      ENDTRY.

    CATCH cx_shm_inconsistent INTO lo_cx_exception.
      &quot; Mauvaise gestion version
      TRY.
          &quot;&quot;  --&gt; Réinitialisation Instance lecture
          CLEAR : me-&gt;mo_attach_read.

          &quot;&quot;  --&gt; Libère les Tokens
          zcl_type_def_areahandle_area=&gt;detach_area( ).

          &quot;&quot;  --&gt; Invalide l&apos;instance générique
          zcl_type_def_areahandle_area=&gt;invalidate_instance( ).

        CATCH cx_shm_parameter_error.

      ENDTRY.

      IF lv_retry_count GT 1.
        &quot; Le traitement a déjà été relancé
        &quot;&quot;  --&gt; Lève une Exception
        WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
        RAISE EXCEPTION TYPE zcx_type_definition
          EXPORTING
            previous = lo_cx_exception.

      ENDIF.

      &quot;&quot;  --&gt; Relance traitement
      ADD 1 TO lv_retry_count.
      RETRY.

    CATCH cx_root INTO lo_cx_exception.
      &quot; Erreur lors de la récupération du Token de Lecture
      &quot;&quot;  --&gt; Lève l&apos;exception
      WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
      RAISE EXCEPTION TYPE zcx_type_definition
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

  &quot; Initialisation instance courante
  zcl_type_definition=&gt;mo_instance = me.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_ADD" VERSION="1" LANGU="F" DESCRIPT="Définition Type - Ajout" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_ADD" SCONAME="IO_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_ADD" SCONAME="RV_SUBRC" VERSION="1" LANGU="F" DESCRIPT="Zone système ABAP : code retour des instructions ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <exception CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_ADD" SCONAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD definition_type_add.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_TYPE_ADD                               *
*&amp; Classe          : ZCL_TYPE_DEFINITION                               *
*&amp; Description     : Ajout définition de Type                          *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception  TYPE REF TO cx_root,
    lo_attach_update TYPE REF TO zcl_type_def_areahandle_area.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle définition de type déjà existante
  &quot; -----------------------------------------------------------

  &quot; Détermine si la définition de Type existe déjà
  IF me-&gt;mo_attach_read-&gt;root-&gt;definition_type_exist( io_definition-&gt;absolute_name ) EQ abap_true.
    &quot; La définition du Type existe déjà
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Ajout de la définition de type
  &quot; -----------------------------------------------------------

  TRY.
      &quot;&quot;  --&gt;  Récupération instance de mise à jour
      lo_attach_update = zcl_type_def_areahandle_area=&gt;attach_for_update( ).

      &quot;&quot;  --&gt; Ajout de la définition de type
      lo_attach_update-&gt;root-&gt;definition_type_add( io_definition ).

      &quot;&quot;  --&gt; Pousse la mise à jour
      lo_attach_update-&gt;detach_commit( ).

      IF me-&gt;mo_attach_read-&gt;is_active_version( ) EQ abap_false.
        &quot;&quot;  --&gt; Libère le Token courant
        me-&gt;mo_attach_read-&gt;detach( ).

        &quot;&quot;  --&gt; Recharge l&apos;instance de lecture
        me-&gt;mo_attach_read = zcl_type_def_areahandle_area=&gt;attach_for_read( ).

      ENDIF.

    CATCH cx_root INTO lo_cx_exception.
      &quot; Une erreur est survenue
      IF lo_attach_update IS BOUND.
        TRY.
            &quot;&quot;  --&gt; Libération Token
            lo_attach_update-&gt;detach_rollback( ).

          CATCH cx_root.                                &quot;#EC NO_HANDLER
            &quot; Erreur libération token

        ENDTRY.

      ENDIF.

      TRY.
          IF me-&gt;mo_attach_read-&gt;is_active_version( ) EQ abap_false.
            &quot;&quot;  --&gt; Libère le Token courant
            me-&gt;mo_attach_read-&gt;detach( ).

            &quot;&quot;  --&gt; Recharge l&apos;instance de lecture
            me-&gt;mo_attach_read = zcl_type_def_areahandle_area=&gt;attach_for_read( ).

          ENDIF.

        CATCH cx_root. &quot;#EC NO_HANDLER

      ENDTRY.

      &quot;&quot;  --&gt; Initialisation code retour en erreur
      rv_subrc = 4.

      &quot;&quot;  --&gt; Lève l&apos;exception
      WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
      RAISE EXCEPTION TYPE zcx_type_definition
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_DELETE" VERSION="1" LANGU="F" DESCRIPT="Définition Type - Suppression" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_DELETE" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_DELETE" SCONAME="IV_FREE_SHM_IF_EMPTY" VERSION="1" LANGU="F" DESCRIPT="Libération SHM si plus de Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_DELETE" SCONAME="RV_SUBRC" VERSION="1" LANGU="F" DESCRIPT="Zone système ABAP : code retour des instructions ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <exception CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_DELETE" SCONAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD definition_type_delete.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_TYPE_DELETE                            *
*&amp; Classe          : ZCL_TYPE_DEFINITION                               *
*&amp; Description     : Suppression définition de Type                    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception  TYPE REF TO cx_root,
    lo_attach_update TYPE REF TO zcl_type_def_areahandle_area.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_empty TYPE flag.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle définition de type déjà existante
  &quot; -----------------------------------------------------------

  &quot; Détermine si la définition de Type existe déjà
  IF me-&gt;mo_attach_read-&gt;root-&gt;definition_type_exist( iv_type ) EQ abap_false.
    &quot; La définition du Type n&apos;existe pas
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Suppression de la définition de type
  &quot; -----------------------------------------------------------

  TRY.
      &quot;&quot;  --&gt;  Récupération instance de mise à jour
      lo_attach_update = zcl_type_def_areahandle_area=&gt;attach_for_update( ).

      &quot;&quot;  --&gt; Ajout de la définition de type
      lv_empty = lo_attach_update-&gt;root-&gt;definition_type_delete( iv_type ).

      &quot;&quot;  --&gt; Pousse la mise à jour
      lo_attach_update-&gt;detach_commit( ).

      IF me-&gt;mo_attach_read-&gt;is_active_version( ) EQ abap_false.
        &quot;&quot;  --&gt; Libère le Token courant
        me-&gt;mo_attach_read-&gt;detach( ).

        IF lv_empty EQ abap_false.
          &quot;&quot;  --&gt; Recharge l&apos;instance de lecture
          me-&gt;mo_attach_read = zcl_type_def_areahandle_area=&gt;attach_for_read( ).

        ENDIF.

      ENDIF.

    CATCH cx_root INTO lo_cx_exception.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Initialisation code retour en erreur
      rv_subrc = 4.

      TRY.
          &quot;&quot;  --&gt; Libère Token de MàJ
          lo_attach_update-&gt;detach_rollback( ).

        CATCH cx_root.                                  &quot;#EC NO_HANDLER

      ENDTRY.

      TRY.
          IF me-&gt;mo_attach_read-&gt;is_active_version( ) EQ abap_false.
            &quot;&quot;  --&gt; Libère le Token courant
            me-&gt;mo_attach_read-&gt;detach( ).

            &quot;&quot;  --&gt; Recharge l&apos;instance de lecture
            me-&gt;mo_attach_read = zcl_type_def_areahandle_area=&gt;attach_for_read( ).

          ENDIF.

        CATCH cx_root.                                  &quot;#EC NO_HANDLER

      ENDTRY.

      &quot;&quot;  --&gt; Lève l&apos;exception
      WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
      RAISE EXCEPTION TYPE zcx_type_definition
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

  IF  lv_empty EQ abap_true
  AND iv_free_shm_if_empty EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Suppression de l&apos;instance SHM
    &quot; -----------------------------------------------------------

    rv_subrc = me-&gt;__internal_use_free_shm( iv_areas_free = abap_true ).

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_FINISH" VERSION="1" LANGU="F" DESCRIPT="Définition Type - Ferme le Token de Lecture" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <exception CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_FINISH" SCONAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD definition_type_finish.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_TYPE_FINISH                            *
*&amp; Classe          : ZCL_TYPE_DEFINITION                               *
*&amp; Description     : Ferme les Tokens SHM                              *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_cx_exception TYPE REF TO cx_root.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  IF me-&gt;mo_attach_read IS BOUND.
    TRY.
        &quot; Libération Token de lecture
        me-&gt;mo_attach_read-&gt;detach( ).

        CLEAR : me-&gt;mo_attach_read.

      CATCH cx_root INTO lo_cx_exception.
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Lève l&apos;Exception
        WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
        RAISE EXCEPTION TYPE zcx_type_definition
          EXPORTING
            previous = lo_cx_exception.

    ENDTRY.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_GET" VERSION="1" LANGU="F" DESCRIPT="Définition Type - Récupération" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_GET" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_GET" SCONAME="RO_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
   <exception CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="DEFINITION_TYPE_GET" SCONAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD definition_type_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_TYPE_GET                               *
*&amp; Classe          : ZCL_TYPE_DEFINITION                               *
*&amp; Description     : Récupération définition de Type                   *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception TYPE REF TO cx_root.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; Retourne la définition du Type
      ro_definition = me-&gt;mo_attach_read-&gt;root-&gt;definition_type_get( iv_type ).

    CATCH cx_root INTO lo_cx_exception.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Lève une exception
      RAISE EXCEPTION TYPE zcx_type_definition
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="GET_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="Définition Type - Récupération Instance" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="GET_INSTANCE" SCONAME="RO_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="SHM - Classe utilitaire Définition de Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TYPE_DEFINITION"/>
   <exception CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="GET_INSTANCE" SCONAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD get_instance.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : GET_INSTANCE                                      *
*&amp; Classe          : ZCL_TYPE_DEFINITION                               *
*&amp; Description     : Récupération instance utilisation SHM Déf. Type   *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_cx_exception TYPE REF TO cx_root.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
        lv_create TYPE xsdboolean.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.

      IF NOT zcl_type_definition=&gt;mo_instance IS BOUND.
        &quot; Création d&apos;une nouvelle instance
        CREATE OBJECT zcl_type_definition=&gt;mo_instance.

      ELSEIF NOT zcl_type_definition=&gt;mo_instance-&gt;mo_attach_read IS BOUND
              OR zcl_type_definition=&gt;mo_instance-&gt;mo_attach_read-&gt;is_valid( )          EQ abap_false
              OR zcl_type_definition=&gt;mo_instance-&gt;mo_attach_read-&gt;is_active_version( ) EQ abap_false.

        IF NOT zcl_type_definition=&gt;mo_instance-&gt;mo_attach_read IS BOUND.
          &quot; Aucune Instance de Lecture
          TRY.
              &quot;&quot;  --&gt; Récupération Token de Lecture
              zcl_type_definition=&gt;mo_instance-&gt;mo_attach_read = zcl_type_def_areahandle_area=&gt;attach_for_read( ).
              lv_create = xsdbool( NOT zcl_type_definition=&gt;mo_instance-&gt;mo_attach_read-&gt;get_root( ) IS BOUND ).

            CATCH cx_root.                               &quot;#EC CATCH_ALL
              &quot; Erreur récupération Token Lecture ou pas d&apos;entité Root défini
              &quot;&quot;  --&gt; Initialisation indicateur création
              lv_create = abap_true.

          ENDTRY.

        ELSEIF zcl_type_definition=&gt;mo_instance-&gt;mo_attach_read-&gt;is_valid( )          EQ abap_false
            OR zcl_type_definition=&gt;mo_instance-&gt;mo_attach_read-&gt;is_active_version( ) EQ abap_false.
          &quot; Instance existante mais sans canal de lecture ou pas dans la version active
          TRY.
              &quot;&quot;  --&gt; Libère les Tokens existant sur cette version
              zcl_type_definition=&gt;mo_instance-&gt;mo_attach_read-&gt;detach( ).

            CATCH cx_root.                &quot;#EC CATCH_ALL #EC NO_HANDLER
              &quot; Erreur libération Token Lecture

          ENDTRY.

          TRY.
              &quot;&quot;  --&gt; Récupération Token de Lecture Valide
              zcl_type_definition=&gt;mo_instance-&gt;mo_attach_read = zcl_type_def_areahandle_area=&gt;attach_for_read( ).
              lv_create = xsdbool( NOT zcl_type_definition=&gt;mo_instance-&gt;mo_attach_read-&gt;get_root( ) IS BOUND ).

            CATCH cx_root.                               &quot;#EC CATCH_ALL
              &quot; Erreur libération Token Lecture
              &quot;&quot;  --&gt; Initialisation indicateur création
              lv_create = abap_true.

          ENDTRY.

        ENDIF.

        IF lv_create EQ abap_true.
          &quot;&quot;  --&gt; Libération de l&apos;instance
          FREE : zcl_type_definition=&gt;mo_instance.

          &quot;&quot;  --&gt; Création nouvelle instance
          CREATE OBJECT zcl_type_definition=&gt;mo_instance.

        ENDIF.

      ENDIF.

      &quot; Retourne l&apos;instance
      ro_instance = zcl_type_definition=&gt;mo_instance.

    CATCH zcx_type_definition INTO lo_cx_exception.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Lève l&apos;Exception
      RAISE EXCEPTION TYPE zcx_type_definition
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="__INTERNAL_USE_FREE_SHM" VERSION="1" LANGU="F" DESCRIPT="Supprime toutes les versions" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="IV_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="Nom d&apos;une instance d&apos;objet partagé d&apos;un domaine" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="IV_AREAS_DETACH" VERSION="1" LANGU="F" DESCRIPT="Libére les Tokens" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="IV_AREAS_FREE" VERSION="1" LANGU="F" DESCRIPT="Supprime les Versions" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="IV_AREAS_INVALIDATE" VERSION="1" LANGU="F" DESCRIPT="Invalide les Versions" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEFINITION" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="RV_RC" VERSION="1" LANGU="F" DESCRIPT="Valeur de retour (constantes dans CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <source>METHOD __internal_use_free_shm.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __INTERNAL_USE_FREE_SHM                           *
*&amp; Classe          : ZCL_TYPE_DEFINITION                               *
*&amp; Description     : Usage Interne : Suppression toutes versions       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : zcl_type_definition=&gt;mo_instance.

  IF iv_areas_free EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Libération des Versions
    &quot; -----------------------------------------------------------

    TRY.
        &quot; Libération des Versions
        rv_rc = zcl_type_def_areahandle_area=&gt;free_instance( iv_instance ).

      CATCH cx_shm_parameter_error.
        &quot; Une erreur est survenue
        rv_rc = cl_shm_area=&gt;rc_nothing_to_be_done.

    ENDTRY.

    RETURN.

  ELSEIF iv_areas_invalidate EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Invalidation des Versions
    &quot; -----------------------------------------------------------

    TRY.
        &quot; Invalide les Versions
        rv_rc = zcl_type_def_areahandle_area=&gt;invalidate_instance( iv_instance ).

      CATCH cx_shm_parameter_error.
        &quot; Une erreur est survenue
        rv_rc = cl_shm_area=&gt;rc_nothing_to_be_done.

    ENDTRY.

    RETURN.

  ELSEIF iv_areas_detach EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Livération des Tokens
    &quot; -----------------------------------------------------------

    &quot; Libération des Tokens
    rv_rc = zcl_type_def_areahandle_area=&gt;detach_all_areas( ).

  ENDIF.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_SHM_ROOT" VERSION="1" LANGU="F" DESCRIPT="Tâche - SHM Racine" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" CLSSHAREDMEMORY="X" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <implementing CLSNAME="ZCL_TASK_SHM_ROOT" REFCLSNAME="IF_SHM_BUILD_INSTANCE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="MT_TASK_MANAGER_ID" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="EPIC_T_GUID" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_TASK_SHM_ROOT" CPDNAME="IF_SHM_BUILD_INSTANCE~BUILD">
   <source>METHOD if_shm_build_instance~build.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

ENDMETHOD.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="TASK_MANAGER_DEREGISTER" VERSION="1" LANGU="F" DESCRIPT="Manager Tâche - Désenregistrement" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="TASK_MANAGER_DEREGISTER" SCONAME="IV_TASK_MANAGER_ID" VERSION="1" LANGU="F" DESCRIPT="Tâche - ID Manager Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTASK_MANAGER_ID"/>
   <parameter CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="TASK_MANAGER_DEREGISTER" SCONAME="RV_EMPTY_LIST" VERSION="1" LANGU="F" DESCRIPT="Plus de Tâches présentes" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG"/>
   <source>METHOD task_manager_deregister.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_MANAGER_DEREGISTER                           *
*&amp; Classe          : ZCL_TASK_SHM_ROOT                                 *
*&amp; Description     : Désenregistrement du Manager de Tâche             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Désenregistrement du Manager de Tâche
  &quot; -----------------------------------------------------------

  &quot; Récupération index du Manager de Tâche
  READ TABLE me-&gt;mt_task_manager_id WITH KEY table_line = iv_task_manager_id
                                TRANSPORTING NO FIELDS BINARY SEARCH.
  IF sy-subrc EQ 0.
    &quot; Position trouvé
    &quot;&quot;  --&gt; Suppression du Manager de Tâche
    DELETE me-&gt;mt_task_manager_id INDEX sy-tabix.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Retourne indicateur de présence d&apos;autre Manager de Tâche
  &quot; -----------------------------------------------------------

  rv_empty_list = xsdbool( me-&gt;mt_task_manager_id[] IS INITIAL ). &quot;Vrai si plus de Manager Tâche présent

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="TASK_MANAGER_IS_REGISTERED" VERSION="1" LANGU="F" DESCRIPT="Manager Tâche - Déjà enregistrée ?" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="TASK_MANAGER_IS_REGISTERED" SCONAME="IV_TASK_MANAGER_ID" VERSION="1" LANGU="F" DESCRIPT="Tâche - ID Manager Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTASK_MANAGER_ID"/>
   <parameter CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="TASK_MANAGER_IS_REGISTERED" SCONAME="RV_FOUND" VERSION="1" LANGU="F" DESCRIPT="Tâche déjà enregistrée" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG"/>
   <source>METHOD task_manager_is_registered.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_MANAGER_IS_REGISTERED                        *
*&amp; Classe          : ZCL_TASK_SHM_ROOT                                 *
*&amp; Description     : Contrôle présence du Manager de Tâche             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle présence du Manager de Tâche
  &quot; -----------------------------------------------------------

  READ TABLE me-&gt;mt_task_manager_id WITH KEY table_line = iv_task_manager_id
                                TRANSPORTING NO FIELDS BINARY SEARCH.
  rv_found = xsdbool( sy-subrc EQ 0 ). &quot;Vrai si ID Tâche existe

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="TASK_MANAGER_REGISTER" VERSION="1" LANGU="F" DESCRIPT="Manager Tâche - Enregistrement" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_ROOT" CMPNAME="TASK_MANAGER_REGISTER" SCONAME="IV_TASK_MANAGER_ID" VERSION="1" LANGU="F" DESCRIPT="Tâche - ID Manager Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTASK_MANAGER_ID"/>
   <source>METHOD task_manager_register.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_MANAGER_REGISTER                             *
*&amp; Classe          : ZCL_TASK_SHM_ROOT                                 *
*&amp; Description     : Ajout du Manager de Tâche                         *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Ajout de l&apos;ID Manager de Tâche
  &quot; -----------------------------------------------------------

  READ TABLE me-&gt;mt_task_manager_id WITH KEY table_line = iv_task_manager_id
                                TRANSPORTING NO FIELDS BINARY SEARCH.
  IF sy-subrc NE 0.
    &quot; ID Tâche non présent
    &quot;&quot;  --&gt; Ajout de l&apos;ID
    INSERT iv_task_manager_id INTO me-&gt;mt_task_manager_id INDEX sy-tabix.

  ENDIF.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_PARAM" VERSION="1" LANGU="F" DESCRIPT="Tâche - Exploitation paramétrage" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_TASK_PARAM" CMPNAME="TS_ZTASK_FUNC_PARAM" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="8 " SRCCOLUMN2="33 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_ztask_func_param.
        INCLUDE TYPE ztask_func_param.
        TYPES :
        not_found TYPE XSDBOOLEAN,
      END OF   ts_ztask_func_param
"/>
  <types CLSNAME="ZCL_TASK_PARAM" CMPNAME="TT_ZTASK_FUNC_PARAM" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="10 " SRCCOLUMN1="4 " SRCROW2="13 " SRCCOLUMN2="76 " TYPESRC_LENG="0 " TYPESRC="tt_ZTASK_FUNC_PARAM TYPE SORTED TABLE OF ZCL_TASK_PARAM=&gt;ts_ztask_func_param
       WITH UNIQUE KEY PRIMARY_KEY COMPONENTS param_guid
       with NON-UNIQUE SORTED KEY second_key COMPONENTS funcname
       WITH NON-UNIQUE SORTED KEY third_key COMPONENTS class_name method_name
"/>
  <types CLSNAME="ZCL_TASK_PARAM" CMPNAME="TS_TASK_FUNCTION_PARAM" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="4 " SRCROW2="14 " SRCCOLUMN2="36 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_task_function_param.
            INCLUDE TYPE ztec_s_task_trace_param.
            INCLUDE TYPE ztec_s_task_compress_param.
    TYPES :
      shm_management TYPE ztask_func_param-shm_management,
      END OF   ts_task_function_param
"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_TASK_PARAM" CMPNAME="MT_ZTASK_FUNC_PARAM" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_TASK_PARAM=&gt;TT_ZTASK_FUNC_PARAM" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TASK_PARAM" CMPNAME="CLASS_CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CLASS_CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD class_constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CLASS_CONSTRUCTOR                                 *
*&amp; Classe          : ZCL_TASK_PARAM                                    *
*&amp; Description     : Constructeur statique                             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération des données de la table de paramétrage
  &quot; -----------------------------------------------------------

  SELECT * FROM ztask_func_param INTO TABLE zcl_task_param=&gt;mt_ztask_func_param.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_PARAM" CMPNAME="TASK_PARAM_GET" VERSION="1" LANGU="F" DESCRIPT="Récupération paramétrage" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_PARAM" CMPNAME="TASK_PARAM_GET" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement à lancer" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_CALL_PROCESS"/>
   <parameter CLSNAME="ZCL_TASK_PARAM" CMPNAME="TASK_PARAM_GET" SCONAME="EV_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Aucune configuration" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN"/>
   <parameter CLSNAME="ZCL_TASK_PARAM" CMPNAME="TASK_PARAM_GET" SCONAME="RS_PARAM" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZCL_TASK_PARAM=&gt;TS_TASK_FUNCTION_PARAM"/>
   <source>METHOD task_param_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_PARAM_GET                                    *
*&amp; Classe          : ZCL_TASK_PARAM                                    *
*&amp; Description     : Récupération paramétrage                          *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR : ev_not_found.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Retourne les paramètres associées à ce Traitement
      &quot; -----------------------------------------------------------

      &quot; Récupération des paramètres de ce traitement
      DATA(ls_ztask_func_param) = zcl_task_param=&gt;__task_param_get( iv_param_guid = zcl_task_param=&gt;__task_param_guid_get( is_task_call_process ) ).

      &quot; Retourne données
      MOVE-CORRESPONDING ls_ztask_func_param TO rs_param.

      &quot; Retourne indicateur données existante
      ev_not_found = ls_ztask_func_param-not_found.

    CATCH cx_no_data_found.
      &quot; GUID inexistant
      &quot;&quot;  --&gt; Arrêt du traitement

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_PARAM" CMPNAME="__TASK_PARAM_GET" VERSION="1" LANGU="F" DESCRIPT="Internal use - Paramétrage - Récupération" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_PARAM" CMPNAME="__TASK_PARAM_GET" SCONAME="IV_PARAM_GUID" VERSION="1" LANGU="F" DESCRIPT="16 Byte UUID in 16 Bytes (Raw Format)" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTASK_FUNC_PARAM-PARAM_GUID"/>
   <parameter CLSNAME="ZCL_TASK_PARAM" CMPNAME="__TASK_PARAM_GET" SCONAME="RS_ZTASK_FUNC_PARAM" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZCL_TASK_PARAM=&gt;TS_ZTASK_FUNC_PARAM"/>
   <source>METHOD __task_param_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __TASK_PARAM_GET                                  *
*&amp; Classe          : ZCL_TASK_PARAM                                    *
*&amp; Description     : Récupération paramétrage                          *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Récupération entrée correspondante
      &quot; -----------------------------------------------------------

      &quot; Récupération des données de paramétrage
      rs_ztask_func_param = zcl_task_param=&gt;mt_ztask_func_param[ param_guid = iv_param_guid ].

    CATCH cx_sy_itab_line_not_found.
      &quot; Aucune correspondance
      &quot;&quot;  --&gt; Récupération de l&apos;entrée en DB
      SELECT SINGLE * FROM ztask_func_param &quot;Table bufferisée en DB
                      INTO rs_ztask_func_param
                     WHERE funcname EQ iv_param_guid.
      IF sy-subrc NE 0.
        &quot; Aucune correspondance
        &quot;&quot;  --&gt; Force l&apos;ajout dans table statique pour éviter recherche ultérieur
        rs_ztask_func_param-param_guid                 = iv_param_guid.
        rs_ztask_func_param-not_found                  = abap_true.
        rs_ztask_func_param-shm_management             = abap_true. &quot;Par défaut
        rs_ztask_func_param-data_compress_line_by_line = abap_true.&quot;Par défaut

      ENDIF.

      &quot; Ajout de l&apos;entrée
      INSERT rs_ztask_func_param INTO TABLE zcl_task_param=&gt;mt_ztask_func_param.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_PARAM" CMPNAME="__TASK_PARAM_GUID_GET" VERSION="1" LANGU="F" DESCRIPT="Détermination GUID de Traitement d&apos;Appel" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_PARAM" CMPNAME="__TASK_PARAM_GUID_GET" SCONAME="IS_TASK_CALL_PROCESS" VERSION="1" LANGU="F" DESCRIPT="Tâche - Traitement à lancer" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTEC_S_TASK_CALL_PROCESS"/>
   <parameter CLSNAME="ZCL_TASK_PARAM" CMPNAME="__TASK_PARAM_GUID_GET" SCONAME="RV_PARAM_GUID" VERSION="1" LANGU="F" DESCRIPT="16 Byte UUID in 16 Bytes (Raw Format)" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTASK_FUNC_PARAM-PARAM_GUID"/>
   <exception CLSNAME="ZCL_TASK_PARAM" CMPNAME="__TASK_PARAM_GUID_GET" SCONAME="CX_NO_DATA_FOUND" VERSION="1" LANGU="F" DESCRIPT="No Data for Release Process on the Database" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD __task_param_guid_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_PARAM_GET                                    *
*&amp; Classe          : ZCL_TASK_PARAM                                    *
*&amp; Description     : Récupération paramétrage                          *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
        ls_ztask_func_param TYPE zcl_task_param=&gt;ts_ztask_func_param.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
        lv_sql_cond TYPE string.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération de l&apos;ID
  &quot; -----------------------------------------------------------

  IF NOT is_task_call_process-function_name IS INITIAL.
    &quot; Récupération de l&apos;ID par MF
    &quot;&quot;  --&gt; Initialisation condition de recherche en DB
    lv_sql_cond = |FUNCNAME = &apos;{ is_task_call_process-function_name }&apos;|. &quot;#EC NOTEXT

    &quot;&quot;  --&gt; Récupération de l&apos;ID correspondant
    READ TABLE zcl_task_param=&gt;mt_ztask_func_param WITH KEY second_key
                                                 COMPONENTS funcname = is_task_call_process-function_name
                                                  ASSIGNING FIELD-SYMBOL(&lt;lfs_s_task_func_param&gt;).

  ELSEIF NOT is_task_call_process-class_name  IS INITIAL
     AND NOT is_task_call_process-method_name IS INITIAL.
    &quot; Récupération de l&apos;ID par Méthode
    &quot;&quot;  --&gt; Initialisation condition de recherche en DB
    lv_sql_cond = |CLASS_NAME = &apos;{ is_task_call_process-class_name }&apos; AND METHOD_NAME = &apos;{ is_task_call_process-method_name }&apos;|. &quot;#EC NOTEXT

    &quot;&quot;  --&gt; Récupération de l&apos;ID correspondant
    READ TABLE zcl_task_param=&gt;mt_ztask_func_param WITH KEY third_key
                                                 COMPONENTS class_name  = is_task_call_process-class_name
                                                            method_name = is_task_call_process-method_name
                                                  ASSIGNING &lt;lfs_s_task_func_param&gt;.

  ELSEIF NOT is_task_call_process-repid_name IS INITIAL.
    &quot; Traitement sur Programme
    &quot;&quot;  --&gt; Force l&apos;Ajout // Pas de gestion des conditions d&apos;appel
    RETURN.

  ELSE.
    &quot; Aucun paramètre
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.
  IF sy-subrc NE 0.
    &quot; Aucune correspondance
    &quot;&quot;  --&gt; Recherche en DB
    SELECT SINGLE * FROM ztask_func_param
                   WHERE (lv_sql_cond)
                    INTO @ls_ztask_func_param.
    IF sy-subrc NE 0.
      &quot; Aucune correspondance en DB
      &quot;&quot;  --&gt; Ajout dans le Buffer
      TRY.
          ls_ztask_func_param-param_guid = cl_system_uuid=&gt;create_uuid_x16_static( ).
        CATCH cx_uuid_error.
          ls_ztask_func_param-param_guid = cl_abap_random=&gt;seed( ).

      ENDTRY.
      ls_ztask_func_param-funcname                   = is_task_call_process-function_name.
      ls_ztask_func_param-class_name                 = is_task_call_process-class_name.
      ls_ztask_func_param-method_name                = is_task_call_process-method_name.
      ls_ztask_func_param-not_found                  = abap_true.
      ls_ztask_func_param-shm_management             = abap_true. &quot;Par défaut
      ls_ztask_func_param-data_compress_line_by_line = abap_true. &quot;Par défaut
      INSERT ls_ztask_func_param INTO TABLE zcl_task_param=&gt;mt_ztask_func_param ASSIGNING &lt;lfs_s_task_func_param&gt;.

    ENDIF.

  ENDIF.

  IF &lt;lfs_s_task_func_param&gt; IS ASSIGNED.
    &quot; Retourne les données
    rv_param_guid = &lt;lfs_s_task_func_param&gt;-param_guid.

  ENDIF.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" VERSION="1" LANGU="F" DESCRIPT="Définition de Type - Classe Root (Mémoire partagée)" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" CLSSHAREDMEMORY="X" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <implementing CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" REFCLSNAME="IF_SHM_BUILD_INSTANCE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <attribute CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="MT_TYPE_DEFINITION" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_TYPE_DEFINITION_CLUSTER=&gt;TY_T_TYPE_DEFINITION" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CPDNAME="IF_SHM_BUILD_INSTANCE~BUILD">
   <source>METHOD if_shm_build_instance~build.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

ENDMETHOD.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_ADD" VERSION="1" LANGU="F" DESCRIPT="Définition Type - Ajout" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_ADD" SCONAME="IO_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_ADD" SCONAME="RV_ADDED" VERSION="1" LANGU="F" DESCRIPT="Ajouté dans le Cluster ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN"/>
   <source>METHOD definition_type_add.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_TYPE_ADD                               *
*&amp; Classe          : ZCL_TYPE_DEF_AREAHANDLE_ROOT                      *
*&amp; Description     : Ajout d&apos;une définition de type                    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Création / Modification du type
  &quot; -----------------------------------------------------------

  &quot; Ajout du Type
  me-&gt;__definition_type_add( io_definition ).

  TRY.
      &quot; Ajout de la Définition du Type dans le Cluster
      me-&gt;__definition_cluster_add( io_definition-&gt;absolute_name ).

      &quot; Initialisation Indicateur définition de Type ajoutée correctement
      rv_added = abap_true.

    CATCH zcx_type_definition.
      &quot; Une erreur est survenue

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_DELETE" VERSION="1" LANGU="F" DESCRIPT="Définition Type - Suppression" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_DELETE" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_DELETE" SCONAME="IV_DELETE_INTO_CLUSTER" VERSION="1" LANGU="F" DESCRIPT="Supprimer du Cluster ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_DELETE" SCONAME="EV_SUBRC" VERSION="1" LANGU="F" DESCRIPT="Zone système ABAP : code retour des instructions ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_DELETE" SCONAME="RV_EMPTY_LIST" VERSION="1" LANGU="F" DESCRIPT="Plus de Définition de Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG"/>
   <source>METHOD definition_type_delete.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_TYPE_DELETE                            *
*&amp; Classe          : ZCL_TYPE_DEF_AREAHANDLE_ROOT                      *
*&amp; Description     : Suppression d&apos;une définition de type              *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR : ev_subrc.

  &quot; -----------------------------------------------------------
  &quot; Suppression de la définition du type
  &quot; -----------------------------------------------------------

  rv_empty_list = me-&gt;__definition_type_delete(
    EXPORTING
      iv_type  = iv_type
    IMPORTING
      ev_subrc = ev_subrc
  ).

  IF iv_delete_into_cluster EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Suppression de la définition du type dans le Cluster
    &quot; -----------------------------------------------------------
    me-&gt;__definition_cluster_delete( iv_type ).

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_EXIST" VERSION="1" LANGU="F" DESCRIPT="Définition Type - Existe ?" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_EXIST" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_EXIST" SCONAME="IO_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_EXIST" SCONAME="RV_FOUND" VERSION="1" LANGU="F" DESCRIPT="Existe ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG"/>
   <source>METHOD definition_type_exist.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_TYPE_EXIST                             *
*&amp; Classe          : ZCL_TYPE_DEF_AREAHANDLE_ROOT                      *
*&amp; Description     : Détermine si la définition de type existe déjà    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv__type_intern TYPE zcl_type_definition_cluster=&gt;ty_type_definition-type.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Initialisation valeur à utiliser
  &quot; -----------------------------------------------------------

  IF NOT iv_type IS INITIAL.
    &quot; Utilisation du Type
    lv__type_intern = iv_type.

  ELSEIF io_definition IS BOUND.
    &quot; Utiliasation instance
    lv__type_intern = io_definition-&gt;absolute_name.

  ELSE.
    &quot; Aucun paramètre
    &quot;&quot;  --&gt; On retourne Type trouvé.
    rv_found = abap_true.
    RETURN.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Initialisation valeur à utiliser
      &quot; -----------------------------------------------------------

      &quot; Recherche si la définition de type existe
      rv_found = xsdbool( line_exists( me-&gt;mt_type_definition[ __type_intern = lv__type_intern ] ) ). &quot;Vrai si Définition Type existe

    CATCH cx_sy_itab_line_not_found.
      &quot; Le Type n&apos;existe pas
      &quot;&quot;  --&gt; Réinitialisation indicateur
      CLEAR : rv_found.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_GET" VERSION="1" LANGU="F" DESCRIPT="Définition Type - Récupération" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_GET" SCONAME="IV_TYPE" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="DEFINITION_TYPE_GET" SCONAME="RO_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
   <source>METHOD definition_type_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : DEFINITION_TYPE_GET                               *
*&amp; Classe          : ZCL_TYPE_DEF_AREAHANDLE_ROOT                      *
*&amp; Description     : Récupération d&apos;une définition de type             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  IF me-&gt;definition_type_exist( iv_type ) EQ abap_false.
    TRY.
        &quot; -----------------------------------------------------------
        &quot; Récupération définition du Type dans le Cluster
        &quot; -----------------------------------------------------------

        me-&gt;__definition_cluster_get( iv_type ).

      CATCH zcx_type_definition.
        &quot; Une erreur est survenue lors de la récupération du Type
        &quot;&quot;  --&gt; Arrêt du traitement
        RETURN.

    ENDTRY.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Récupération définition du Type
      &quot; -----------------------------------------------------------

      &quot; Récupération du Type
      ro_definition = me-&gt;__definition_type_get( iv_type ).

    CATCH zcx_type_definition.
      &quot; Une erreur est survenue lors de la récupération du Type
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_CLUSTER_ADD" VERSION="1" LANGU="F" DESCRIPT="Internal use - Définition Type - Cluster - Export to DB" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_CLUSTER_ADD" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_CLUSTER_ADD" SCONAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD __definition_cluster_add.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __DEFINITION_CLUSTER_ADD                          *
*&amp; Classe          : ZCL_TYPE_DEF_AREAHANDLE_ROOT                      *
*&amp; Description     : Usage Interne - Export définition de type         *
*                    stocker dans Cluster &quot;ZCLUST_TYPE_DEF&quot;            *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
        lt_type_definition TYPE zcl_type_definition_cluster=&gt;ty_t_type_definition.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_textid         TYPE scx_t100key,
    ls_clust_type_def TYPE zclust_type_def.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_cx_exception TYPE REF TO cx_root.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_srtfd                   TYPE zclust_type_def-srtfd,
    lv_type_definition_xml     TYPE xstring,
    lv_type_definition_xml_zip TYPE xstring.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération de la définition du type
  &quot; -----------------------------------------------------------

  &quot; Récupération position du Type correspondant
  READ TABLE me-&gt;mt_type_definition WITH KEY second_key
                                  COMPONENTS __type_intern_parent_higher = iv_type
                               TRANSPORTING NO FIELDS.
  IF sy-subrc NE 0.
    &quot; Le Type n&apos;a pas été chargé // Ajout de la définition impossible
    &quot;&quot;  --&gt; Arrêt du traitement
    ls_textid-msgid = &apos;CO&apos;.                                 &quot;#EC NOTEXT
    ls_textid-msgno = 051.
    ls_textid-attr1 = iv_type.
    RAISE EXCEPTION TYPE zcx_type_definition
      EXPORTING
        textid = ls_textid.

  ENDIF.

  &quot; Alimentation table interne de la définition du type
  LOOP AT me-&gt;mt_type_definition ASSIGNING FIELD-SYMBOL(&lt;lfs_s_type_definition&gt;)
                                      FROM sy-tabix USING KEY second_key.

    IF &lt;lfs_s_type_definition&gt;-__type_intern_parent_higher NE iv_type.
      &quot; On ne traite plus le même Type
      &quot;&quot;  --&gt; Arrêt de la boucle
      EXIT.

    ENDIF.

    &quot; Ajout de l&apos;entrée
    INSERT &lt;lfs_s_type_definition&gt; INTO TABLE lt_type_definition.

  ENDLOOP.

  IF lt_type_definition[] IS INITIAL.
    &quot; Aucune données récupérées
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Ajout de la Définition du Type dans le Cluster
      &quot; -----------------------------------------------------------

    zcl_type_definition_cluster=&gt;definition_add(
      iv_type            = iv_type
      it_type_definition = lt_type_definition
    ).

    CATCH zcx_type_definition_cluster INTO lo_cx_exception.
      &quot; Erreur enregistrement dans le Cluster
      &quot;&quot;  --&gt; Lève une exception
      RAISE EXCEPTION TYPE zcx_type_definition
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_CLUSTER_DELETE" VERSION="1" LANGU="F" DESCRIPT="Internal use - Définition Type - Cluster - Delete into DB" EXPOSURE="0" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_CLUSTER_DELETE" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_CLUSTER_DELETE" SCONAME="RV_DELETED" VERSION="1" LANGU="F" DESCRIPT="Supprimé du Cluster ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_CLUSTER_DELETE" SCONAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD __definition_cluster_delete.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __DEFINITION_CLUSTER_DELETE                       *
*&amp; Classe          : ZCL_TYPE_DEF_AREAHANDLE_ROOT                      *
*&amp; Description     : Usage Interne - Suppression définition de type    *
*                    stockée dans Cluster &quot;ZCLUST_TYPE_DEF&quot;            *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Suppression de la définition du Type
      &quot; -----------------------------------------------------------

      &quot; Suppression de la Définition du Type dans Cluster
      rv_deleted = zcl_type_definition_cluster=&gt;definition_del( iv_type ).

    CATCH zcx_type_definition_cluster INTO DATA(lo_cx_exception).
      &quot; Une erreur est survenue lors de la suppression
      RAISE EXCEPTION TYPE zcx_type_definition
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_CLUSTER_GET" VERSION="1" LANGU="F" DESCRIPT="Internal use - Définition Type - Cluster - Import from DB" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_CLUSTER_GET" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_CLUSTER_GET" SCONAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD __definition_cluster_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __DEFINITION_CLUSTER_GET                          *
*&amp; Classe          : ZCL_TYPE_DEF_AREAHANDLE_ROOT                      *
*&amp; Description     : Usage Interne - Récupération définition de type   *
*                    stocker dans Cluster &quot;ZCLUST_TYPE_DEF&quot;            *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle
  &quot; -----------------------------------------------------------

  IF me-&gt;definition_type_exist( iv_type ) EQ abap_true.
    &quot; La définition est déjà chargée
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  TRY.
      &quot; Ajout de la Définition du Type
      INSERT LINES OF zcl_type_definition_cluster=&gt;definition_get( iv_type ) INTO TABLE me-&gt;mt_type_definition.

    CATCH zcx_type_definition_cluster INTO DATA(lo_cx_exception).
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Lève l&apos;Exception
      RAISE EXCEPTION TYPE zcx_type_definition
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_ADD" VERSION="1" LANGU="F" DESCRIPT="Internal use - Définition Type - Ajout" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_ADD" SCONAME="IO_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_ADD" SCONAME="IV_SUBTYPE_GUID" VERSION="1" LANGU="F" DESCRIPT="GUID Sous-Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYSUUID_C32" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_ADD" SCONAME="IV__TYPE_INTERN_PARENT" VERSION="1" LANGU="F" DESCRIPT="__Type Interne Parent" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_ADD" SCONAME="IV__TYPE_INTERN_PARENT_HIGHER" VERSION="1" LANGU="F" DESCRIPT="__ Type Interne de plus haut niveau" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
   <source>METHOD __definition_type_add.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __DEFINITION_TYPE_ADD                             *
*&amp; Classe          : ZCL_TYPE_DEF_AREAHANDLE_ROOT                      *
*&amp; Description     : Usage Interne - Ajout d&apos;une définition de type    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_abap_elemdescr   TYPE REF TO cl_abap_elemdescr,
    lo_abap_datadescr   TYPE REF TO cl_abap_datadescr,
    lo_abap_tabledescr  TYPE REF TO cl_abap_tabledescr,
    lo_abap_structdescr TYPE REF TO cl_abap_structdescr.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_type_definition   TYPE zcl_type_definition_cluster=&gt;ty_type_definition,
    ls_components_intern TYPE zcl_type_definition_cluster=&gt;ty_components_intern.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv__type_intern TYPE string.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Pré-Traitement
  &quot; -----------------------------------------------------------

  IF NOT iv_subtype_guid IS INITIAL.
    &quot; Cas d&apos;un sous-élèment
    &quot;&quot;  --&gt; Initialisation Type à la valeur du GUID transmis
    lv__type_intern = iv_subtype_guid.

  ELSE.
    &quot;Cas d&apos;un élèment &quot;classique&quot;
    &quot;&quot;  --&gt; Initialisation Type au nom du Type
    lv__type_intern = io_definition-&gt;absolute_name.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Création / Modification du type
  &quot; -----------------------------------------------------------

  &quot; Récupération de la définition du Type existante
  READ TABLE me-&gt;mt_type_definition WITH TABLE KEY __type_intern = lv__type_intern
                                         ASSIGNING FIELD-SYMBOL(&lt;lfs_s_type_definition&gt;).
  IF sy-subrc NE 0.
    &quot; Le Type n&apos;existe pas
    &quot;&quot;  --&gt; Création d&apos;une nouvelle entrée
    ls_type_definition-type                        = io_definition-&gt;absolute_name.
    ls_type_definition-kind                        = io_definition-&gt;kind.
    ls_type_definition-__type_intern               = lv__type_intern.
    IF NOT iv__type_intern_parent IS INITIAL.
      &quot; Définition de Type &quot;fils&quot;
      &quot;&quot;  --&gt; Initialisation de l&apos;identifiant du Niveau au-dessus
      ls_type_definition-__type_intern_parent = iv__type_intern_parent.

    ELSE.
      &quot; Définition de Type &quot;Parent&quot;
      &quot;&quot;  --&gt; Initialisation Niveau au-dessu avec ce type
      ls_type_definition-__type_intern_parent = lv__type_intern.

    ENDIF.

    IF NOT iv__type_intern_parent_higher IS INITIAL.
      &quot; Définition de Type &quot;fils&quot;
      &quot;&quot;  --&gt; Initialisation de l&apos;identifiant du Niveau Plus Haut
      ls_type_definition-__type_intern_parent_higher = iv__type_intern_parent_higher.

    ELSE.
      &quot; Définition de Type &quot;Parent&quot;
      &quot;&quot;  --&gt; Initialisation Niveau Plus Haut avec ce type
      ls_type_definition-__type_intern_parent_higher = lv__type_intern.

    ENDIF.

    &quot;&quot;  --&gt; Ajout de l&apos;entrée
    INSERT ls_type_definition INTO TABLE me-&gt;mt_type_definition ASSIGNING &lt;lfs_s_type_definition&gt;.

  ENDIF.

  &quot; Suivant le type de données
  IF io_definition-&gt;kind EQ cl_abap_typedescr=&gt;kind_elem.
    &quot; Elementaire
    lo_abap_datadescr ?= io_definition.

  ELSEIF io_definition-&gt;kind EQ cl_abap_typedescr=&gt;kind_table
      OR io_definition-&gt;kind EQ cl_abap_typedescr=&gt;kind_struct.
    &quot; Table ou Structure
    IF io_definition-&gt;kind EQ cl_abap_typedescr=&gt;kind_table.
      &quot; Table
      &quot;&quot;  --&gt; Move-Cast dans le bon type
      lo_abap_tabledescr ?= io_definition.

      &quot;&quot;  --&gt; Initialisation type de table
      &lt;lfs_s_type_definition&gt;-table_kind = lo_abap_tabledescr-&gt;table_kind.

      &quot;&quot;  --&gt; Récupération des Clefs
      &lt;lfs_s_type_definition&gt;-table_key = lo_abap_tabledescr-&gt;get_keys( ).

      TRY.
          &quot;&quot;  --&gt; Récupération structure utilisé
          lo_abap_structdescr ?= lo_abap_tabledescr-&gt;get_table_line_type( ).

        CATCH cx_sy_move_cast_error.
          &quot; Type de table de données Elémentaire
          TRY.
              &quot;&quot;  --&gt; Récupération description
              lo_abap_elemdescr ?= lo_abap_tabledescr-&gt;get_table_line_type( ).

              &quot;&quot;  --&gt; Initialisation indicateur table de données Elémentaire
              &lt;lfs_s_type_definition&gt;-rowkind = lo_abap_elemdescr-&gt;kind.

              &quot;&quot;  --&gt; Ajout de l&apos;entrée
              ls_components_intern-name     = &apos;TABLE_LINE&apos;. &quot;#EC NOTEXT
              ls_components_intern-position = 1.
              ls_components_intern-type     = lo_abap_elemdescr-&gt;absolute_name.
              APPEND ls_components_intern TO &lt;lfs_s_type_definition&gt;-t_components_intern.

              &quot;&quot;  --&gt; Arrêt du traitement
              RETURN.

            CATCH cx_root.
              &quot; Autre cas
              &quot;&quot;  --&gt; Non géré // Arrêt du traitement
              RETURN.

          ENDTRY.

      ENDTRY.

    ELSE.
      &quot; Structure
      lo_abap_structdescr ?= io_definition.

    ENDIF.

    &quot; Récupération des champs
    LOOP AT lo_abap_structdescr-&gt;get_components( ) ASSIGNING FIELD-SYMBOL(&lt;lfs_s_components&gt;).

      CLEAR : ls_components_intern.

      &quot; Initialisation des données
      ls_components_intern-type     = &lt;lfs_s_components&gt;-type-&gt;absolute_name.
      ls_components_intern-name     = &lt;lfs_s_components&gt;-name.
      ls_components_intern-position = sy-tabix.

      IF &lt;lfs_s_components&gt;-type-&gt;is_ddic_type( ) EQ abap_false.
        &quot; Encore un type non DDIC
        TRY.
            &quot;&quot;  --&gt; Génération ID Unique
            ls_components_intern-subtype_guid = cl_system_uuid=&gt;create_uuid_c32_static( ).

          CATCH cx_uuid_error.
            &quot; Erreur génération GUID
            &quot;&quot;  --&gt; Génération ID aléatoire
            ls_components_intern-subtype_guid = cl_abap_random=&gt;seed( ).

        ENDTRY.

        &quot;&quot;  --&gt; Appel récursif pour stockage définition du type
        me-&gt;__definition_type_add(
          io_definition                 = &lt;lfs_s_components&gt;-type
          iv_subtype_guid               = ls_components_intern-subtype_guid
          iv__type_intern_parent        = &lt;lfs_s_type_definition&gt;-__type_intern
          iv__type_intern_parent_higher = &lt;lfs_s_type_definition&gt;-__type_intern_parent_higher
        ).

      ENDIF.

      &quot; Ajout de l&apos;entrée
      APPEND ls_components_intern TO &lt;lfs_s_type_definition&gt;-t_components_intern.

    ENDLOOP.

    &quot; Tri dans le doute ...
    SORT &lt;lfs_s_type_definition&gt;-t_components_intern BY position.

  ELSE.
    &quot; Autre
    &quot;&quot;  --&gt; Non géré
    RETURN.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_DELETE" VERSION="1" LANGU="F" DESCRIPT="Internal use - Définition Type - Suppression" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_DELETE" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_DELETE" SCONAME="EV_SUBRC" VERSION="1" LANGU="F" DESCRIPT="Zone système ABAP : code retour des instructions ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_DELETE" SCONAME="RV_EMPTY_LIST" VERSION="1" LANGU="F" DESCRIPT="Plus de Définition de Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG"/>
   <source>METHOD __definition_type_delete.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __DEFINITION_TYPE_DELETE                          *
*&amp; Classe          : ZCL_TYPE_DEF_AREAHANDLE_ROOT                      *
*&amp; Description     : Suppression d&apos;une définition de type              *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR : ev_subrc.

  &quot; -----------------------------------------------------------
  &quot; Suppression de la définition du type
  &quot; -----------------------------------------------------------

  &quot; Recherche si la définition de type existe
  READ TABLE me-&gt;mt_type_definition WITH TABLE KEY __type_intern = iv_type
                                      TRANSPORTING NO FIELDS.
  IF sy-subrc EQ 0.
    &quot; La définition du type existe
    &quot;&quot;  --&gt; Suppression du Type
    DELETE me-&gt;mt_type_definition INDEX sy-tabix.
    ev_subrc = sy-subrc.

    &quot;&quot;  --&gt; Suppression des Types Fils
    DELETE me-&gt;mt_type_definition USING KEY second_key WHERE __type_intern_parent_higher = iv_type.

  ENDIF.

  &quot; Retourne Liste Vide
  rv_empty_list = xsdbool( me-&gt;mt_type_definition[] IS INITIAL ). &quot;Vrai si plus de définition de Type

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_GET" VERSION="1" LANGU="F" DESCRIPT="Internal use - Définition Type - Récupération" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_GET" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_GET" SCONAME="RO_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
   <exception CLSNAME="ZCL_TYPE_DEF_AREAHANDLE_ROOT" CMPNAME="__DEFINITION_TYPE_GET" SCONAME="ZCX_TYPE_DEFINITION" VERSION="1" LANGU="F" DESCRIPT="Définition Type - SHM - Classe exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD __definition_type_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __DEFINITION_TYPE_GET                             *
*&amp; Classe          : ZCL_TYPE_DEF_AREAHANDLE_ROOT                      *
*&amp; Description     : Usage Interne - Récupération définition de type   *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_key        TYPE abap_keydescr_tab,
    lt_components TYPE cl_abap_structdescr=&gt;component_table.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_key        TYPE         abap_keydescr,
    ls_components TYPE LINE OF cl_abap_structdescr=&gt;component_table.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_table            TYPE REF TO data,
    lo_cx_exception     TYPE REF TO cx_root,
    lo_abap_elemdescr   TYPE REF TO cl_abap_elemdescr,
    lo_abap_datadescr   TYPE REF TO cl_abap_datadescr,
    lo_abap_tabledescr  TYPE REF TO cl_abap_tabledescr,
    lo_abap_structdescr TYPE REF TO cl_abap_structdescr.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_elemen_type TYPE string.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_s_table_key&gt; TYPE abap_table_keydescr.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération de la définition du Type
  &quot; -----------------------------------------------------------

  &quot; Récupération de la définition du type
  READ TABLE me-&gt;mt_type_definition WITH TABLE KEY __type_intern = iv_type
                                         ASSIGNING FIELD-SYMBOL(&lt;lfs_s_type_definition&gt;).
  IF sy-subrc NE 0.
    &quot; Aucune correspondance
    &quot;&quot;  --&gt; Arrêt du traitment
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Retourne la définition du Type
  &quot; -----------------------------------------------------------

  IF &lt;lfs_s_type_definition&gt;-kind EQ cl_abap_typedescr=&gt;kind_elem.
    &quot; Elementaire
    ro_definition = cl_abap_typedescr=&gt;describe_by_name( p_name = &lt;lfs_s_type_definition&gt;-type ).

  ELSEIF &lt;lfs_s_type_definition&gt;-kind EQ cl_abap_typedescr=&gt;kind_table
      OR &lt;lfs_s_type_definition&gt;-kind EQ cl_abap_typedescr=&gt;kind_struct.
    &quot; Table ou Structure

    TRY.

        IF NOT &lt;lfs_s_type_definition&gt;-rowkind IS INITIAL.
          &quot; Table de données &quot;spéciale&quot;
          &quot;&quot;  --&gt; Suivant le type de ligne
          CASE &lt;lfs_s_type_definition&gt;-rowkind.

            WHEN &apos;E&apos;.                                       &quot;#EC NOTEXT
              &quot;Elémentaire
              &quot;&quot;  --&gt; Récupération définition élèment
              lo_abap_elemdescr ?= cl_abap_elemdescr=&gt;describe_by_name( &lt;lfs_s_type_definition&gt;-t_components_intern[ 1 ]-type ).

              &quot;&quot;  --&gt; Création de la table suivant type de table
              CASE &lt;lfs_s_type_definition&gt;-table_kind.

                WHEN cl_abap_tabledescr=&gt;tablekind_std
                  OR cl_abap_tabledescr=&gt;tablekind_any.
                  &quot; Table de type standard
                  CREATE DATA lo_table TYPE STANDARD TABLE OF (lo_abap_elemdescr-&gt;absolute_name).

                WHEN cl_abap_tabledescr=&gt;tablekind_hashed.
                  &quot; Table hashée
                  CREATE DATA lo_table TYPE HASHED TABLE OF (lo_abap_elemdescr-&gt;absolute_name) WITH UNIQUE KEY table_line.

                WHEN cl_abap_tabledescr=&gt;tablekind_index
                  OR cl_abap_tabledescr=&gt;tablekind_sorted.
                  &quot; Table de type triée
                  CREATE DATA lo_table TYPE SORTED TABLE OF (lo_abap_elemdescr-&gt;absolute_name) WITH UNIQUE KEY table_line.

                WHEN OTHERS.
                  &quot; Autres

              ENDCASE.

            WHEN OTHERS.
              &quot; Autre

          ENDCASE.

          IF lo_table IS BOUND.
            &quot; Retourne définition du type
            ro_definition = cl_abap_typedescr=&gt;describe_by_data_ref( lo_table ).

          ENDIF.

        ELSE.
          &quot; Table de données structurées
          &quot;&quot;  --&gt; Préparation de la structure
          LOOP AT &lt;lfs_s_type_definition&gt;-t_components_intern ASSIGNING FIELD-SYMBOL(&lt;lfs_s_components_intern&gt;).

            CLEAR : ls_components.

            &quot; Initialisation des données
            ls_components-name = &lt;lfs_s_components_intern&gt;-name.

            IF &lt;lfs_s_components_intern&gt;-subtype_guid IS INITIAL.
              &quot; Type DDIC
              ls_components-type ?= cl_abap_datadescr=&gt;describe_by_name( &lt;lfs_s_components_intern&gt;-type ).

            ELSE.
              &quot; Type non DDIC
              TRY.
                  &quot;&quot;  --&gt; Récupération du Type via définition
                  ls_components-type ?= me-&gt;__definition_type_get( iv_type = &lt;lfs_s_components_intern&gt;-subtype_guid ).

                CATCH zcx_type_definition INTO lo_cx_exception.
                  &quot; Une erreur est survenue
                  &quot;&quot;  --&gt; Lève l&apos;Exception
                  WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
                  RAISE EXCEPTION TYPE zcx_type_definition
                    EXPORTING
                      previous = lo_cx_exception.

              ENDTRY.

            ENDIF.

            &quot; Ajout de l&apos;entrée
            APPEND ls_components TO lt_components.

          ENDLOOP.

          &quot;&quot;  --&gt; Création de la structure
          lo_abap_structdescr = cl_abap_structdescr=&gt;create( p_components = lt_components ).

          IF &lt;lfs_s_type_definition&gt;-kind EQ cl_abap_typedescr=&gt;kind_table.
            &quot; Table
            &quot;&quot;  --&gt; Conversion dans le type attendu
            lo_abap_datadescr ?= lo_abap_structdescr.

            TRY.

                IF lines( &lt;lfs_s_type_definition&gt;-table_key ) EQ 1
                AND NOT line_exists( &lt;lfs_s_type_definition&gt;-table_key[ key_kind = cl_abap_tabledescr=&gt;keydefkind_user ] ). &quot;Définition clef Utilisateur
                  &quot; Une seule clef et non défini par l&apos;utilisateur
                  READ TABLE &lt;lfs_s_type_definition&gt;-table_key INDEX 1 ASSIGNING &lt;lfs_s_table_key&gt;.
                  APPEND &lt;lfs_s_table_key&gt;-name TO lt_key.

                  &quot;&quot;  --&gt; Création du type de table
                  lo_abap_tabledescr = cl_abap_tabledescr=&gt;create(
                    p_line_type  = lo_abap_datadescr
                    p_table_kind = &lt;lfs_s_type_definition&gt;-table_kind
                    p_unique     = &lt;lfs_s_table_key&gt;-is_unique
                    p_key        = lt_key
                    p_key_kind   = &lt;lfs_s_table_key&gt;-key_kind
                  ).

                ELSE.
                  &quot; Plusieurs Clefs ou au moins une définie par l&apos;utilisateur
                  &quot;&quot;  --&gt; Création du type de table avec plusieurs avec Clefs
                  lo_abap_tabledescr = cl_abap_tabledescr=&gt;create_with_keys(
                    p_line_type    = lo_abap_datadescr
                    p_keys         = &lt;lfs_s_type_definition&gt;-table_key
                 ).

                ENDIF.

              CATCH cx_root.
                &quot; Erreur lors de la création de la table avec les Clefs spécifié
                &quot;&quot;  --&gt; Création de la table sans Clefs
                lo_abap_tabledescr = cl_abap_tabledescr=&gt;create(
                  p_line_type  = lo_abap_datadescr
                  p_table_kind = &lt;lfs_s_type_definition&gt;-table_kind
                ).

            ENDTRY.

            &quot;&quot;  --&gt; Retourne la définition du type
            ro_definition ?= lo_abap_tabledescr.

          ELSE.
            &quot; Structure
            &quot;&quot;  --&gt; Retourne la définition du type
            ro_definition ?= lo_abap_structdescr.

          ENDIF.

        ENDIF.

      CATCH cx_root INTO lo_cx_exception.
        &quot; Erreur lors de la création de la structure
        &quot;&quot;  --&gt; Arrêt du traitement
        WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
        RAISE EXCEPTION TYPE zcx_type_definition
          EXPORTING
            previous = lo_cx_exception.

    ENDTRY.

  ELSE.
    &quot; Autre
    &quot;&quot;  --&gt; Non géré
    RETURN.

  ENDIF.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_SHM" VERSION="1" LANGU="F" DESCRIPT="Tâche - Exploitation SHM" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_TASK_SHM" CMPNAME="TS_INSTANCE" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="7 " SRCCOLUMN2="23 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_instance,
      type     TYPE        shm_inst_name,
      instance TYPE REF TO zcl_task_shm,
    END OF   ts_instance
"/>
  <types CLSNAME="ZCL_TASK_SHM" CMPNAME="TT_INSTANCE" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="4 " SRCROW2="10 " SRCCOLUMN2="60 " TYPESRC_LENG="0 " TYPESRC="tt_instance TYPE SORTED TABLE OF ts_instance
                  WITH UNIQUE KEY primary_key COMPONENTS type
"/>
  <types CLSNAME="ZCL_TASK_SHM" CMPNAME="TS_SHM_AREA" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="12 " SRCCOLUMN1="4 " SRCROW2="15 " SRCCOLUMN2="23 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_shm_area,
      shm_area_name     TYPE        shm_inst_name,
      shm_area_instance TYPE REF TO zcl_task_shm_area,
    END OF   ts_shm_area
"/>
  <types CLSNAME="ZCL_TASK_SHM" CMPNAME="TS_PERSISTENT_DATA" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="17 " SRCCOLUMN1="4 " SRCROW2="19 " SRCCOLUMN2="34 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_persistent_data,
          t_instance TYPE zcl_task_shm=&gt;tt_instance,
        END OF   ts_persistent_data
"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_TASK_SHM" CMPNAME="MS_PERSISTENT_DATA" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_TASK_SHM=&gt;TS_PERSISTENT_DATA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_SHM" CMPNAME="MS_SHM_AREA" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_TASK_SHM=&gt;TS_SHM_AREA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TASK_SHM" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CONSTRUCTOR" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="CONSTRUCTOR" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <exception CLSNAME="ZCL_TASK_SHM" CMPNAME="CONSTRUCTOR" SCONAME="ZCX_TASK_SHM" VERSION="1" LANGU="F" DESCRIPT="Tâche - SHM - Classe exception" MTDTYPE="2" EDITORDER="1 "/>
   <source>METHOD constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_TASK_SHM                                      *
*&amp; Description     : Création instance pour utilisation SHM Task       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception  TYPE REF TO cx_root,
    lo_attach_write  TYPE REF TO zcl_task_shm_area,
    lo_task_shm_root TYPE REF TO zcl_task_shm_root.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Récupération version courante
      &quot; -----------------------------------------------------------

      &quot; Lecture de la version courante
      me-&gt;ms_shm_area-shm_area_name     = iv_type.
      me-&gt;ms_shm_area-shm_area_instance = zcl_task_shm_area=&gt;attach_for_read( me-&gt;ms_shm_area-shm_area_name ).

    CATCH cx_shm_no_active_version.
      &quot; Aucune version existante
      TRY.
          &quot;&quot;  --&gt; Création instance d&apos;écriture
          lo_attach_write = zcl_task_shm_area=&gt;attach_for_write( me-&gt;ms_shm_area-shm_area_name ).

          &quot;&quot;  --&gt; Création d&apos;une nouvelle version
          CREATE OBJECT lo_task_shm_root AREA HANDLE lo_attach_write.

          &quot;&quot;  --&gt; Initialisation de la version
          lo_attach_write-&gt;set_root( lo_task_shm_root ).

          &quot;&quot;  --&gt; Sauvegarde la version
          lo_attach_write-&gt;detach_commit( ).

          &quot;&quot;  --&gt; Récupère l&apos;instance de lecture
          me-&gt;ms_shm_area-shm_area_instance = zcl_task_shm_area=&gt;attach_for_read( me-&gt;ms_shm_area-shm_area_name ).

        CATCH cx_root INTO lo_cx_exception.
          &quot; Une erreur est survenue
          &quot;&quot;  --&gt; Lève l&apos;exception
          WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
          RAISE EXCEPTION TYPE zcx_task_shm
            EXPORTING
              previous = lo_cx_exception.

      ENDTRY.

    CATCH cx_root INTO lo_cx_exception.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Lève l&apos;exception
      WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
      RAISE EXCEPTION TYPE zcx_task_shm
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM" CMPNAME="GET_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="SHM - Récupération instance" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="GET_INSTANCE" SCONAME="IV_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="GET_INSTANCE" SCONAME="RO_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="Tâche - Exploitation SHM" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK_SHM"/>
   <source>METHOD get_instance.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_TASK_SHM                                      *
*&amp; Description     : Création instance pour utilisation SHM Task       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_instance TYPE zcl_task_shm=&gt;ts_instance.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération version courante
  &quot; -----------------------------------------------------------

  READ TABLE zcl_task_shm=&gt;ms_persistent_data-t_instance WITH TABLE KEY type = CONV shm_inst_name( iv_type )
                                                              ASSIGNING FIELD-SYMBOL(&lt;lfs_s_instance&gt;).
  IF sy-subrc NE 0.
    &quot; Instance non existante pour ce MF
    &quot;&quot;  --&gt; Création nouvelle entrée
    ls_instance-type = iv_type.

    &quot;&quot;  --&gt; Création de l&apos;instance
    CREATE OBJECT ls_instance-instance
      EXPORTING
        iv_type = iv_type.

    &quot;&quot;  --&gt; Ajout de l&apos;entrée
    INSERT ls_instance INTO TABLE zcl_task_shm=&gt;ms_persistent_data-t_instance ASSIGNING &lt;lfs_s_instance&gt;.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Retourne l&apos;instance
  &quot; -----------------------------------------------------------

  ro_instance = &lt;lfs_s_instance&gt;-instance.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM" CMPNAME="TASK_MANAGER_DEREGISTER" VERSION="1" LANGU="F" DESCRIPT="SHM - Désenregistrement Manager Tâche" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="TASK_MANAGER_DEREGISTER" SCONAME="IV_TASK_MANAGER_ID" VERSION="1" LANGU="F" DESCRIPT="ID Manager de Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTASK_MANAGER_ID"/>
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="TASK_MANAGER_DEREGISTER" SCONAME="RV_SUBRC" VERSION="1" LANGU="F" DESCRIPT="Zone système ABAP : code retour des instructions ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <exception CLSNAME="ZCL_TASK_SHM" CMPNAME="TASK_MANAGER_DEREGISTER" SCONAME="ZCX_TASK_SHM" VERSION="1" LANGU="F" DESCRIPT="Tâche - SHM - Classe exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD task_manager_deregister.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_DEREGISTER                                   *
*&amp; Classe          : ZCL_TASK_SHM                                      *
*&amp; Description     : Désenregistrement du Manager de Tâche             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception  TYPE REF TO cx_root,
    lo_attach_update TYPE REF TO zcl_task_shm_area.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_empty TYPE flag.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle présence de l&apos;ID
  &quot; -----------------------------------------------------------

  IF me-&gt;ms_shm_area-shm_area_instance-&gt;root-&gt;task_manager_is_registered( iv_task_manager_id ) EQ abap_false.
    &quot; ID inexistant
    &quot;&quot; --&gt; Ne rien faire
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Récupération version courante
  &quot; -----------------------------------------------------------

  TRY.
      &quot;&quot;  --&gt;  Récupération instance de mise à jour
      lo_attach_update = zcl_task_shm_area=&gt;attach_for_update( me-&gt;ms_shm_area-shm_area_name ).

      &quot;&quot;  --&gt; Suppression de l&apos;ID du Manager de Tâche
      lv_empty = lo_attach_update-&gt;root-&gt;task_manager_deregister( iv_task_manager_id ).

      &quot;&quot;  --&gt; Pousse la mise à jour
      lo_attach_update-&gt;detach_commit( ).

      IF me-&gt;ms_shm_area-shm_area_instance-&gt;is_active_version( ) EQ abap_false.
        &quot;&quot;  --&gt; Libère le Token courant
        me-&gt;ms_shm_area-shm_area_instance-&gt;detach( ).

        IF lv_empty EQ abap_false.
          &quot; Il reste des Tâches affectés
          &quot;&quot;  --&gt; Recharge l&apos;instance de lecture
          me-&gt;ms_shm_area-shm_area_instance = zcl_task_shm_area=&gt;attach_for_read( me-&gt;ms_shm_area-shm_area_name ).

        ENDIF.

      ENDIF.

    CATCH cx_root INTO lo_cx_exception.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Retour code en erreur
      rv_subrc = 4.

      &quot;&quot;  --&gt; Lève l&apos;exception
      WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
      RAISE EXCEPTION TYPE zcx_task_shm
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

  IF lv_empty EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Suppression des SHMs inutilisées
    &quot; -----------------------------------------------------------

    TRY.
        &quot; Suppression de la Définition du Type dans la SHM
        zcl_type_definition=&gt;get_instance( )-&gt;definition_type_delete(
            iv_type              = me-&gt;ms_shm_area-shm_area_name
            iv_free_shm_if_empty = abap_true
        ).

      CATCH zcx_type_definition.                         &quot;#EC NOHANDLER
        &quot; Erreur suppression Type dans la SHM
        &quot;&quot;  --&gt; Tant pis ...

    ENDTRY.

    &quot; Suppression de l&apos;entrée dans la SHM des Tâches
    me-&gt;__internal_use_free_shm(
        iv_shm_area_name    = me-&gt;ms_shm_area-shm_area_name
        iv_areas_free       = abap_true
    ).

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM" CMPNAME="TASK_MANAGER_REGISTER" VERSION="1" LANGU="F" DESCRIPT="SHM - Enregistrement Manager Tâche" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="TASK_MANAGER_REGISTER" SCONAME="IV_TASK_MANAGER_ID" VERSION="1" LANGU="F" DESCRIPT="ID Manager de Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZTASK_MANAGER_ID"/>
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="TASK_MANAGER_REGISTER" SCONAME="RV_SUBRC" VERSION="1" LANGU="F" DESCRIPT="Zone système ABAP : code retour des instructions ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <exception CLSNAME="ZCL_TASK_SHM" CMPNAME="TASK_MANAGER_REGISTER" SCONAME="ZCX_TASK_SHM" VERSION="1" LANGU="F" DESCRIPT="Tâche - SHM - Classe exception" MTDTYPE="0" EDITORDER="1 "/>
   <source>METHOD task_manager_register.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TASK_MANAGER_REGISTER                             *
*&amp; Classe          : ZCL_TASK_SHM                                      *
*&amp; Description     : Enregistrement du Manager de Tâche                *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_cx_exception  TYPE REF TO cx_root,
    lo_attach_update TYPE REF TO zcl_task_shm_area.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle Manager de Tâche existante
  &quot; -----------------------------------------------------------

  &quot; Détermine si le Manager de Tâche est enregistrée sur la SHM
  IF me-&gt;ms_shm_area-shm_area_instance-&gt;root-&gt;task_manager_is_registered( iv_task_manager_id ) EQ abap_true.
    &quot; Manager de Tâche existe déjà
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Ajout du Manager de Tâche
  &quot; -----------------------------------------------------------

  TRY.
      &quot;&quot;  --&gt;  Récupération instance de mise à jour
      lo_attach_update = zcl_task_shm_area=&gt;attach_for_update( me-&gt;ms_shm_area-shm_area_name ).

      &quot;&quot;  --&gt; Ajout de l&apos;ID de Manager Tâche
      lo_attach_update-&gt;root-&gt;task_manager_register( iv_task_manager_id ).

      &quot;&quot;  --&gt; Pousse la mise à jour
      lo_attach_update-&gt;detach_commit( ).

      IF me-&gt;ms_shm_area-shm_area_instance-&gt;is_active_version( ) EQ abap_false.
        &quot;&quot;  --&gt; Libère le Token courant
        me-&gt;ms_shm_area-shm_area_instance-&gt;detach( ).

        &quot;&quot;  --&gt; Recharge l&apos;instance de lecture
        me-&gt;ms_shm_area-shm_area_instance = zcl_task_shm_area=&gt;attach_for_read( me-&gt;ms_shm_area-shm_area_name ).

      ENDIF.

    CATCH cx_root INTO lo_cx_exception.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Retour code en erreur
      rv_subrc = 4.

      &quot;&quot;  --&gt; Lève l&apos;exception
      WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
      RAISE EXCEPTION TYPE zcx_task_shm
        EXPORTING
          previous = lo_cx_exception.

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM" CMPNAME="__INTERNAL_USE_FREE_SHM" VERSION="1" LANGU="F" DESCRIPT="SHM - Suppression toutes versions" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="IV_SHM_AREA_NAME" VERSION="1" LANGU="F" DESCRIPT="Nom d&apos;une instance d&apos;objet partagé d&apos;un domaine" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="IV_AREAS_DETACH" VERSION="1" LANGU="F" DESCRIPT="Libére les Tokens" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="IV_AREAS_FREE" VERSION="1" LANGU="F" DESCRIPT="Supprime les Versions" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="IV_AREAS_INVALIDATE" VERSION="1" LANGU="F" DESCRIPT="Invalide les Versions" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM" CMPNAME="__INTERNAL_USE_FREE_SHM" SCONAME="RV_RC" VERSION="1" LANGU="F" DESCRIPT="Valeur de retour (constantes dans CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <source>METHOD __internal_use_free_shm.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : __INTERNAL_USE_FREE_SHM                           *
*&amp; Classe          : ZCL_TASK_SHM                                      *
*&amp; Description     : Usage Interne : Suppression toutes versions       *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  IF NOT iv_shm_area_name IS INITIAL.
    &quot; -----------------------------------------------------------
    &quot; Libération de la Version spécifiée
    &quot; -----------------------------------------------------------

    IF iv_areas_free EQ abap_true.
      &quot; -----------------------------------------------------------
      &quot; Libération de la Version
      &quot; -----------------------------------------------------------

      TRY.
          &quot; Libération de la Version
          rv_rc = zcl_task_shm_area=&gt;free_instance( iv_shm_area_name ).

        CATCH cx_shm_parameter_error.
          &quot; Une erreur est survenue
          rv_rc = cl_shm_area=&gt;rc_nothing_to_be_done.

      ENDTRY.

    ELSEIF iv_areas_invalidate EQ abap_true.
      &quot; -----------------------------------------------------------
      &quot; Invalidation de la Version
      &quot; -----------------------------------------------------------

      TRY.
          &quot; Invalide de la Version
          rv_rc = zcl_task_shm_area=&gt;invalidate_instance( iv_shm_area_name ).

        CATCH cx_shm_parameter_error.
          rv_rc = cl_shm_area=&gt;rc_nothing_to_be_done.

      ENDTRY.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Suppression de l&apos;instance globale
    &quot; -----------------------------------------------------------

    &quot; Suppression de l&apos;entrée dans la globale
    READ TABLE zcl_task_shm=&gt;ms_persistent_data-t_instance WITH TABLE KEY type = iv_shm_area_name
                                                             TRANSPORTING NO FIELDS.
    IF sy-subrc EQ 0.
      &quot; Suppression de l&apos;entrée
      DELETE zcl_task_shm=&gt;ms_persistent_data-t_instance INDEX sy-tabix.

    ENDIF.

  ELSE.
    IF iv_areas_free EQ abap_true.
      &quot; -----------------------------------------------------------
      &quot; Libération des Versions
      &quot; -----------------------------------------------------------

      TRY.
          &quot; Libération des Versions
          rv_rc = zcl_task_shm_area=&gt;free_area( ).

        CATCH cx_shm_parameter_error.
          &quot; Une erreur est survenue
          rv_rc = cl_shm_area=&gt;rc_nothing_to_be_done.

      ENDTRY.

    ELSEIF iv_areas_invalidate EQ abap_true.
      &quot; -----------------------------------------------------------
      &quot; Invalidation des Versions
      &quot; -----------------------------------------------------------

      TRY.
          &quot; Invalide les Versions
          rv_rc = zcl_task_shm_area=&gt;invalidate_area( ).

        CATCH cx_shm_parameter_error.
          rv_rc = cl_shm_area=&gt;rc_nothing_to_be_done.

      ENDTRY.

    ELSEIF iv_areas_detach EQ abap_true.
      &quot; -----------------------------------------------------------
      &quot; Livération des Tokens
      &quot; -----------------------------------------------------------

      &quot; Libération des Tokens
      rv_rc = zcl_task_shm_area=&gt;detach_all_areas( ).

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Suppression des instances globale
    &quot; -----------------------------------------------------------

    FREE : zcl_task_shm=&gt;ms_persistent_data-t_instance.

  ENDIF.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TASK_SHM_AREA" VERSION="1" LANGU="F" DESCRIPT="Tâche - Mémoire partagée" CATEGORY="45" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" RSTAT="S" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CL_SHM_AREA">
  <friends CLSNAME="ZCL_TASK_SHM_AREA" REFCLSNAME="CL_SHM_AREA" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros></localMacros>
  <attribute CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="AREA_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of an Area Class" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="&apos;ZCL_TASK_SHM_AREA&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SHM_AREA_NAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ROOT" VERSION="1" LANGU="F" DESCRIPT="SHM: Model of a Data Class" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_TASK_SHM_ROOT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="_CLIENT_DEPENDENT" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="5 " ATTDECLTYP="2" ATTVALUE="ABAP_FALSE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="_LIFE_CONTEXT" VERSION="1" LANGU="F" DESCRIPT="Lifetime of an Area (Constants in CL_SHM_AREA)" EXPOSURE="0" STATE="1" EDITORDER="6 " ATTDECLTYP="2" ATTVALUE="CL_SHM_AREA=&gt;LIFE_CONTEXT_APPSERVER" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SHM_LIFE_CONTEXT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="_TRACE_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="(Internal) Flag: Trace Active?" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="1" ATTVALUE="ABAP_FALSE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="_TRACE_SERVICE" VERSION="1" LANGU="F" DESCRIPT="(Internal) Reference to Trace Class" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="3" TYPE="IF_SHM_TRACE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="_TRANSACTIONAL" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="2" ATTVALUE="ABAP_FALSE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="_VERSION_" VERSION="1" LANGU="F" DESCRIPT="(internal)" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="22" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCL_TASK_SHM_AREA" REFCLSNAME="CL_SHM_AREA" VERSION="1" STATE="1">
   <redefinition CLSNAME="ZCL_TASK_SHM_AREA" REFCLSNAME="CL_SHM_AREA" VERSION="1" MTDNAME="GET_ROOT" EXPOSURE="0"/>
  </inheritance>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" VERSION="1" LANGU="F" DESCRIPT="Request a Read Lock" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="HANDLE" VERSION="1" LANGU="F" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK_SHM_AREA"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_INCONSISTENT" VERSION="1" LANGU="F" DESCRIPT="Different Definitions Between Program and Area" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_NO_ACTIVE_VERSION" VERSION="1" LANGU="F" DESCRIPT="No active version exists for an attach" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_READ_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Request for a Second Read Lock" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="5 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="A Change Lock Is Already Active" MTDTYPE="0" EDITORDER="6 "/>
   <source>method ATTACH_FOR_READ.

  DATA:
    l_attributes       TYPE shma_attributes,
    l_root             TYPE REF TO object,
    l_cx               TYPE REF TO cx_root,
    l_client           TYPE shm_client,
    l_client_supplied  TYPE abap_bool. &quot;#EC NEEDED

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.


  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_read = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

*   try sneak mode first
    handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                      sneak_mode   = abap_true
                                      life_context = _life_context
                            IMPORTING root         = l_root ).

    IF l_root IS INITIAL.
*     no root object returned, sneak mode was not successful.
*     -&gt; read area properties from database and try again.
      cl_shm_service=&gt;initialize(
        EXPORTING area_name       = handle-&gt;area_name
                  client          = l_client
        IMPORTING attributes      = l_attributes
      ).

      handle-&gt;properties = l_attributes-properties.
      handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                        sneak_mode   = abap_false
                                        life_context = _life_context
                              IMPORTING root         = l_root ).

    ENDIF.

    handle-&gt;root ?= l_root.
*   &lt;

  ELSE.

    TRY.

*       &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                          sneak_mode   = abap_true
                                          life_context = _life_context
                                IMPORTING root         = l_root ).

        IF l_root IS INITIAL.
*         no root object returned, sneak mode was not successful.
*         -&gt; read area properties from database and try again.
          cl_shm_service=&gt;initialize(
            EXPORTING area_name       = handle-&gt;area_name
                      client          = l_client
            IMPORTING attributes      = l_attributes
          ).

          handle-&gt;properties = l_attributes-properties.
          handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                            sneak_mode   = abap_false
                                            life_context = _life_context
                                  IMPORTING root         = l_root ).

        ENDIF.
        handle-&gt;root ?= l_root.

*       &lt;
        _trace_service-&gt;trin_attach_for_read(
          area_name = area_name
          inst_name = inst_name
          client    = l_client ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_read(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" VERSION="1" LANGU="F" DESCRIPT="Request a Change Lock" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="ATTACH_MODE" VERSION="1" LANGU="F" DESCRIPT="Mode of ATTACH (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_ATTACH_MODE" PARVALUE="CL_SHM_AREA=&gt;ATTACH_MODE_DEFAULT"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="WAIT_TIME" VERSION="1" LANGU="F" DESCRIPT="Maximum Wait Time (in Milliseconds)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="0"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="HANDLE" VERSION="1" LANGU="F" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK_SHM_AREA"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_INCONSISTENT" VERSION="1" LANGU="F" DESCRIPT="Different Definitions Between Program and Area" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_NO_ACTIVE_VERSION" VERSION="1" LANGU="F" DESCRIPT="No active version exists for an attach" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_VERSION_LIMIT_EXCEEDED" VERSION="1" LANGU="F" DESCRIPT="No Additional Versions Available" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="A write lock is already active" MTDTYPE="0" EDITORDER="5 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Passed Parameter Has Incorrect Value" MTDTYPE="0" EDITORDER="6 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_PENDING_LOCK_REMOVED" VERSION="1" LANGU="F" DESCRIPT="Shared Objects: Waiting Lock Was Deleted" MTDTYPE="0" EDITORDER="7 "/>
   <source>method ATTACH_FOR_UPDATE.

  DATA:
    l_attributes             TYPE shma_attributes,
    l_root                   TYPE REF TO object,
    l_cx                     TYPE REF TO cx_root,
    l_client                 TYPE shm_client,
    l_client_supplied        TYPE abap_bool, &quot;#EC NEEDED
    l_wait_time              TYPE i,
    l_wait_time_per_loop     TYPE i,
    l_wait_time_per_loop_sec TYPE f.

  l_wait_time = wait_time.

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.


  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_upd = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

    cl_shm_service=&gt;initialize(
      EXPORTING area_name    = handle-&gt;area_name
                client       = l_client
      IMPORTING attributes   = l_attributes
    ).

    handle-&gt;properties = l_attributes-properties.

    handle-&gt;_attach_update70(
      EXPORTING area_name = handle-&gt;area_name
                mode      = attach_mode
      IMPORTING root      = l_root
      CHANGING  wait_time = l_wait_time ).

    IF abap_true = l_attributes-properties-has_versions AND
       handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
      handle-&gt;_attach_update70(
        EXPORTING area_name = handle-&gt;area_name
                  mode      = attach_mode
        IMPORTING root      = l_root
        CHANGING  wait_time = l_wait_time ).
    ENDIF.

    IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
       handle-&gt;_lock IS INITIAL.

      l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
      IF l_wait_time_per_loop &lt; 2000.
        l_wait_time_per_loop = 2000.
      ELSEIF l_wait_time_per_loop &gt; 300000.
        l_wait_time_per_loop = 300000.
      ENDIF.

      l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

      WHILE handle-&gt;_lock IS INITIAL.

        IF l_wait_time_per_loop &gt; l_wait_time.
          l_wait_time_per_loop = l_wait_time.
          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
        ENDIF.

        WAIT UP TO l_wait_time_per_loop_sec SECONDS.
        l_wait_time = l_wait_time - l_wait_time_per_loop.

        handle-&gt;_attach_update70(
          EXPORTING area_name = handle-&gt;area_name
                    mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
          IMPORTING root      = l_root
          CHANGING  wait_time = l_wait_time ).

        IF abap_true = l_attributes-properties-has_versions AND
           handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
          handle-&gt;_attach_update70(
            EXPORTING area_name = handle-&gt;area_name
                      mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
            IMPORTING root      = l_root
            CHANGING  wait_time = l_wait_time ).
        ENDIF.

      ENDWHILE.

    ENDIF.

    handle-&gt;root ?= l_root.

*   &lt;

  ELSE.

    TRY.

*       &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        cl_shm_service=&gt;initialize(
          EXPORTING area_name    = handle-&gt;area_name
                    client       = l_client
          IMPORTING attributes   = l_attributes
        ).

        handle-&gt;properties = l_attributes-properties.

        handle-&gt;_attach_update70(
          EXPORTING area_name = handle-&gt;area_name
                    mode      = attach_mode
          IMPORTING root      = l_root
          CHANGING  wait_time = l_wait_time ).

        IF abap_true = l_attributes-properties-has_versions AND
           handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
          handle-&gt;_attach_update70(
            EXPORTING area_name = handle-&gt;area_name
                      mode      = attach_mode
            IMPORTING root      = l_root
            CHANGING  wait_time = l_wait_time ).
        ENDIF.

        IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
           handle-&gt;_lock IS INITIAL.

          l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
          IF l_wait_time_per_loop &lt; 2000.
            l_wait_time_per_loop = 2000.
          ELSEIF l_wait_time_per_loop &gt; 300000.
            l_wait_time_per_loop = 300000.
          ENDIF.

          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

          WHILE handle-&gt;_lock IS INITIAL.

            IF l_wait_time_per_loop &gt; l_wait_time.
              l_wait_time_per_loop = l_wait_time.
              l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
            ENDIF.

            WAIT UP TO l_wait_time_per_loop_sec SECONDS.
            l_wait_time = l_wait_time - l_wait_time_per_loop.

            handle-&gt;_attach_update70(
              EXPORTING
                area_name = handle-&gt;area_name
                mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
              IMPORTING
                root      = l_root
              CHANGING
                wait_time = l_wait_time ).

            IF abap_true = l_attributes-properties-has_versions AND
               handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
              handle-&gt;_attach_update70(
                EXPORTING
                  area_name = handle-&gt;area_name
                  mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
                IMPORTING
                  root      = l_root
                CHANGING
                  wait_time = l_wait_time ).
            ENDIF.

          ENDWHILE.

        ENDIF.

        handle-&gt;root ?= l_root.

*       &lt;
        _trace_service-&gt;trin_attach_for_update(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_update(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" VERSION="1" LANGU="F" DESCRIPT="Request a Write Lock" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="ATTACH_MODE" VERSION="1" LANGU="F" DESCRIPT="Mode of ATTACH (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_ATTACH_MODE" PARVALUE="CL_SHM_AREA=&gt;ATTACH_MODE_DEFAULT"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="WAIT_TIME" VERSION="1" LANGU="F" DESCRIPT="Maximum Wait Time (in Milliseconds)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="0"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="HANDLE" VERSION="1" LANGU="F" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TASK_SHM_AREA"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_VERSION_LIMIT_EXCEEDED" VERSION="1" LANGU="F" DESCRIPT="No Additional Versions Available" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="F" DESCRIPT="A write lock is already active" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Passed Parameter Has Incorrect Value" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_PENDING_LOCK_REMOVED" VERSION="1" LANGU="F" DESCRIPT="Shared Objects: Waiting Lock Was Deleted" MTDTYPE="0" EDITORDER="5 "/>
   <source>method ATTACH_FOR_WRITE.

  DATA:
    l_attributes             TYPE shma_attributes,
    l_cx                     TYPE REF TO cx_root,
    l_client                 TYPE shm_client,
    l_client_supplied        TYPE abap_bool, &quot;#EC NEEDED
    l_wait_time              TYPE i,
    l_wait_time_per_loop     TYPE i,
    l_wait_time_per_loop_sec TYPE f.

  l_wait_time = wait_time.

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.


  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_write = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

    cl_shm_service=&gt;initialize(
      EXPORTING area_name    = handle-&gt;area_name
                client       = l_client
      IMPORTING attributes   = l_attributes
    ).

    handle-&gt;properties = l_attributes-properties.

    handle-&gt;_attach_write70(
      EXPORTING
        area_name = handle-&gt;area_name
        mode      = attach_mode
      CHANGING
        wait_time = l_wait_time ).

    IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
       handle-&gt;_lock IS INITIAL.

      l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
      IF l_wait_time_per_loop &lt; 2000.
        l_wait_time_per_loop = 2000.
      ELSEIF l_wait_time_per_loop &gt; 300000.
        l_wait_time_per_loop = 300000.
      ENDIF.

      l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

      WHILE handle-&gt;_lock IS INITIAL.

        IF l_wait_time_per_loop &gt; l_wait_time.
          l_wait_time_per_loop = l_wait_time.
          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
        ENDIF.

        WAIT UP TO l_wait_time_per_loop_sec SECONDS.
        l_wait_time = l_wait_time - l_wait_time_per_loop.

        handle-&gt;_attach_write70(
          EXPORTING
            area_name = handle-&gt;area_name
            mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
          CHANGING
            wait_time = l_wait_time ).

      ENDWHILE.

    ENDIF.

*   &lt;

  ELSE.

    TRY.

*     &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        cl_shm_service=&gt;initialize(
          EXPORTING area_name    = handle-&gt;area_name
                    client       = l_client
          IMPORTING attributes   = l_attributes
        ).

        handle-&gt;properties = l_attributes-properties.

        handle-&gt;_attach_write70(
          EXPORTING
            area_name = handle-&gt;area_name
            mode      = attach_mode
          CHANGING
            wait_time = l_wait_time ).

        IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
           handle-&gt;_lock IS INITIAL.

          l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
          IF l_wait_time_per_loop &lt; 2000.
            l_wait_time_per_loop = 2000.
          ELSEIF l_wait_time_per_loop &gt; 300000.
            l_wait_time_per_loop = 300000.
          ENDIF.

          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

          WHILE handle-&gt;_lock IS INITIAL.

            IF l_wait_time_per_loop &gt; l_wait_time.
              l_wait_time_per_loop = l_wait_time.
              l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
            ENDIF.

            WAIT UP TO l_wait_time_per_loop_sec SECONDS.
            l_wait_time = l_wait_time - l_wait_time_per_loop.

            handle-&gt;_attach_write70(
              EXPORTING
                area_name = handle-&gt;area_name
                mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
              CHANGING
                wait_time = l_wait_time ).

          ENDWHILE.

        ENDIF.

*     &lt;

        _trace_service-&gt;trin_attach_for_write(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
        ).
      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_write(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="BUILD" VERSION="1" LANGU="F" DESCRIPT="Direct Call of Area Constructor" EXPOSURE="2" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="BUILD" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="BUILD" SCONAME="CX_SHMA_NOT_CONFIGURED" VERSION="1" LANGU="F" DESCRIPT="SHM Administration: Area Property Is Not Configured" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="BUILD" SCONAME="CX_SHMA_INCONSISTENT" VERSION="1" LANGU="F" DESCRIPT="SHM Administration: Inconsistent Attribute Combination" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="BUILD" SCONAME="CX_SHM_BUILD_FAILED" VERSION="1" LANGU="F" DESCRIPT="Constructor Run Failed" MTDTYPE="0" EDITORDER="3 "/>
   <source>method BUILD.

  DATA:
    l_cls_name TYPE shm_auto_build_class_name,
    l_cx TYPE REF TO cx_root.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-build = abap_false.

*   &gt;
    l_cls_name =
      cl_shm_service=&gt;get_auto_build_class_name( area_name ).

    CALL METHOD (l_cls_name)=&gt;if_shm_build_instance~build
      EXPORTING
        inst_name = inst_name.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        l_cls_name =
          cl_shm_service=&gt;get_auto_build_class_name( area_name ).

        CALL METHOD (l_cls_name)=&gt;if_shm_build_instance~build
          EXPORTING
            inst_name = inst_name.
*       &lt;
        _trace_service-&gt;trin_build(
          area_name         = area_name
          inst_name         = inst_name
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_build(
          area_name         = area_name
          inst_name         = inst_name
          cx                = l_cx
        ).
    ENDTRY.

  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="CLASS_CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CLASS_CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <source>method CLASS_CONSTRUCTOR.

* TRACE { DO NOT REMOVE THIS LINE !
  _trace_active = abap_false.
  TRY.
      _trace_service =
        cl_shm_service=&gt;trace_get_service( area_name ).
      IF NOT _trace_service IS INITIAL.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      ENDIF.
    CATCH cx_root. &quot;#EC NO_HANDLER
                   &quot;#EC CATCH_ALL
  ENDTRY.
* TRACE } DO NOT REMOVE THIS LINE !

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="DETACH_AREA" VERSION="1" LANGU="F" DESCRIPT="Release all locks on all instances" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="DETACH_AREA" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <source>method DETACH_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.


* &gt;
  rc = _detach_area71( area_name        = area_name
                       client           = l_client
                       client_supplied  = l_client_supplied
                       client_dependent = _client_dependent
                       life_context     = _life_context
       ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-detach_area = abap_true.
      _trace_service-&gt;trin_detach_area(
        area_name = area_name
        client    = l_client
        rc        = rc
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_AREA" VERSION="1" LANGU="F" DESCRIPT="Delete all instances" EXPOSURE="2" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_AREA" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="F" DESCRIPT="Writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_AREA" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_AREA" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method FREE_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.


* &gt;
  rc = _free_area71( area_name         = area_name
                     client            = l_client
                     client_supplied   = l_client_supplied
                     client_dependent  = _client_dependent
                     transactional     = _transactional
                     terminate_changer = terminate_changer
                     affect_server     = affect_server
                     life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-free_area = abap_true.
      _trace_service-&gt;trin_free_area(
      area_name         = area_name
      client            = l_client
      terminate_changer = terminate_changer
      affect_server     = affect_server
      rc                = rc
    ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="Deletion of an Instance" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_INSTANCE" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_INSTANCE" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="F" DESCRIPT="Writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_INSTANCE" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="FREE_INSTANCE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method FREE_INSTANCE.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.


* &gt;
  rc = _free_instance71( area_name         = area_name
                         inst_name         = inst_name
                         client            = l_client
                         client_supplied   = l_client_supplied
                         client_dependent  = _client_dependent
                         transactional     = _transactional
                         terminate_changer = terminate_changer
                         affect_server     = affect_server
                         life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-free_instance = abap_true.
      _trace_service-&gt;trin_free_instance(
        area_name         = area_name
        inst_name         = inst_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="GET_GENERATOR_VERSION" VERSION="1" LANGU="F" DESCRIPT="Query Generator Version" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="GET_GENERATOR_VERSION" SCONAME="GENERATOR_VERSION" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
   <source>method GET_GENERATOR_VERSION.
  generator_version = _version_.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="GET_INSTANCE_INFOS" VERSION="1" LANGU="F" DESCRIPT="Returns the names of all instances" EXPOSURE="2" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="GET_INSTANCE_INFOS" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance in an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="GET_INSTANCE_INFOS" SCONAME="INFOS" VERSION="1" LANGU="F" DESCRIPT="Overview of all Instances of an SHM Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_INST_INFOS"/>
   <source>method GET_INSTANCE_INFOS.

  DATA:
    l_client             TYPE shm_client,
    l_client_supplied    TYPE abap_bool VALUE abap_false,
    l_inst_name_supplied TYPE abap_bool VALUE abap_false.


  IF inst_name IS SUPPLIED.
    l_inst_name_supplied = abap_true.
  ENDIF.

* &gt;
  TRY.
      CALL METHOD (&apos;_GET_INSTANCE_INFOS804&apos;)
        EXPORTING
          area_name          = area_name
          client             = l_client
          client_supplied    = l_client_supplied
          client_dependent   = _client_dependent
          life_context       = _life_context
          inst_name          = inst_name
          inst_name_supplied = l_inst_name_supplied
        RECEIVING
          infos              = infos.
    CATCH cx_sy_dyn_call_illegal_method.
*     New kernel and/or new basis SP missing -&gt; use slow fallback
      infos = _get_instance_infos71(
                area_name        = area_name
                client           = l_client
                client_supplied  = l_client_supplied
                client_dependent = _client_dependent
                life_context     = _life_context
              ).
      IF abap_true = l_inst_name_supplied.
        DELETE infos WHERE name &lt;&gt; inst_name.
      ENDIF.
  ENDTRY.
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-get_instance_inf = abap_true.
      _trace_service-&gt;trin_get_instance_infos(
        area_name         = area_name
        client            = l_client
        infos             = infos
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="CL_SHM_AREA" CMPNAME="GET_ROOT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method GET_ROOT.

  DATA:
    l_cx        TYPE REF TO cx_root,
    l_area_name TYPE string,
    l_inst_name TYPE string,
    l_client    TYPE string.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-get_root = abap_false.

*   &gt;
    IF is_valid( ) = abap_false.
      l_area_name = me-&gt;area_name.
      l_inst_name = me-&gt;inst_name.
      l_client    = me-&gt;client.
      RAISE EXCEPTION TYPE cx_shm_already_detached
        EXPORTING
          area_name = l_area_name
          inst_name = l_inst_name
          client    = l_client.
    ENDIF.
    root = me-&gt;root.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        IF is_valid( ) = abap_false.
          l_area_name = me-&gt;area_name.
          l_inst_name = me-&gt;inst_name.
          l_client    = me-&gt;client.
          RAISE EXCEPTION TYPE cx_shm_already_detached
            EXPORTING
              area_name = l_area_name
              inst_name = l_inst_name
              client    = l_client.
        ENDIF.
        root = me-&gt;root.
*       &lt;

        _trace_service-&gt;trin_get_root(
          area_name = area_name
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_get_root(
          area_name = area_name
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_AREA" VERSION="1" LANGU="F" DESCRIPT="Active versions of all instances will be set to obsolete" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="F" DESCRIPT="Active writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method INVALIDATE_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.


* &gt;
  rc = _invalidate_area71( area_name         = area_name
                           client            = l_client
                           client_supplied   = l_client_supplied
                           client_dependent  = _client_dependent
                           transactional     = _transactional
                           terminate_changer = terminate_changer
                           affect_server     = affect_server
                           life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-invalidate_area = abap_true.
      _trace_service-&gt;trin_invalidate_area(
        area_name         = area_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_INSTANCE" VERSION="1" LANGU="F" DESCRIPT="Active version of one instance will be set to obsolete" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="INST_NAME" VERSION="1" LANGU="F" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="F" DESCRIPT="Active writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="RC" VERSION="1" LANGU="F" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="F" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method INVALIDATE_INSTANCE.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool value abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.


* &gt;
  rc = _invalidate_instance71(
    area_name         = area_name
    inst_name         = inst_name
    client            = l_client
    client_supplied   = l_client_supplied
    client_dependent  = _client_dependent
    transactional     = _transactional
    terminate_changer = terminate_changer
    affect_server     = affect_server
    life_context      = _life_context
  ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-invalidate_inst = abap_true.
      _trace_service-&gt;trin_invalidate_instance(
        area_name         = area_name
        inst_name         = inst_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="SET_ROOT" VERSION="1" LANGU="F" DESCRIPT="Sets Root Objects" EXPOSURE="2" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="SET_ROOT" SCONAME="ROOT" VERSION="1" LANGU="F" DESCRIPT="Root object" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_TASK_SHM_ROOT"/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="SET_ROOT" SCONAME="CX_SHM_INITIAL_REFERENCE" VERSION="1" LANGU="F" DESCRIPT="Initial Reference Passed" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_TASK_SHM_AREA" CMPNAME="SET_ROOT" SCONAME="CX_SHM_WRONG_HANDLE" VERSION="1" LANGU="F" DESCRIPT="Incorrect Handle" MTDTYPE="0" EDITORDER="2 "/>
   <source>method SET_ROOT.

  DATA:
    l_cx TYPE REF TO cx_root.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-set_root = abap_false.

*   &gt;
    _set_root( root ).
    me-&gt;root = root.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        _set_root( root ).
        me-&gt;root = root.
*       &lt;
        _trace_service-&gt;trin_set_root(
          area_name         = area_name
          inst_name         = inst_name
          root              = root
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_set_root(
          area_name         = area_name
          inst_name         = inst_name
          root              = root
          cx                = l_cx
        ).
    ENDTRY.

  ENDIF.

  endmethod.</source>
  </method>
 </CLAS>
 <DOCV OBJNAME="DTZTASK_WIZARD_003" ID="DT" OBJECT="ZTASK_WIZARD_003" TYP="E" DOKVERSION="0001">
  <TextLines TDFORMAT="*" TDLINE="Sélection des traitements à paralléliser"/>
  <TextLines TDFORMAT="*" TDLINE="Cette étape vous permet de sélection les modules fonctions à"/>
  <TextLines TDLINE="paralléliser."/>
 </DOCV>
 <DOCV OBJNAME="DTZTASK_WIZARD_002" ID="DT" OBJECT="ZTASK_WIZARD_002" TYP="E" DOKVERSION="0001">
  <TextLines TDFORMAT="*" TDLINE="Sélection du programme cadre"/>
  <TextLines TDFORMAT="*" TDLINE="Dans cette étape vous devez spécifier le programme (spécifique) dans"/>
  <TextLines TDLINE="lequel vous souhaitez implémenter le cadriciel."/>
  <TextLines TDFORMAT="*" TDLINE="Vous avez la possibilité d&apos;ajouter, dans l&apos;écran de sélection, les"/>
  <TextLines TDLINE="élèments pertinents pour la configuration. A savoir :"/>
  <TextLines TDFORMAT="*" TDLINE=",,,,- Groupe de Serveur"/>
  <TextLines TDFORMAT="*" TDLINE=",,,,- Nombre de Tâche"/>
  <TextLines TDFORMAT="*"/>
  <TextLines TDFORMAT="*" TDLINE="Le programme contenant le template du cadriciel est aussi spécifié mais"/>
  <TextLines TDLINE="non modifiable depuis cet assistant."/>
 </DOCV>
 <DOCV OBJNAME="DTZTASK_WIZARD_001" ID="DT" OBJECT="ZTASK_WIZARD_001" TYP="E" DOKVERSION="0001">
  <TextLines TDFORMAT="*" TDLINE="Bienvenue dans l&apos;assistant d&apos;implémentation de parallélisation."/>
  <TextLines TDFORMAT="*" TDLINE="Cet assistant va vous permettre de générer les élèments permettant de"/>
  <TextLines TDLINE="gérer la parallélisation des traitements sur des modules fonctions et/ou"/>
  <TextLines TDLINE="méthodes statiques."/>
 </DOCV>
 <DOCV OBJNAME="DTZTASK_WIZARD_004" ID="DT" OBJECT="ZTASK_WIZARD_004" TYP="E" DOKVERSION="0001">
  <TextLines TDFORMAT="*" TDLINE="Sélection des traitements à paralléliser"/>
  <TextLines TDFORMAT="*" TDLINE="Cette étape vous permet de sélection les méthodes statiques à"/>
  <TextLines TDLINE="paralléliser."/>
 </DOCV>
 <DOCV OBJNAME="DTZTASK_WIZARD_005" ID="DT" OBJECT="ZTASK_WIZARD_005" TYP="E" DOKVERSION="0002">
  <TextLines TDFORMAT="*" TDLINE="Sélection Groupe de Serveur"/>
  <TextLines TDFORMAT="*"/>
  <TextLines TDFORMAT="*" TDLINE="Cette étape vous permet de choisir le Groupe de Serveur sur lequel"/>
  <TextLines TDLINE="seront exécutés les traitements."/>
  <TextLines TDFORMAT="*" TDLINE="Vous avez la possibilité d&apos;utiliser le serveur par défaut ou d&apos;en"/>
  <TextLines TDLINE="choisir un précis."/>
 </DOCV>
 <DTEL ROLLNAME="ZE_FLUX_TYPE_RAQ" DDLANGUAGE="F" DOMNAME="ZDOM_FLUX_TYPE_RAQ" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="20" SCRLEN3="40" DDTEXT="Reste à Quai - Type de Flux" REPTEXT="Type de Flux" SCRTEXT_S="Ty. Flux" SCRTEXT_M="Type de Flux" SCRTEXT_L="Type de Flux" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" DECIMALS="000000" OUTPUTLEN="000001" VALEXI="X" REFKIND="D" MultiLanguageSupport="X">
  <tpara/>
  <DDLANGUAGE LANGU="E">
   <DD04V ROLLNAME="ZE_FLUX_TYPE_RAQ" DDLANGUAGE="E" DOMNAME="ZDOM_FLUX_TYPE_RAQ" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="20" SCRLEN3="40" DDTEXT="Reste à Quai - Type de Flux" REPTEXT="Type de Flux" SCRTEXT_S="Ty. Flux" SCRTEXT_M="Type de Flux" SCRTEXT_L="Type de Flux" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" DECIMALS="000000" OUTPUTLEN="000001" VALEXI="X" REFKIND="D"/>
  </DDLANGUAGE>
  <DDLANGUAGE LANGU="F">
   <DD04V ROLLNAME="ZE_FLUX_TYPE_RAQ" DDLANGUAGE="F" DOMNAME="ZDOM_FLUX_TYPE_RAQ" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="20" SCRLEN3="40" DDTEXT="Reste à Quai - Type de Flux" REPTEXT="Type de Flux" SCRTEXT_S="Ty. Flux" SCRTEXT_M="Type de Flux" SCRTEXT_L="Type de Flux" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" DECIMALS="000000" OUTPUTLEN="000001" VALEXI="X" REFKIND="D"/>
  </DDLANGUAGE>
 </DTEL>
 <DTEL ROLLNAME="ZTYPE_DEFINITION_GUID" DDLANGUAGE="F" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="32" SCRLEN1="10" SCRLEN2="20" SCRLEN3="40" DDTEXT="Définition de Type - ID Cluster" REPTEXT="Définition de Type - ID Cluster" SCRTEXT_S="ID Cluster" SCRTEXT_M="ID Cluster" SCRTEXT_L="Déf. Type - ID Cluster" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" DECIMALS="000000" OUTPUTLEN="000032" REFKIND="D" MultiLanguageSupport="X">
  <tpara/>
  <DDLANGUAGE LANGU="F">
   <DD04V ROLLNAME="ZTYPE_DEFINITION_GUID" DDLANGUAGE="F" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="32" SCRLEN1="10" SCRLEN2="20" SCRLEN3="40" DDTEXT="Définition de Type - ID Cluster" REPTEXT="Définition de Type - ID Cluster" SCRTEXT_S="ID Cluster" SCRTEXT_M="ID Cluster" SCRTEXT_L="Déf. Type - ID Cluster" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" DECIMALS="000000" OUTPUTLEN="000032" REFKIND="D"/>
  </DDLANGUAGE>
 </DTEL>
 <DTEL ROLLNAME="ZTRACE_XFELD" DDLANGUAGE="F" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="12" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DDTEXT="Trace - Activation de trace" REPTEXT="Trace active" SCRTEXT_S="Trace" SCRTEXT_M="Trace active" SCRTEXT_L="Trace active" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" DECIMALS="000000" OUTPUTLEN="000001" VALEXI="X" REFKIND="D" MultiLanguageSupport="X">
  <tpara/>
  <DDLANGUAGE LANGU="F">
   <DD04V ROLLNAME="ZTRACE_XFELD" DDLANGUAGE="F" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="12" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DDTEXT="Trace - Activation de trace" REPTEXT="Trace active" SCRTEXT_S="Trace" SCRTEXT_M="Trace active" SCRTEXT_L="Trace active" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" DECIMALS="000000" OUTPUTLEN="000001" VALEXI="X" REFKIND="D"/>
  </DDLANGUAGE>
 </DTEL>
 <DTEL ROLLNAME="ZTRACE_MEM_XFELD" DDLANGUAGE="F" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="20" SCRLEN3="20" DDTEXT="Trace - Activation Trace mémoire" REPTEXT="Trace mémoire active" SCRTEXT_S="Trace mém" SCRTEXT_M="Trace mémoire active" SCRTEXT_L="Trace mémoire active" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" DECIMALS="000000" OUTPUTLEN="000001" VALEXI="X" REFKIND="D" MultiLanguageSupport="X">
  <tpara/>
  <DDLANGUAGE LANGU="F">
   <DD04V ROLLNAME="ZTRACE_MEM_XFELD" DDLANGUAGE="F" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="20" SCRLEN3="20" DDTEXT="Trace - Activation Trace mémoire" REPTEXT="Trace mémoire active" SCRTEXT_S="Trace mém" SCRTEXT_M="Trace mémoire active" SCRTEXT_L="Trace mémoire active" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" DECIMALS="000000" OUTPUTLEN="000001" VALEXI="X" REFKIND="D"/>
  </DDLANGUAGE>
 </DTEL>
 <DTEL ROLLNAME="ZTASK_TRACE_ID" DDLANGUAGE="F" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="08" SCRLEN1="08" SCRLEN2="08" SCRLEN3="08" DDTEXT="Tâche - ID Trace" REPTEXT="ID Trace" SCRTEXT_S="ID Trace" SCRTEXT_M="ID Trace" SCRTEXT_L="ID Trace" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" DECIMALS="000000" OUTPUTLEN="000032" REFKIND="D" MultiLanguageSupport="X">
  <tpara/>
  <DDLANGUAGE LANGU="F">
   <DD04V ROLLNAME="ZTASK_TRACE_ID" DDLANGUAGE="F" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="08" SCRLEN1="08" SCRLEN2="08" SCRLEN3="08" DDTEXT="Tâche - ID Trace" REPTEXT="ID Trace" SCRTEXT_S="ID Trace" SCRTEXT_M="ID Trace" SCRTEXT_L="ID Trace" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" DECIMALS="000000" OUTPUTLEN="000032" REFKIND="D"/>
  </DDLANGUAGE>
 </DTEL>
 <DTEL ROLLNAME="ZTASK_MANAGER_ID" DDLANGUAGE="F" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="32" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DDTEXT="Tâche - ID Manager Tâche" REPTEXT="ID Manager Tâche" SCRTEXT_S="ID Manager" SCRTEXT_M="ID Manager" SCRTEXT_L="ID Manager Tâche" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" DECIMALS="000000" OUTPUTLEN="000032" REFKIND="D" MultiLanguageSupport="X">
  <tpara/>
  <DDLANGUAGE LANGU="F">
   <DD04V ROLLNAME="ZTASK_MANAGER_ID" DDLANGUAGE="F" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="32" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DDTEXT="Tâche - ID Manager Tâche" REPTEXT="ID Manager Tâche" SCRTEXT_S="ID Manager" SCRTEXT_M="ID Manager" SCRTEXT_L="ID Manager Tâche" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" DECIMALS="000000" OUTPUTLEN="000032" REFKIND="D"/>
  </DDLANGUAGE>
 </DTEL>
 <DTEL ROLLNAME="ZTASK_ID" DDLANGUAGE="F" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="32" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DDTEXT="Tâche - ID Tâche" REPTEXT="ID Tâche" SCRTEXT_S="ID Tâche" SCRTEXT_M="ID Tâche" SCRTEXT_L="ID Tâche" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" DECIMALS="000000" OUTPUTLEN="000032" REFKIND="D" MultiLanguageSupport="X">
  <tpara/>
  <DDLANGUAGE LANGU="F">
   <DD04V ROLLNAME="ZTASK_ID" DDLANGUAGE="F" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="32" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DDTEXT="Tâche - ID Tâche" REPTEXT="ID Tâche" SCRTEXT_S="ID Tâche" SCRTEXT_M="ID Tâche" SCRTEXT_L="ID Tâche" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" DECIMALS="000000" OUTPUTLEN="000032" REFKIND="D"/>
  </DDLANGUAGE>
 </DTEL>
 <DTEL ROLLNAME="ZTASK_DATA_COMPRESS_LINE" DDLANGUAGE="F" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="20" SCRLEN3="40" DDTEXT="Tâche - Données - Compression données (ligne)" REPTEXT="Compression données lignes / lignes" SCRTEXT_S="Comp." SCRTEXT_M="Comp. L/L" SCRTEXT_L="Compression données" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" DECIMALS="000000" OUTPUTLEN="000001" VALEXI="X" REFKIND="D" MultiLanguageSupport="X">
  <tpara/>
  <DDLANGUAGE LANGU="F">
   <DD04V ROLLNAME="ZTASK_DATA_COMPRESS_LINE" DDLANGUAGE="F" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="20" SCRLEN3="40" DDTEXT="Tâche - Données - Compression données (ligne)" REPTEXT="Compression données lignes / lignes" SCRTEXT_S="Comp." SCRTEXT_M="Comp. L/L" SCRTEXT_L="Compression données" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" DECIMALS="000000" OUTPUTLEN="000001" VALEXI="X" REFKIND="D"/>
  </DDLANGUAGE>
 </DTEL>
 <DTEL ROLLNAME="ZTASK_DATA_COMPRESS_GLOBAL" DDLANGUAGE="F" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="28" SCRLEN1="09" SCRLEN2="15" SCRLEN3="20" DDTEXT="Tâche - Données - Compression données globales" REPTEXT="Compression données globales" SCRTEXT_S="Comp. glb" SCRTEXT_M="Comp. globale" SCRTEXT_L="Compression globale" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" DECIMALS="000000" OUTPUTLEN="000001" VALEXI="X" REFKIND="D" MultiLanguageSupport="X">
  <tpara/>
  <DDLANGUAGE LANGU="F">
   <DD04V ROLLNAME="ZTASK_DATA_COMPRESS_GLOBAL" DDLANGUAGE="F" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="28" SCRLEN1="09" SCRLEN2="15" SCRLEN3="20" DDTEXT="Tâche - Données - Compression données globales" REPTEXT="Compression données globales" SCRTEXT_S="Comp. glb" SCRTEXT_M="Comp. globale" SCRTEXT_L="Compression globale" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" DECIMALS="000000" OUTPUTLEN="000001" VALEXI="X" REFKIND="D"/>
  </DDLANGUAGE>
 </DTEL>
 <DTEL ROLLNAME="ZSHM_MANAGEMENT" DDLANGUAGE="F" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="17" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DDTEXT="SHM - Gestion de la SHM" REPTEXT="Gestion de la SHM" SCRTEXT_S="Gest. SHM" SCRTEXT_M="Gest. SHM" SCRTEXT_L="Gestion de la SHM" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" DECIMALS="000000" OUTPUTLEN="000001" VALEXI="X" REFKIND="D" MultiLanguageSupport="X">
  <tpara/>
  <DDLANGUAGE LANGU="F">
   <DD04V ROLLNAME="ZSHM_MANAGEMENT" DDLANGUAGE="F" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="17" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DDTEXT="SHM - Gestion de la SHM" REPTEXT="Gestion de la SHM" SCRTEXT_S="Gest. SHM" SCRTEXT_M="Gest. SHM" SCRTEXT_L="Gestion de la SHM" AUTHCLASS="00" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" DECIMALS="000000" OUTPUTLEN="000001" VALEXI="X" REFKIND="D"/>
  </DDLANGUAGE>
 </DTEL>
 <FUGR AREA="ZTASK_FUNC_PARAM" SPRAS="F" AREAT="Gestion étendue de tables (générée)">
  <functionGroupDocumentation/>
  <mainprogram NAME="SAPLZTASK_FUNC_PARAM" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="F" APPL="S" RMAND="200" RLOAD="F" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
   <textPool/>
   <dynpros>
    <dynpro PROG="SAPLZTASK_FUNC_PARAM" DNUM="0001" FNUM="0001" BZMX="61 " BZBR="183 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="61 " NOCO="183 " VALP="0 " CUAN="G" SPRA="F" DTEXT="Gestion de vue : écran de synthèse ZTASK_FUNC_PARAM">
     <dynprofield FNAM="TCTRL_ZTASK_FUNC_PARAM" DIDX="003B" FLG1="F8" FLG2="FC" FLG3="00" FILL="T" FMB1="00" FMB2="00" LENG="B7" LINE="01" COLN="02" LTYP="E" LANF="65" LBLK="01" LREP="01" AGLT="00" ADEZ="00"/>
     <dynprofield FNAM="VIM_FRAME_FIELD" DIDX="003C" FLG1="80" FLG2="02" FLG3="88" FMB1="30" FMB2="40" LENG="3C" LINE="01" COLN="00" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________________________________________________"/>
     <dynprofield FNAM="*ZTASK_FUNC_PARAM-FUNCNAME" DIDX="001E" FLG1="20" FLG2="00" FLG3="00" FMB1="30" FMB2="80" LENG="28" LINE="01" COLN="01" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" ITYP="3" AGLT="00" ADEZ="00" STXT="Module fonction"/>
     <dynprofield FNAM="*ZTASK_FUNC_PARAM-CLASS_NAME" DIDX="001E" FLG1="20" FLG2="00" FLG3="00" FMB1="30" FMB2="80" LENG="28" LINE="01" COLN="02" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" ITYP="3" AGLT="00" ADEZ="00" STXT="Classe/Interface"/>
     <dynprofield FNAM="*ZTASK_FUNC_PARAM-METHOD_NAME" DIDX="003D" FLG1="20" FLG2="00" FLG3="00" FMB1="30" FMB2="80" LENG="28" LINE="01" COLN="03" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" ITYP="3" AGLT="00" ADEZ="00" STXT="Méthode"/>
     <dynprofield FNAM="*ZTASK_FUNC_PARAM-TRACE_ACTIVE" DIDX="000A" FLG1="30" FLG2="00" FLG3="00" FMB1="30" FMB2="80" LENG="28" LINE="01" COLN="04" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" ITYP="1" AGLT="00" ADEZ="00" STXT="Trace" RES1="X"/>
     <dynprofield FNAM="*ZTASK_FUNC_PARAM-TRACE_MEMORY" DIDX="000A" FLG1="30" FLG2="00" FLG3="00" FMB1="30" FMB2="80" LENG="28" LINE="01" COLN="05" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" ITYP="1" AGLT="00" ADEZ="00" STXT="Trace mém" RES1="X"/>
     <dynprofield FNAM="*ZTASK_FUNC_PARAM-SHM_MANAGEMENT" DIDX="000A" FLG1="30" FLG2="00" FLG3="00" FMB1="30" FMB2="80" LENG="28" LINE="01" COLN="06" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" ITYP="1" AGLT="00" ADEZ="00" STXT="Gest. SHM" RES1="X"/>
     <dynprofield FNAM="*ZTASK_FUNC_PARAM-DATA_COMPRESS_LINE_BY_LINE" DIDX="000A" FLG1="30" FLG2="00" FLG3="00" FMB1="30" FMB2="80" LENG="28" LINE="01" COLN="07" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" ITYP="1" AGLT="00" ADEZ="00" STXT="Comp." RES1="X"/>
     <dynprofield FNAM="*ZTASK_FUNC_PARAM-DATA_COMPRESS_GLOBAL" DIDX="0009" FLG1="30" FLG2="00" FLG3="00" FMB1="30" FMB2="80" LENG="28" LINE="01" COLN="08" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" ITYP="1" AGLT="00" ADEZ="00" STXT="Comp. glb" RES1="X"/>
     <dynprofield FNAM="VIM_MARKED" DIDX="0001" FLG1="80" FLG2="00" FLG3="88" FILL="C" FMB1="00" FMB2="20" LENG="01" LINE="01" COLN="00" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="102" AGLT="00" ADEZ="00"/>
     <dynprofield FNAM="ZTASK_FUNC_PARAM-FUNCNAME" DIDX="001E" FLG1="B0" FLG2="00" FLG3="80" FMB1="00" FMB2="00" LENG="1E" LINE="01" COLN="01" LTYP="T" LANF="65" LBLK="01" LREP="01" PAID="LIB" TYPE="CHAR" ITYP="C" AGLT="3C" ADEZ="00" STXT="______________________________" RES1="                                       00"/>
     <dynprofield FNAM="ZTASK_FUNC_PARAM-CLASS_NAME" DIDX="001E" FLG1="B0" FLG2="00" FLG3="80" FMB1="00" FMB2="00" LENG="1E" LINE="01" COLN="02" LTYP="T" LANF="65" LBLK="01" LREP="01" PAID="CLASS" TYPE="CHAR" ITYP="C" AGLT="3C" ADEZ="00" STXT="______________________________" RES1="                                       00"/>
     <dynprofield FNAM="ZTASK_FUNC_PARAM-METHOD_NAME" DIDX="003D" FLG1="B0" FLG2="00" FLG3="80" FMB1="00" FMB2="00" LENG="3D" LINE="01" COLN="03" LTYP="T" LANF="65" LBLK="01" LREP="01" PAID="MTDNAME" TYPE="CHAR" ITYP="C" AGLT="7A" ADEZ="00" STXT="_____________________________________________________________" RES1="                                       00"/>
     <dynprofield FNAM="ZTASK_FUNC_PARAM-TRACE_ACTIVE" DIDX="000A" FLG1="B0" FLG2="00" FLG3="81" FILL="C" FMB1="00" FMB2="08" LENG="01" LINE="01" COLN="04" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="103" ITYP="C" AGLT="02" ADEZ="00" RES1="X                                      00"/>
     <dynprofield FNAM="ZTASK_FUNC_PARAM-TRACE_MEMORY" DIDX="000A" FLG1="B0" FLG2="00" FLG3="81" FILL="C" FMB1="00" FMB2="08" LENG="01" LINE="01" COLN="05" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="104" ITYP="C" AGLT="02" ADEZ="00" RES1="X                                      00"/>
     <dynprofield FNAM="ZTASK_FUNC_PARAM-SHM_MANAGEMENT" DIDX="000A" FLG1="B0" FLG2="00" FLG3="81" FILL="C" FMB1="00" FMB2="08" LENG="01" LINE="01" COLN="06" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="105" ITYP="C" AGLT="02" ADEZ="00" RES1="X                                      00"/>
     <dynprofield FNAM="ZTASK_FUNC_PARAM-DATA_COMPRESS_LINE_BY_LINE" DIDX="000A" FLG1="B0" FLG2="00" FLG3="81" FILL="C" FMB1="00" FMB2="08" LENG="01" LINE="01" COLN="07" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="106" ITYP="C" AGLT="02" ADEZ="00" RES1="X                                      00"/>
     <dynprofield FNAM="ZTASK_FUNC_PARAM-DATA_COMPRESS_GLOBAL" DIDX="0009" FLG1="B0" FLG2="00" FLG3="81" FILL="C" FMB1="00" FMB2="08" LENG="01" LINE="01" COLN="08" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="107" ITYP="C" AGLT="02" ADEZ="00" RES1="X                                      00"/>
     <dynprofield FNAM="VIM_POSI_PUSH" DIDX="0000" FLG1="80" FLG2="00" FLG3="88" FILL="P" FMB1="30" FMB2="00" LENG="14" LINE="3D" COLN="14" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="108" AGLT="00" ADEZ="00" STXT="____________________" RES1="                                                                                                                                                                        POSI"/>
     <dynprofield FNAM="VIM_POSITION_INFO" DIDX="0000" FLG1="80" FLG2="02" FLG3="88" FMB1="33" FMB2="00" LENG="1E" LINE="3D" COLN="29" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="______________________________"/>
     <dynprofield FNAM="OK_CODE" DIDX="0000" FLG1="80" FLG2="10" FLG3="08" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
     <dynproflowsource>PROCESS BEFORE OUTPUT.
 MODULE LISTE_INITIALISIEREN.
 LOOP AT EXTRACT WITH CONTROL
  TCTRL_ZTASK_FUNC_PARAM CURSOR NEXTLINE.
   MODULE LISTE_SHOW_LISTE.
 ENDLOOP.
*
PROCESS AFTER INPUT.
 MODULE LISTE_EXIT_COMMAND AT EXIT-COMMAND.
 MODULE LISTE_BEFORE_LOOP.
 LOOP AT EXTRACT.
   MODULE LISTE_INIT_WORKAREA.
   CHAIN.
*    FIELD ZTASK_FUNC_PARAM-PARAM_GUID .
    FIELD ZTASK_FUNC_PARAM-FUNCNAME .
    FIELD ZTASK_FUNC_PARAM-CLASS_NAME .
    FIELD ZTASK_FUNC_PARAM-METHOD_NAME .
    FIELD ZTASK_FUNC_PARAM-TRACE_ACTIVE .
    FIELD ZTASK_FUNC_PARAM-TRACE_MEMORY .
    FIELD ZTASK_FUNC_PARAM-SHM_MANAGEMENT .
    FIELD ZTASK_FUNC_PARAM-DATA_COMPRESS_LINE_BY_LINE .
    FIELD ZTASK_FUNC_PARAM-DATA_COMPRESS_GLOBAL .
    MODULE SET_UPDATE_FLAG ON CHAIN-REQUEST.
   ENDCHAIN.
   FIELD VIM_MARKED MODULE LISTE_MARK_CHECKBOX.
   CHAIN.
*    FIELD ZTASK_FUNC_PARAM-PARAM_GUID .
    MODULE LISTE_UPDATE_LISTE.
   ENDCHAIN.
 ENDLOOP.
 MODULE LISTE_AFTER_LOOP.</dynproflowsource>
    </dynpro>
   </dynpros>
   <source>* regenerated at 06.03.2017 12:22:32
*******************************************************************
*   System-defined Include-files.                                 *
*******************************************************************
  INCLUDE LZTASK_FUNC_PARAMTOP.              &quot; Global Data
  INCLUDE LZTASK_FUNC_PARAMUXX.              &quot; Function Modules

*******************************************************************
*   User-defined Include-files (if necessary).                    *
*******************************************************************
* INCLUDE LZTASK_FUNC_PARAMF...              &quot; Subroutines
* INCLUDE LZTASK_FUNC_PARAMO...              &quot; PBO-Modules
* INCLUDE LZTASK_FUNC_PARAMI...              &quot; PAI-Modules
* INCLUDE LZTASK_FUNC_PARAME...              &quot; Events
* INCLUDE LZTASK_FUNC_PARAMP...              &quot; Local class implement.
* INCLUDE LZTASK_FUNC_PARAMT99.              &quot; ABAP Unit tests
  INCLUDE LZTASK_FUNC_PARAMF00                    . &quot; subprograms
  INCLUDE LZTASK_FUNC_PARAMI00                    . &quot; PAI modules
  INCLUDE LSVIMFXX                                . &quot; subprograms
  INCLUDE LSVIMOXX                                . &quot; PBO modules
  INCLUDE LSVIMIXX                                . &quot; PAI modules

INCLUDE lztask_func_paramf01.</source>
  </mainprogram>
  <includeprograms>
   <include NAME="LZTASK_FUNC_PARAMF00" SQLX="X" EDTX="X" SUBC="I" LEVL="740" RLOAD="F">
    <include_source>*---------------------------------------------------------------------*
*    view related FORM routines
*   generation date: 06.03.2017 at 12:22:32
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*

* base table related FORM-routines.............
INCLUDE LSVIMFTX .</include_source>
   </include>
   <include NAME="LZTASK_FUNC_PARAMF01" SQLX="X" VARCL="X" SUBC="I" APPL="S" RMAND="200" RLOAD="F" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LZTASK_FUNC_PARAMF01.
*----------------------------------------------------------------------*

FORM event_05.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Création GUID
      &quot; -----------------------------------------------------------

      &quot; Création du GUID
      ztask_func_param-param_guid = cl_system_uuid=&gt;create_uuid_x16_static( ).

    CATCH cx_uuid_error.
      &quot; Erreur génération GUID

  ENDTRY.

ENDFORM.</include_source>
   </include>
   <include NAME="LZTASK_FUNC_PARAMI00" SQLX="X" EDTX="X" SUBC="I" LEVL="740" RLOAD="F">
    <include_source>*---------------------------------------------------------------------*
*    view related PAI modules
*   generation date: 06.03.2017 at 12:22:32
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*

INCLUDE LSVIMITX . &quot;base table related PAI modules</include_source>
   </include>
   <include NAME="LZTASK_FUNC_PARAMTOP" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RMAND="200" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
    <include_source>* regenerated at 06.03.2017 12:22:32
FUNCTION-POOL ZTASK_FUNC_PARAM           MESSAGE-ID SV.

* INCLUDE LZTASK_FUNC_PARAMD...              &quot; Local class definition
  INCLUDE LSVIMDAT                                . &quot;general data decl.
  INCLUDE LZTASK_FUNC_PARAMT00                    . &quot;view rel. data dcl.</include_source>
   </include>
  </includeprograms>
  <functionmodules>
   <functionmodule NAME="TABLEFRAME_ZTASK_FUNC_PARAM" STEXT="Gestion étendue de tables, niveau supérieur">
    <importing PARAMETER="VIEW_ACTION" DEFAULT="&apos;S&apos;"/>
    <importing PARAMETER="VIEW_NAME" DBFIELD="DD02V-TABNAME"/>
    <importing PARAMETER="CORR_NUMBER" DBFIELD="E070-TRKORR" DEFAULT="&apos; &apos;"/>
    <tables PARAMETER="DBA_SELLIST" DBSTRUCT="VIMSELLIST"/>
    <tables PARAMETER="DPL_SELLIST" DBSTRUCT="VIMSELLIST"/>
    <tables PARAMETER="EXCL_CUA_FUNCT" DBSTRUCT="VIMEXCLFUN"/>
    <tables PARAMETER="X_HEADER" DBSTRUCT="VIMDESC"/>
    <tables PARAMETER="X_NAMTAB" DBSTRUCT="VIMNAMTAB"/>
    <exceptions EXCEPTION="MISSING_CORR_NUMBER"/>
    <documentation PARAMETER="VIEW_ACTION" KIND="P" STEXT="Aktion mit Tabelle: anz./änd./transp. (S/U/T)" INDEX=" 001"/>
    <documentation PARAMETER="VIEW_NAME" KIND="P" STEXT="Name der Tabelle" INDEX=" 002"/>
    <documentation PARAMETER="CORR_NUMBER" KIND="P" STEXT="Korrekturnummer für durchgeführte Änderungen" INDEX=" 003"/>
    <documentation PARAMETER="DBA_SELLIST" KIND="P" STEXT="Selektionsbedingungen für den DB-Zugriff" INDEX=" 004"/>
    <documentation PARAMETER="DPL_SELLIST" KIND="P" STEXT="Selektionsbedingungen für die Anzeige" INDEX=" 005"/>
    <documentation PARAMETER="EXCL_CUA_FUNCT" KIND="P" STEXT="Tabelle mit dynam. zu deaktivierenden CUA-Funkt." INDEX=" 006"/>
    <documentation PARAMETER="X_HEADER" KIND="P" STEXT="Kontrollblocktabelle für die Tabelle" INDEX=" 007"/>
    <documentation PARAMETER="X_NAMTAB" KIND="P" STEXT="Kontrollblocktabelle für die Tabellen-Felder" INDEX=" 008"/>
    <documentation PARAMETER="MISSING_CORR_NUMBER" KIND="X" STEXT="Korrekturnummer fehlt" INDEX=" 009"/>
    <fm_source>*---------------------------------------------------------------------*
*    program for:   TABLEFRAME_ZTASK_FUNC_PARAM
*   generation date: 06.03.2017 at 12:22:31
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*

  PERFORM TABLEFRAME TABLES X_HEADER X_NAMTAB DBA_SELLIST DPL_SELLIST
                            EXCL_CUA_FUNCT
                     USING  CORR_NUMBER VIEW_ACTION VIEW_NAME.</fm_source>
    <functionModuleDocumentation/>
   </functionmodule>
   <functionmodule NAME="TABLEPROC_ZTASK_FUNC_PARAM" GLOBAL="X" STEXT="Gestion étendue de tables, niveau inférieur">
    <importing PARAMETER="FCODE" DEFAULT="&apos;RDED&apos;"/>
    <importing PARAMETER="VIEW_ACTION" DEFAULT="&apos;S&apos;"/>
    <importing PARAMETER="VIEW_NAME" DBFIELD="DD02V-TABNAME"/>
    <importing PARAMETER="CORR_NUMBER" DBFIELD="E070-TRKORR" DEFAULT="&apos; &apos;"/>
    <exporting PARAMETER="LAST_ACT_ENTRY"/>
    <exporting PARAMETER="UCOMM"/>
    <exporting PARAMETER="UPDATE_REQUIRED"/>
    <tables PARAMETER="CORR_KEYTAB" DBSTRUCT="E071K"/>
    <tables PARAMETER="DBA_SELLIST" DBSTRUCT="VIMSELLIST"/>
    <tables PARAMETER="DPL_SELLIST" DBSTRUCT="VIMSELLIST"/>
    <tables PARAMETER="EXCL_CUA_FUNCT" DBSTRUCT="VIMEXCLFUN"/>
    <tables PARAMETER="EXTRACT"/>
    <tables PARAMETER="TOTAL"/>
    <tables PARAMETER="X_HEADER" DBSTRUCT="VIMDESC"/>
    <tables PARAMETER="X_NAMTAB" DBSTRUCT="VIMNAMTAB"/>
    <exceptions EXCEPTION="MISSING_CORR_NUMBER"/>
    <exceptions EXCEPTION="SAVING_CORRECTION_FAILED"/>
    <documentation PARAMETER="FCODE" KIND="P" STEXT="gewünschte Funktion des Bausteins" INDEX=" 001"/>
    <documentation PARAMETER="VIEW_ACTION" KIND="P" STEXT="Aktion mit Tabelle: anz./änd./transp. (S/U/T)" INDEX=" 002"/>
    <documentation PARAMETER="VIEW_NAME" KIND="P" STEXT="Name der Tabelle" INDEX=" 003"/>
    <documentation PARAMETER="CORR_NUMBER" KIND="P" STEXT="Korrekturnummer für durchgeführte Änderungen" INDEX=" 004"/>
    <documentation PARAMETER="LAST_ACT_ENTRY" KIND="P" STEXT="Index der Cursorposition in der Anzeigetabelle" INDEX=" 005"/>
    <documentation PARAMETER="UCOMM" KIND="P" STEXT="letztes User-command innerhalb der Viewpflege" INDEX=" 006"/>
    <documentation PARAMETER="UPDATE_REQUIRED" KIND="P" STEXT="Flag: Einträge verändert, Sichern erforderlich" INDEX=" 007"/>
    <documentation PARAMETER="CORR_KEYTAB" KIND="P" STEXT="Tabelle mit den Keys der zu transport. Einträge" INDEX=" 008"/>
    <documentation PARAMETER="DBA_SELLIST" KIND="P" STEXT="Selektionsbedingungen für den DB-Zugriff" INDEX=" 009"/>
    <documentation PARAMETER="DPL_SELLIST" KIND="P" STEXT="Selektionsbedingungen für die Anzeige" INDEX=" 010"/>
    <documentation PARAMETER="EXCL_CUA_FUNCT" KIND="P" STEXT="Tab. der nicht zu aktivierenden CUA-Funktionen" INDEX=" 011"/>
    <documentation PARAMETER="EXTRACT" KIND="P" STEXT="Tab. der gerade sichtbaren Daten (Anzeigetabelle" INDEX=" 012"/>
    <documentation PARAMETER="TOTAL" KIND="P" STEXT="Tabelle, mit allen von der DB gelesenen Daten" INDEX=" 013"/>
    <documentation PARAMETER="X_HEADER" KIND="P" STEXT="Kontrollblocktabelle für die Tabelle" INDEX=" 014"/>
    <documentation PARAMETER="X_NAMTAB" KIND="P" STEXT="Kontrollblocktabelle für die Tabellen-Felder" INDEX=" 015"/>
    <documentation PARAMETER="MISSING_CORR_NUMBER" KIND="X" STEXT="Korrekturnummer fehlt" INDEX=" 016"/>
    <documentation PARAMETER="SAVING_CORRECTION_FAILED" KIND="X" STEXT="Fehler beim Sichern der Korrektureinträge" INDEX=" 017"/>
    <fm_source>*---------------------------------------------------------------------*
*    program for:   TABLEPROC_ZTASK_FUNC_PARAM
*   generation date: 06.03.2017 at 12:22:31
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*

  PERFORM TABLEPROC.</fm_source>
    <functionModuleDocumentation/>
   </functionmodule>
  </functionmodules>
 </FUGR>
 <FUGR AREA="ZTEC_TASK_PARALLEL" SPRAS="F" AREAT="GF Traitement Tâche Paralléle">
  <functionGroupDocumentation/>
  <mainprogram NAME="SAPLZTEC_TASK_PARALLEL" VARCL="X" DBAPL="S" DBNA="D$" SUBC="F" APPL="S" RMAND="100" RLOAD="F" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
   <textPool/>
   <source>*******************************************************************
*   System-defined Include-files.                                 *
*******************************************************************
  INCLUDE LZTEC_TASK_PARALLELTOP.            &quot; Global Data
  INCLUDE LZTEC_TASK_PARALLELUXX.            &quot; Function Modules

*******************************************************************
*   User-defined Include-files (if necessary).                    *
*******************************************************************
* INCLUDE LZTEC_TASK_PARALLELF...            &quot; Subroutines
* INCLUDE LZTEC_TASK_PARALLELO...            &quot; PBO-Modules
* INCLUDE LZTEC_TASK_PARALLELI...            &quot; PAI-Modules
* INCLUDE LZTEC_TASK_PARALLELE...            &quot; Events
* INCLUDE LZTEC_TASK_PARALLELP...            &quot; Local class implement.
* INCLUDE LZTEC_TASK_PARALLELT99.            &quot; ABAP Unit tests

INCLUDE lztec_task_parallelf01.

INCLUDE lztec_task_parallelf02.

INCLUDE lztec_task_parallelf03.</source>
  </mainprogram>
  <includeprograms>
   <include NAME="LZTEC_TASK_PARALLELF01" VARCL="X" SUBC="I" APPL="S" RMAND="100" RLOAD="F" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LZTEC_TASK_PARALLELF01.
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Include         : LZTEC_TASK_PARALLELF01                            *
*&amp; Module Fonction : Z_TASK_CALL_PROCESS                               *
*&amp; Groupe Fonction : ZTEC_TASK_PARALELL                                *
*&amp; Description     : Include pour routine sur Appel MF                 *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *


*&amp;---------------------------------------------------------------------*
*&amp;      Form  FUNCTION_CALL_PROCESS
*&amp;---------------------------------------------------------------------*
*       Appel d&apos;un Module Fonction
*----------------------------------------------------------------------*
*      --&gt; IV_FUNCTION_NAME                 Module Fonction à exécuter
*      --&gt; IT_FUNCTION_PARAMETERS           Table des paramètres d&apos;appels
*      --&gt; IV_FUNCTION_DATA_COMPRESSED      Données d&apos;appe compressées
*      --&gt; IS_TASK_DATA_COMPRESS_PARAM      Type de Compression
*      &lt;-- ET_TASK_RESULT                   Données de retour
*      &lt;-- EV_TASK_RESULT_DATA_COMPRESSED   Données de retour compressées
*----------------------------------------------------------------------*
FORM function_call_process USING iv_function_name               TYPE rs38l_fnam
                                 it_function_parameters         TYPE ztec_t_function_parameters
                                 iv_function_data_compressed    TYPE xstring
                                 is_task_data_compress_param    TYPE ztec_s_task_compress_param
                        CHANGING et_task_result                 TYPE ztec_t_function_parameters
                                 ev_task_result_data_compressed TYPE xstring.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_table_data TYPE tt_table_data,
    lt_exceptions TYPE abap_func_excpbind_tab,
    lt_parameters TYPE abap_func_parmbind_tab.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_subrc TYPE sy-subrc.                                 &quot;#EC NEEDED

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR   : ev_task_result_data_compressed.
  REFRESH : et_task_result.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Initialisation tables paramètres d&apos;appel Dynamique
      &quot; -----------------------------------------------------------

      &quot; Initialisation des paramètres dynamique
      PERFORM func_dynamic_parameters_set USING iv_function_name
                                                it_function_parameters
                                                iv_function_data_compressed
                                       CHANGING lt_table_data   &quot;Sert à stocker les références des données
                                                lt_parameters
                                                lt_exceptions.

    CATCH cx_root.                                       &quot;#EC CATCH_ALL
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Arrêt du traitement
      MESSAGE ID zif_task_constant=&gt;mc_message_class_id
            TYPE &apos;E&apos;                                        &quot;#EC NOTEXT
          NUMBER 501                                        &quot;#EC NOTEXT
            WITH iv_function_name
         RAISING dynamic_convert_error.

  ENDTRY.

  IF lt_exceptions[] IS INITIAL.
    &quot; -----------------------------------------------------------
    &quot; Gestion des Exceptions // Afin d&apos;éviter toute erreur
    &quot; -----------------------------------------------------------
    PERFORM func_exception_table_set USING iv_function_name
                                  CHANGING lt_exceptions.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Appel du MF
      &quot; -----------------------------------------------------------

      &quot; Appel du MF avec paramètres dynamique
      CALL FUNCTION iv_function_name
        PARAMETER-TABLE lt_parameters
        EXCEPTION-TABLE lt_exceptions.
      lv_subrc = sy-subrc.

    CATCH cx_root INTO DATA(lo_cx_exception).
      &quot; Une erreur est survenue lors de l&apos;appel
      &quot;&quot;  --&gt; Arrêt du traitement
      MESSAGE ID zif_task_constant=&gt;mc_message_class_id
            TYPE &apos;E&apos;                                        &quot;#EC NOTEXT
          NUMBER 502                                        &quot;#EC NOTEXT
            WITH iv_function_name
                 lo_cx_exception-&gt;get_text( )
         RAISING dynamic_call_error.

  ENDTRY.

  &quot; -----------------------------------------------------------
  &quot; Initialisation table de retour
  &quot; -----------------------------------------------------------

  &quot; Conserve uniquement les paramètres d&apos;Export / Changing / Table (vue du MF)
  DELETE lt_parameters WHERE kind EQ abap_func_exporting.
  IF NOT lt_parameters[] IS INITIAL.
    &quot; Initialisation table de retour
    PERFORM func_result_set USING lv_subrc
                                  lt_parameters
                                  lt_exceptions
                                  it_function_parameters
                                  is_task_data_compress_param
                         CHANGING et_task_result
                                  ev_task_result_data_compressed.

  ENDIF.

ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  FUNC_DYNAMIC_PARAMETERS_SET
*&amp;---------------------------------------------------------------------*
*       Initialisation des paramètres dynamique d&apos;appel
*----------------------------------------------------------------------*
*      --&gt; IV_FUNCTION_NAME             Nom du MF à appeler
*      --&gt; IT_FUNCTION_PARAMETERS       Table paramètre statique
*      --&gt; IV_FUNCTION_DATA_COMPRESSED  Données comprimées
*      &lt;-- ET_TABLE_DATA                Table stockage paramètre
*      &lt;-- ET_PARAMETERS                Table paramètre dynamique
*      &lt;-- ET_EXCEPTIONS                Table exception dynamique
*----------------------------------------------------------------------*
FORM func_dynamic_parameters_set USING iv_function_name            TYPE rs38l_fnam &quot;#EC NEEDED
                                       it_function_parameters      TYPE ztec_t_function_parameters
                                       iv_function_data_compressed TYPE xstring
                              CHANGING et_table_data               TYPE tt_table_data
                                       et_parameters               TYPE abap_func_parmbind_tab
                                       et_exceptions               TYPE abap_func_excpbind_tab.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_exceptions TYPE abap_func_excpbind,
    ls_parameters TYPE abap_func_parmbind,
    ls_table_data TYPE ts_table_data.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_abap_zip        TYPE REF TO cl_abap_zip,
    lo_type_descr      TYPE REF TO cl_abap_typedescr,
    lo_cx_exception    TYPE REF TO cx_root,
    lo_type_definition TYPE REF TO zcl_type_definition.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
        lv_data_decompress TYPE xstring.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_value_data&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : et_parameters, et_exceptions, et_table_data.

  &quot; -----------------------------------------------------------
  &quot; Pré-Traitement
  &quot; -----------------------------------------------------------

  IF NOT iv_function_data_compressed IS INITIAL.
    &quot; Données compressées
    &quot;&quot;  --&gt; Chargement dossier compressées
    CREATE OBJECT lo_abap_zip.
    lo_abap_zip-&gt;support_unicode_names = abap_true.
    lo_abap_zip-&gt;load(
      EXPORTING
        zip             = iv_function_data_compressed
      EXCEPTIONS
        zip_parse_error = 1
        OTHERS          = 2
    ).
    IF sy-subrc NE 0.
      &quot; Une erreur est survenue // Les données sont illisibles
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Conversion des paramètres &quot;statiques&quot; en &quot;dynamique&quot;
  &quot; -----------------------------------------------------------

  &quot; Parcours l&apos;ensemble des paramètres &quot;statique&quot;
  LOOP AT it_function_parameters ASSIGNING FIELD-SYMBOL(&lt;lfs_s_function_parameters&gt;).

    CLEAR    : ls_parameters, ls_exceptions, ls_table_data, lv_data_decompress.
    UNASSIGN : &lt;lfs_value_data&gt;.

    &quot; Contrôle cohérence du Type
    cl_abap_typedescr=&gt;describe_by_name(
      EXPORTING
        p_name         = &lt;lfs_s_function_parameters&gt;-value_type
      EXCEPTIONS
        type_not_found = 1
        OTHERS         = 2
    ).
    IF sy-subrc NE 0.
      &quot; Type non défini dans le RTTS du système
      &quot;&quot;  --&gt; On va le charger depuis la mémoire partagée
      IF NOT lo_type_definition IS BOUND.
        &quot; Récupération instance courante
        lo_type_definition = zcl_type_definition=&gt;get_instance( ).

      ENDIF.

      TRY.
          &quot; Récupération de la définition du Type
          lo_type_descr = lo_type_definition-&gt;definition_type_get( &lt;lfs_s_function_parameters&gt;-value_type ).

        CATCH zcx_type_definition INTO lo_cx_exception.
          &quot; Erreur lors de la récupération de la définition du Type
          &quot;&quot;  --&gt; Lève une Exception
          WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
          RAISE EXCEPTION TYPE zcx_task_call
            EXPORTING
              previous = lo_cx_exception.

      ENDTRY.

      &quot;&quot;  --&gt; Création de la zone Typée
      CREATE DATA ls_table_data-value TYPE (lo_type_descr-&gt;absolute_name).

    ELSE.
      &quot;&quot;  --&gt; Création de la zone typée
      IF &lt;lfs_s_function_parameters&gt;-parameter_kind EQ zif_task_constant=&gt;mc_parameter_kind_tables.
        &quot; Paramètre Table
        CREATE DATA ls_table_data-value TYPE STANDARD TABLE OF (&lt;lfs_s_function_parameters&gt;-value_type).

      ELSE.
        &quot; Paramètre &lt;&gt; Table
        CREATE DATA ls_table_data-value TYPE (&lt;lfs_s_function_parameters&gt;-value_type).

      ENDIF.

    ENDIF.

    &quot; Initialisation pointeur sur la donnée
    ASSIGN ls_table_data-value-&gt;* TO &lt;lfs_value_data&gt;.

    &quot; Suivant le Type de Paramètre (Signature)
    CASE &lt;lfs_s_function_parameters&gt;-parameter_kind.

      WHEN zif_task_constant=&gt;mc_parameter_kind_importing.
        &quot; Cas d&apos;un paramètre d&apos;Export (vue MF)
        &quot;&quot;  --&gt; Les paramètres d&apos;Export non pas à être rempli !

      WHEN zif_task_constant=&gt;mc_parameter_kind_exception.
        &quot; Cas d&apos;une Exception
        &quot;&quot;  --&gt; Ajout de l&apos;Exception
        ls_exceptions-name  = &lt;lfs_s_function_parameters&gt;-parameter_name.
        ls_exceptions-value = lines( et_exceptions ) + 1.
        INSERT ls_exceptions INTO TABLE et_exceptions.

        &quot;&quot;  --&gt; Passe à l&apos;itération suivante
        CONTINUE.

      WHEN OTHERS.
        &quot; Autre type de paramètre
        IF &lt;lfs_s_function_parameters&gt;-value_is_compressed_global EQ abap_true
        OR NOT &lt;lfs_s_function_parameters&gt;-value_data_xml         IS INITIAL.
          &quot; Données &quot;complexe&quot; stockées sous forme XML
          &quot;&quot;  --&gt; Suivant méthode de compression
          CASE abap_true.

            WHEN &lt;lfs_s_function_parameters&gt;-value_is_compressed_local.
              &quot; Compression ligne à ligne
              &quot;&quot;  --&gt; Création instance compression
              CREATE OBJECT lo_abap_zip.
              lo_abap_zip-&gt;support_unicode_names = abap_true.

              &quot;&quot;  --&gt; Lecture dossier compressé
              lo_abap_zip-&gt;load(
                EXPORTING
                  zip             = &lt;lfs_s_function_parameters&gt;-value_data_xml
                EXCEPTIONS
                  zip_parse_error = 1
                  OTHERS          = 2
              ).
              IF sy-subrc EQ 0.
                &quot; Aucune erreur
                &quot;&quot;  --&gt; Récupération données décompressées
                lo_abap_zip-&gt;get(
                  EXPORTING
                    index                   = 1
                  IMPORTING
                    content                 = lv_data_decompress
                  EXCEPTIONS
                    zip_index_error         = 1
                    zip_decompression_error = 2
                    OTHERS                  = 3
                ).

              ENDIF.
              IF sy-subrc NE 0.
                &quot; Une erreur est survenue
                &quot;&quot;  --&gt; Réinitialisation données
                CLEAR : lv_data_decompress.

              ENDIF.

            WHEN &lt;lfs_s_function_parameters&gt;-value_is_compressed_global.
              &quot; Compression globale
              &quot;&quot;  --&gt; Décompression des données
              lo_abap_zip-&gt;get(
                EXPORTING
                  name                    = CONV string( &lt;lfs_s_function_parameters&gt;-parameter_name )
                IMPORTING
                  content                 = lv_data_decompress
                EXCEPTIONS
                  zip_index_error         = 1
                  zip_decompression_error = 2
                  OTHERS                  = 3
              ).
              IF sy-subrc NE 0.
                &quot; Une erreur est survenue
                &quot;&quot;  --&gt; Réinitialisation données
                CLEAR : lv_data_decompress.

              ENDIF.

            WHEN OTHERS.
              &quot; Autres
              &quot;&quot;  --&gt; Pas de décompression // Rien à faire
              lv_data_decompress = &lt;lfs_s_function_parameters&gt;-value_data_xml.

          ENDCASE.

          IF NOT lv_data_decompress IS INITIAL.
            &quot;&quot; --&gt; Restructuration des données
            CALL TRANSFORMATION id
                     SOURCE XML lv_data_decompress
                         RESULT data = &lt;lfs_value_data&gt;.

          ENDIF.

        ELSEIF NOT &lt;lfs_s_function_parameters&gt;-value_data IS INITIAL.
          &quot; Type Elémentaire
          &quot;&quot;  --&gt; Initialisation des données
          &lt;lfs_value_data&gt; = &lt;lfs_s_function_parameters&gt;-value_data.

        ELSE.                                               &quot;#EC NEEDED
          &quot; Autre cas
          &quot;&quot;  --&gt; ToDo : Ajouter ici les autres cas

        ENDIF.

    ENDCASE.

    &quot;&quot;  --&gt; Création d&apos;une entrée permettant de stocker les paramètres d&apos;appel Dynamique
    ls_table_data-name = &lt;lfs_s_function_parameters&gt;-parameter_name.                &quot;Nom du paramètre
    INSERT ls_table_data INTO TABLE et_table_data.                                  &quot;Ajout dans table de paramètre

    &quot;&quot;  --&gt; Initialisation table paramètre d&apos;appel dynamique
    ls_parameters-name  = &lt;lfs_s_function_parameters&gt;-parameter_name.     &quot;Nom du paramètre
    ls_parameters-kind  = &lt;lfs_s_function_parameters&gt;-parameter_kind.     &quot;Type (ABAP) du paramètre
    ls_parameters-value = REF #( &lt;lfs_value_data&gt; ).                      &quot;Référence sur le contenu
    INSERT ls_parameters INTO TABLE et_parameters.                        &quot;Ajout du paramètre dynamique

  ENDLOOP.

  &quot; -----------------------------------------------------------
  &quot; Fin de traitement
  &quot; -----------------------------------------------------------

  IF lo_type_definition IS BOUND.
    TRY.
        &quot; Libération Token Mémoire Partagée
        lo_type_definition-&gt;definition_type_finish( ).

      CATCH zcx_type_definition.                        &quot;#EC NO_HANDLER
        &quot; Erreur libération mémoire

    ENDTRY.

  ENDIF.

ENDFORM.                    &quot; DYNAMIC_PARAMETERS_SET

*&amp;---------------------------------------------------------------------*
*&amp;      Form  FUNC_EXCEPTION_TABLE_SET
*&amp;---------------------------------------------------------------------*
*       Initialisation table d&apos;Exception
*----------------------------------------------------------------------*
*      --&gt; IV_FUNCTION_NAME     Nom du MF
*      &lt;-&gt; CT_EXCEPTIONS        Table des Exceptions
*----------------------------------------------------------------------*
FORM func_exception_table_set USING iv_function_name TYPE clike
                           CHANGING ct_exceptions    TYPE abap_func_excpbind_tab.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_fupararef_exception TYPE tt_fupararef_exception.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_exception           TYPE abap_func_excpbind,
    ls_fupararef_exception TYPE ts_fupararef_exception.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération des Exceptions du MF
  &quot; -----------------------------------------------------------

  &quot; Récupération position première occurence associée au MF
  READ TABLE gs_persistent_data-t_fupararef_exception
    WITH KEY funcname = iv_function_name TRANSPORTING NO FIELDS
                                               BINARY SEARCH.
  IF sy-subrc NE 0.
    &quot; Aucune Exception
    SELECT funcname parameter pposition FROM fupararef
                                  INTO TABLE lt_fupararef_exception ##TOO_MANY_ITAB_FIELDS
                                       WHERE funcname  EQ iv_function_name
                                         AND paramtype EQ &apos;X&apos;.
    IF sy-subrc NE 0.
      &quot; Création d&apos;une entrée afin de ne pas rechercher à nouveau les données
      ls_fupararef_exception-funcname  = iv_function_name.
      ls_fupararef_exception-not_found = abap_true.
      INSERT ls_fupararef_exception INTO TABLE gs_persistent_data-t_fupararef_exception.

    ELSE.
      &quot; Ajout des entrées
      INSERT LINES OF lt_fupararef_exception INTO TABLE gs_persistent_data-t_fupararef_exception.
      FREE : lt_fupararef_exception.

    ENDIF.

    &quot; Récupération position première occurence
    READ TABLE gs_persistent_data-t_fupararef_exception
      WITH KEY funcname = iv_function_name TRANSPORTING NO FIELDS
                                                 BINARY SEARCH.

  ENDIF.

  IF sy-subrc NE 0.
    &quot; Aucune Exception trouvée
    &quot;&quot;  --&gt; Supprime toutes les exceptions présentes
    FREE : ct_exceptions.

    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Récupération des Exceptions du MF
  &quot; -----------------------------------------------------------

  &quot; Parcours l&apos;ensemble des Exceptions
  LOOP AT gs_persistent_data-t_fupararef_exception ASSIGNING FIELD-SYMBOL(&lt;lfs_s_fupararef_exception&gt;)
                                                        FROM sy-tabix.

    CLEAR : ls_exception.

    IF &lt;lfs_s_fupararef_exception&gt;-not_found EQ abap_true.
      &quot; Aucune Exception
      &quot;&quot;  --&gt; Supprime toutes les exceptions présentes (au cas où)
      FREE : ct_exceptions.

      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

    IF &lt;lfs_s_fupararef_exception&gt;-funcname NE iv_function_name.
      &quot; On ne traite plus le même MF
      &quot;&quot;  --&gt; Arrêt de la boucle
      EXIT.

    ENDIF.

    &quot; Recherche si l&apos;Exception est déjà renseigné
    READ TABLE ct_exceptions WITH TABLE KEY name = &lt;lfs_s_fupararef_exception&gt;-parameter
                               TRANSPORTING NO FIELDS.
    IF sy-subrc NE 0.
      &quot; Exception non ajoutée
      &quot;&quot;  --&gt; Ajout de l&apos;Exception
      ls_exception-name = &lt;lfs_s_fupararef_exception&gt;-parameter.
      ls_exception-value = lines( ct_exceptions ) + 1.
      INSERT ls_exception INTO TABLE ct_exceptions.

    ENDIF.

  ENDLOOP.      &quot;Fin de parcours des Exceptions

ENDFORM.                    &quot; FUNC_EXCEPTION_TABLE_SET

*&amp;---------------------------------------------------------------------*
*&amp;      Form  FUNC_RESULT_SET
*&amp;---------------------------------------------------------------------*
*       Initialisation paramètre de retour
*----------------------------------------------------------------------*
*      --&gt; IV_SUBRC                        Code retour MF
*      --&gt; IT_PARAMETERS                   Table paramètres d&apos;appel
*      --&gt; IT_EXCEPTIONS                   Table Exception
*      --&gt; IT_FUNCTION_PARAMETERS          Table paramètre statique
*      --&gt; IS_TASK_DATA_COMPRESS_PARAM     Méthode de Compression
*      &lt;-- ET_TASK_RESULT                  Table de retour (statique)
*      &lt;-- EV_TASK_RESULT_DATA_COMPRESSED  Données compressées
*----------------------------------------------------------------------*
FORM func_result_set USING iv_subrc                       TYPE sy-subrc
                           it_parameters                  TYPE abap_func_parmbind_tab
                           it_exceptions                  TYPE abap_func_excpbind_tab
                           it_function_parameters         TYPE ztec_t_function_parameters
                           is_task_data_compress_param    TYPE ztec_s_task_compress_param
                  CHANGING et_task_result                 TYPE ztec_t_function_parameters
                           ev_task_result_data_compressed TYPE xstring.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_result TYPE ztec_s_function_parameters.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_abap_zip TYPE REF TO cl_abap_zip.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_value&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE  : et_task_result.
  CLEAR : ev_task_result_data_compressed.

  &quot; -----------------------------------------------------------
  &quot; Pré-Traitement
  &quot; -----------------------------------------------------------

  IF NOT is_task_data_compress_param IS INITIAL.
    &quot; Activation de la Compression globale ou Ligne par Ligne
    &quot;&quot;  --&gt; Création instance de Compression
    CREATE OBJECT lo_abap_zip.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Alimentation table de retour
  &quot; -----------------------------------------------------------

  &quot; Constitution table de sortie
  LOOP AT it_parameters ASSIGNING FIELD-SYMBOL(&lt;lfs_s_parameters&gt;).

    CLEAR : ls_result.

    &quot; Récupération données associé au paramètre
    READ TABLE it_function_parameters WITH KEY parameter_name = &lt;lfs_s_parameters&gt;-name
                                     ASSIGNING FIELD-SYMBOL(&lt;lfs_s_function_parameters&gt;).
    IF sy-subrc NE 0.
      &quot; Pas de correspondance // Cas ne devant pas se produire
      &quot;&quot;  --&gt; Passe à l&apos;itération suivante
      CONTINUE.

    ENDIF.

    &quot; Initialisation données du paramètre
    ls_result-parameter_name = &lt;lfs_s_function_parameters&gt;-parameter_name.
    ls_result-parameter_kind = &lt;lfs_s_function_parameters&gt;-parameter_kind.

    &quot; Initialisation données du contenu du paramètre
    ls_result-value_kind = &lt;lfs_s_function_parameters&gt;-value_kind.
    ls_result-value_type = &lt;lfs_s_function_parameters&gt;-value_type.

    &quot; Initialisation pointeur sur les données
    ASSIGN &lt;lfs_s_parameters&gt;-value-&gt;* TO &lt;lfs_value&gt;.

    &quot; Suivant le type de données
    CASE &lt;lfs_s_function_parameters&gt;-value_kind.

      WHEN cl_abap_typedescr=&gt;kind_elem.
        &quot; Elementaire
        &quot;&quot;  --&gt; Initialisation de la données
        ls_result-value_data = &lt;lfs_value&gt;.

      WHEN OTHERS.
        &quot; Cas structure complexe
        TRY.
            &quot;&quot;  --&gt; Initialisation des données sous format XML
            CALL TRANSFORMATION id
                         SOURCE data = &lt;lfs_value&gt;
                     RESULT XML ls_result-value_data_xml.

          CATCH cx_root.                  &quot;#EC CATCH_ALL #EC NO_HANDLER
            &quot; Erreur conversion en XML

        ENDTRY.

        IF NOT is_task_data_compress_param IS INITIAL.
          &quot; Compression des données activée
          IF NOT lo_abap_zip IS BOUND.
            &quot;&quot;  --&gt; Création instance Compression
            CREATE OBJECT lo_abap_zip.

          ENDIF.

          &quot;&quot;  --&gt; Ajout de la données dans dossier compression
          lo_abap_zip-&gt;add(
              name    = CONV string( &lt;lfs_s_function_parameters&gt;-parameter_name )
              content = ls_result-value_data_xml
          ).

          &quot;&quot;  --&gt; Suivant le type de compression
          CASE abap_true.

            WHEN is_task_data_compress_param-data_compress_line_by_line.
              &quot; Compression à la ligne
              &quot;&quot;  --&gt; Récupération données compressées
              ls_result-value_data_xml = lo_abap_zip-&gt;save( ).

              &quot;&quot;  --&gt; Initialisation indicateur données compressées ligne à ligne
              ls_result-value_is_compressed_local = abap_true.

              &quot;&quot;  --&gt; Libération instance Compression
              FREE : lo_abap_zip.

            WHEN is_task_data_compress_param-data_compress_global.
              &quot; Compression globale
              &quot;&quot;  --&gt; Libération contenu données
              FREE : ls_result-value_data_xml.

              &quot;&quot;  --&gt; Initialisation indicateur données compressées globale
              ls_result-value_is_compressed_global = abap_true.

            WHEN OTHERS.
              &quot; Autres

          ENDCASE.      &quot;Fin test Type de Compression

        ENDIF.          &quot;Fin test Compression données active

    ENDCASE.

    &quot; Ajout dans la table de sortie
    APPEND ls_result TO et_task_result.

  ENDLOOP.

  &quot; -----------------------------------------------------------
  &quot; Alimentation table de retour
  &quot; -----------------------------------------------------------

  &quot; -----------------------------------------------------------
  &quot; Post-Traitement
  &quot; -----------------------------------------------------------

  IF is_task_data_compress_param-data_compress_global EQ abap_true.
    &quot; Donneés compressées au global
    &quot;&quot;  --&gt; Réstitution du dossier de compression
    ev_task_result_data_compressed = lo_abap_zip-&gt;save( ).

  ENDIF.

ENDFORM.                    &quot; FUNC_RESULT_SET</include_source>
   </include>
   <include NAME="LZTEC_TASK_PARALLELF02" VARCL="X" SUBC="I" APPL="S" RMAND="200" RLOAD="F" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LZTEC_TASK_PARALLELF02.
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Include         : LZTEC_TASK_PARALLELF02                            *
*&amp; Module Fonction : Z_TASK_CALL_PROCESS                               *
*&amp; Groupe Fonction : ZTEC_TASK_PARALELL                                *
*&amp; Description     : Include pour routine sur Appel Méthode Statique   *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

*&amp;---------------------------------------------------------------------*
*&amp;      Form  METHOD_CALL_PROCESS
*&amp;---------------------------------------------------------------------*
*       Appel d&apos;une Métode Statique
*----------------------------------------------------------------------*
*      --&gt; IV_CLASS_NAME                    Classe
*      --&gt; IV_METHOD_NAME                   Méthode Statique
*      --&gt; IT_METHOD_PARAMETERS             Table des paramètres d&apos;appels
*      --&gt; IV_METHOD_DATA_COMPRESSED        Données d&apos;appe compressées
*      --&gt; IS_TASK_DATA_COMPRESS_PARAM      Type de Compression
*      &lt;-- ET_TASK_RESULT                   Données de retour
*      &lt;-- EV_TASK_RESULT_DATA_COMPRESSED   Données de retour compressées
*----------------------------------------------------------------------*
FORM method_call_process USING iv_class_name                  TYPE seoclsname
                               iv_method_name                 TYPE seocpdname
                               it_method_parameters           TYPE ztec_t_function_parameters
                               iv_method_data_compressed      TYPE xstring
                               is_task_data_compress_param    TYPE ztec_s_task_compress_param
                      CHANGING et_task_result                 TYPE ztec_t_function_parameters
                               ev_task_result_data_compressed TYPE xstring.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_table_data       TYPE tt_table_data,
    lt_exceptions       TYPE abap_excpbind_tab,
    lt_parameters       TYPE abap_parmbind_tab,
    lt_exceptions_class TYPE tt_exceptions_class.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_subrc             TYPE sy-subrc,                     &quot;#EC NEEDED
    lv_sconame           TYPE seosubco-sconame,
    lv_exception_by_meth TYPE xsdboolean.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR   : ev_task_result_data_compressed.
  REFRESH : et_task_result.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Initialisation tables paramètres d&apos;appel Dynamique
      &quot; -----------------------------------------------------------

      &quot; Initialisation des paramètres dynamique
      PERFORM meth_dynamic_parameters_set USING iv_class_name
                                                iv_method_name
                                                it_method_parameters
                                                iv_method_data_compressed
                                       CHANGING lt_table_data   &quot;Sert à stocker les références des données
                                                lt_parameters
                                                lt_exceptions.

    CATCH cx_root.                                       &quot;#EC CATCH_ALL
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Arrêt du traitement
      MESSAGE ID zif_task_constant=&gt;mc_message_class_id
            TYPE &apos;E&apos;                                        &quot;#EC NOTEXT
          NUMBER 006                                        &quot;#EC NOTEXT
         RAISING dynamic_convert_error.

  ENDTRY.

  IF lt_exceptions[] IS INITIAL.
    &quot; -----------------------------------------------------------
    &quot; Gestion des Exceptions // Afin d&apos;éviter toute erreur
    &quot; -----------------------------------------------------------
    PERFORM meth_exception_table_set USING iv_class_name
                                           iv_method_name
                                  CHANGING lt_exceptions
                                           lt_exceptions_class.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Appel de la Méthode
      &quot; -----------------------------------------------------------

      &quot; Appel de la Méthode avec paramètres dynamique
      CALL METHOD (iv_class_name)=&gt;(iv_method_name)
        PARAMETER-TABLE lt_parameters
        EXCEPTION-TABLE lt_exceptions.
      lv_subrc = sy-subrc.

    CATCH cx_root INTO DATA(lo_cx_exception).
      &quot; Une erreur est survenue durant l&apos;exécution de la méthode
      &quot;&quot;  --&gt; Il faut différencier l&apos;erreur générée par la méthode
      &quot;&quot;      de l&apos;erreur générée par l&apos;appel de la méthode
      &quot;&quot;  --&gt; Récupération du nom de la classe d&apos;exception
      lv_sconame = cl_abap_classdescr=&gt;get_class_name( lo_cx_exception ).
      lv_sconame = lv_sconame+7.  &quot;Conserve uniquement le nom de la classe

      &quot;&quot;  --&gt; Recherche si cette classe est gérée par la méthode
      READ TABLE lt_exceptions_class WITH TABLE KEY table_line = lv_sconame
                                       TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.
        &quot; Non gérée par la Méthode
        WHILE lo_cx_exception-&gt;previous IS BOUND.
          &quot;&quot;  --&gt; On remonte dans la pile d&apos;exception
          lo_cx_exception = lo_cx_exception-&gt;previous.

          &quot;&quot;  --&gt; Récupération du nom de la classe d&apos;exception
          lv_sconame = cl_abap_classdescr=&gt;get_class_name( lo_cx_exception ).
          lv_sconame = lv_sconame+7.  &quot;Conserve uniquement le nom de la classe

          &quot;&quot;  --&gt; Recherche si cette classe est gérée par la méthode
          READ TABLE lt_exceptions_class WITH TABLE KEY table_line = lv_sconame
                                           TRANSPORTING NO FIELDS.
          IF sy-subrc EQ 0.
            &quot; Exception gérée par la méthode
            &quot;&quot;  --&gt; Initialisation indicateur Exception gérée par la méthode
            lv_exception_by_meth = abap_true.

            &quot;&quot;  --&gt; Arrêt de la boucle
            EXIT.

          ENDIF.

        ENDWHILE.

      ELSE.
        &quot; Exception gérée par la Méthode
        &quot;&quot;  --&gt; Initialisation indicateur Exception gérée par la méthode
        lv_exception_by_meth = abap_true.

      ENDIF.

      IF lv_exception_by_meth EQ abap_true.
        &quot; Une Exception gérée par la méthode est survenue
        &quot;&quot;  --&gt; Transmet l&apos;Exception en retour
        lo_cx_exception-&gt;get_text( ).
        MESSAGE ID sy-msgid TYPE sy-msgty
            NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
           RAISING during_process_error.

      ELSE.
        &quot; Une Exception non gérée par la méthode est survenue
        &quot;&quot;  --&gt; Arrêt du traitement
        MESSAGE ID zif_task_constant=&gt;mc_message_class_id
              TYPE &apos;E&apos;                                      &quot;#EC NOTEXT
            NUMBER 502                                      &quot;#EC NOTEXT
              WITH |{ iv_class_name }=&gt;{ iv_method_name }|  &quot;#EC NOTEXT
                   lo_cx_exception-&gt;get_text( )
           RAISING dynamic_call_error.

      ENDIF.

  ENDTRY.

  &quot; -----------------------------------------------------------
  &quot; Initialisation table de retour
  &quot; -----------------------------------------------------------

  &quot; Conserve uniquement les paramètres d&apos;Export / Changing / Table / Retour (vue Méthode)
  DELETE lt_parameters WHERE kind EQ cl_abap_objectdescr=&gt;exporting.
  IF NOT lt_parameters[] IS INITIAL.
    &quot; Initialisation table de retour
    PERFORM meth_result_set USING lt_parameters
                                  it_method_parameters
                                  is_task_data_compress_param
                         CHANGING et_task_result
                                  ev_task_result_data_compressed.

  ENDIF.

ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  METH_DYNAMIC_PARAMETERS_SET
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt; IV_CLASS_NAME              Classe
*      --&gt; IV_METHOD_NAME             Méthode
*      --&gt; IT_METHOD_PARAMETERS       Table paramètre statique
*      --&gt; IV_METHOD_DATA_COMPRESSED  Données comprimées
*      &lt;-- ET_TABLE_DATA              Table container des données
*      &lt;-- ET_PARAMETERS              Table paramètre dynamique
*      &lt;-- ET_EXCEPTIONS              Table exception dynamique
*----------------------------------------------------------------------*
FORM meth_dynamic_parameters_set USING iv_class_name             TYPE seoclsname
                                       iv_method_name            TYPE seocpdname
                                       it_method_parameters      TYPE ztec_t_function_parameters
                                       iv_method_data_compressed TYPE xstring
                              CHANGING et_table_data             TYPE tt_table_data
                                       et_parameters             TYPE abap_parmbind_tab
                                       et_exceptions             TYPE abap_excpbind_tab.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_table_data TYPE ts_table_data,
    ls_exceptions TYPE abap_excpbind,
    ls_parameters TYPE abap_parmbind.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_abap_zip        TYPE REF TO cl_abap_zip,
    lo_type_descr      TYPE REF TO cl_abap_typedescr,
    lo_cx_exception    TYPE REF TO cx_root,
    lo_type_definition TYPE REF TO zcl_type_definition.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
        lv_data_decompress TYPE xstring.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_value_data&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  REFRESH : et_parameters, et_exceptions, et_table_data.

  &quot; -----------------------------------------------------------
  &quot; Pré-Traitement
  &quot; -----------------------------------------------------------

  IF NOT iv_method_data_compressed IS INITIAL.
    &quot; Données compressées
    &quot;&quot;  --&gt; Chargement dossier compressées
    CREATE OBJECT lo_abap_zip.
    lo_abap_zip-&gt;support_unicode_names = abap_true.
    lo_abap_zip-&gt;load(
      EXPORTING
        zip             = iv_method_data_compressed
      EXCEPTIONS
        zip_parse_error = 1
        OTHERS          = 2
    ).
    IF sy-subrc NE 0.
      &quot; Une erreur est survenue // Les données sont illisibles
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Conversion des paramètres &quot;statiques&quot; en &quot;dynamique&quot;
  &quot; -----------------------------------------------------------

  &quot; Parcours l&apos;ensemble des paramètres &quot;statique&quot;
  LOOP AT it_method_parameters ASSIGNING FIELD-SYMBOL(&lt;lfs_s_method_parameters&gt;).

    CLEAR    : ls_parameters, ls_exceptions, ls_table_data, lv_data_decompress.
    UNASSIGN : &lt;lfs_value_data&gt;.

    &quot; Contrôle cohérence du Type
    cl_abap_typedescr=&gt;describe_by_name(
      EXPORTING
        p_name         = &lt;lfs_s_method_parameters&gt;-value_type
      EXCEPTIONS
        type_not_found = 1
        OTHERS         = 2
    ).
    IF sy-subrc NE 0.
      &quot; Type non défini dans le RTTS du système
      &quot;&quot;  --&gt; On va le charger depuis la mémoire partagée
      IF NOT lo_type_definition IS BOUND.
        &quot; Récupération instance courante
        lo_type_definition = zcl_type_definition=&gt;get_instance( ).

      ENDIF.

      TRY.
          &quot; Récupération de la définition du Type
          lo_type_descr = lo_type_definition-&gt;definition_type_get( &lt;lfs_s_method_parameters&gt;-value_type ).

        CATCH zcx_type_definition INTO lo_cx_exception.
          &quot; Erreur lors de la récupération de la définition du Type
          &quot;&quot;  --&gt; Lève une Exception
          WHILE lo_cx_exception-&gt;previous IS BOUND. lo_cx_exception = lo_cx_exception-&gt;previous. ENDWHILE.
          RAISE EXCEPTION TYPE zcx_task_call
            EXPORTING
              previous = lo_cx_exception.

      ENDTRY.

      &quot;&quot;  --&gt; Création de la zone Typée
      CREATE DATA ls_table_data-value TYPE (lo_type_descr-&gt;absolute_name).

    ELSE.
      &quot;&quot;  --&gt; Création de la zone typée
      CREATE DATA ls_table_data-value TYPE (&lt;lfs_s_method_parameters&gt;-value_type).

    ENDIF.

    &quot; Initialisation pointeur sur la donnée
    ASSIGN ls_table_data-value-&gt;* TO &lt;lfs_value_data&gt;.

    &quot; Suivant le Type du paramètre (Signature)
    CASE &lt;lfs_s_method_parameters&gt;-parameter_kind.

      WHEN cl_abap_objectdescr=&gt;importing.
        &quot; Cas d&apos;un paramètre d&apos;Export (Vu Méthode)
        &quot;&quot;  --&gt; Les paramètres d&apos;Export non pas à être rempli !

      WHEN OTHERS.
        &quot; Autre type de paramètre
        IF &lt;lfs_s_method_parameters&gt;-value_is_compressed_global EQ abap_true
        OR NOT &lt;lfs_s_method_parameters&gt;-value_data_xml         IS INITIAL.
          &quot; Données &quot;complexe&quot; stockées sous forme XML
          &quot;&quot;  --&gt; Suivant méthode de compression
          CASE abap_true.

            WHEN &lt;lfs_s_method_parameters&gt;-value_is_compressed_local.
              &quot; Compression ligne à ligne
              &quot;&quot;  --&gt; Création instance compression
              CREATE OBJECT lo_abap_zip.
              lo_abap_zip-&gt;support_unicode_names = abap_true.

              &quot;&quot;  --&gt; Lecture dossier compressé
              lo_abap_zip-&gt;load(
                EXPORTING
                  zip             = &lt;lfs_s_method_parameters&gt;-value_data_xml
                EXCEPTIONS
                  zip_parse_error = 1
                  OTHERS          = 2
              ).
              IF sy-subrc EQ 0.
                &quot; Aucune erreur
                &quot;&quot;  --&gt; Récupération données décompressées
                lo_abap_zip-&gt;get(
                  EXPORTING
                    index                   = 1
                  IMPORTING
                    content                 = lv_data_decompress
                  EXCEPTIONS
                    zip_index_error         = 1
                    zip_decompression_error = 2
                    OTHERS                  = 3
                ).

              ENDIF.
              IF sy-subrc NE 0.
                &quot; Une erreur est survenue
                &quot;&quot;  --&gt; Réinitialisation données
                CLEAR : lv_data_decompress.

              ENDIF.

            WHEN &lt;lfs_s_method_parameters&gt;-value_is_compressed_global.
              &quot; Compression globale
              &quot;&quot;  --&gt; Décompression des données
              lo_abap_zip-&gt;get(
                EXPORTING
                  name                    = CONV string( &lt;lfs_s_method_parameters&gt;-parameter_name )
                IMPORTING
                  content                 = lv_data_decompress
                EXCEPTIONS
                  zip_index_error         = 1
                  zip_decompression_error = 2
                  OTHERS                  = 3
              ).
              IF sy-subrc NE 0.
                &quot; Une erreur est survenue
                &quot;&quot;  --&gt; Réinitialisation données
                CLEAR : lv_data_decompress.

              ENDIF.

            WHEN OTHERS.
              &quot; Autres
              &quot;&quot;  --&gt; Pas de décompression // Rien à faire
              lv_data_decompress = &lt;lfs_s_method_parameters&gt;-value_data_xml.

          ENDCASE.

          IF NOT lv_data_decompress IS INITIAL.
            &quot;&quot; --&gt; Restructuration des données
            CALL TRANSFORMATION id
                     SOURCE XML lv_data_decompress
                         RESULT data = &lt;lfs_value_data&gt;.

          ENDIF.

        ELSEIF NOT &lt;lfs_s_method_parameters&gt;-value_data IS INITIAL.
          &quot; Type Elémentaire
          &quot;&quot;  --&gt; Initialisation des données
          &lt;lfs_value_data&gt; = &lt;lfs_s_method_parameters&gt;-value_data.

        ELSE.                                               &quot;#EC NEEDED
          &quot; Autre cas
          &quot;&quot;  --&gt; ToDo : Ajouter ici les autres cas

        ENDIF.

    ENDCASE.

    &quot;&quot;  --&gt; Création d&apos;une entrée permettant de stocker les paramètres d&apos;appel Dynamique
    ls_table_data-name = &lt;lfs_s_method_parameters&gt;-parameter_name.                &quot;Nom du paramètre
    INSERT ls_table_data INTO TABLE et_table_data.                                  &quot;Ajout dans table de paramètre

    &quot;&quot;  --&gt; Initialisation table paramètre d&apos;appel dynamique
    ls_parameters-name  = &lt;lfs_s_method_parameters&gt;-parameter_name.    &quot;Nom du paramètre
    ls_parameters-kind  = &lt;lfs_s_method_parameters&gt;-parameter_kind.    &quot;Type (ABAP) du paramètre
    ls_parameters-value = REF #( &lt;lfs_value_data&gt; ).                   &quot;Référence sur le contenu
    INSERT ls_parameters INTO TABLE et_parameters.                     &quot;Ajout du paramètre dynamique

  ENDLOOP.

  &quot; -----------------------------------------------------------
  &quot; Fin de traitement
  &quot; -----------------------------------------------------------

  IF lo_type_definition IS BOUND.
    TRY.
        &quot; Libération Token Mémoire Partagée
        lo_type_definition-&gt;definition_type_finish( ).

      CATCH zcx_type_definition.                        &quot;#EC NO_HANDLER
        &quot; Erreur libération mémoire

    ENDTRY.

  ENDIF.

ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  METH_EXCEPTION_TABLE_SET
*&amp;---------------------------------------------------------------------*
*       Initialisation table d&apos;Exception
*----------------------------------------------------------------------*
*      --&gt; IV_CLASS_NAME        Classe
*      --&gt; IV_METHOD_NAME       Méthode
*      &lt;-&gt; CT_EXCEPTIONS        Table des Exceptions classique
*      &lt;-- ET_EXCEPTIONS_CLASS  Table des Exceptions basées sur Classe
*----------------------------------------------------------------------*
FORM meth_exception_table_set USING iv_class_name       TYPE seoclsname
                                    iv_method_name      TYPE seocpdname
                           CHANGING ct_exceptions       TYPE abap_excpbind_tab
                                    et_exceptions_class TYPE tt_exceptions_class.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_seosubco_exception TYPE tt_seosubco_exception.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_exception          TYPE abap_excpbind,
    ls_seosubco_exception TYPE ts_seosubco_exception.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  REFRESH : et_exceptions_class.

  &quot; -----------------------------------------------------------
  &quot; Récupération des Exceptions de la Méthode
  &quot; -----------------------------------------------------------

  &quot; Récupération position première occurence associée à la Méthode
  READ TABLE gs_persistent_data-t_seosubco_exception
    WITH KEY clsname = iv_class_name
             cmpname = iv_method_name
    TRANSPORTING NO FIELDS
          BINARY SEARCH.
  IF sy-subrc NE 0.
    &quot; Aucune Exception
    SELECT main~clsname, main~cmpname, main~sconame, def~mtdnewexc
           FROM seosubco     AS main
     INNER JOIN seocompodf   AS def
             ON def~clsname  EQ main~clsname
            AND def~cmpname  EQ main~cmpname
          WHERE main~clsname EQ @iv_class_name
            AND main~cmpname EQ @iv_method_name
            AND main~scotype EQ &apos;1&apos; &quot;Exception &quot;#EC NOTEXT
            AND def~version  EQ &apos;1&apos; &quot;Actif &quot;#EC NOTEXT
     INTO TABLE @lt_seosubco_exception. ##TOO_MANY_ITAB_FIELDS
    IF sy-subrc NE 0.
      &quot; Création d&apos;une entrée afin de ne pas rechercher à nouveau les données
      ls_seosubco_exception-clsname   = iv_class_name.
      ls_seosubco_exception-cmpname   = iv_method_name.
      ls_seosubco_exception-not_found = abap_true.
      INSERT ls_seosubco_exception INTO TABLE gs_persistent_data-t_seosubco_exception.

    ELSE.
      &quot; Ajout des entrées
      INSERT LINES OF lt_seosubco_exception INTO TABLE gs_persistent_data-t_seosubco_exception.
      FREE : lt_seosubco_exception.

    ENDIF.

    &quot; Récupération position première occurence
    READ TABLE gs_persistent_data-t_seosubco_exception
      WITH KEY clsname = iv_class_name
               cmpname = iv_method_name
      TRANSPORTING NO FIELDS
            BINARY SEARCH.

  ENDIF.

  IF sy-subrc NE 0.
    &quot; Aucune Exception trouvée
    &quot;&quot;  --&gt; Supprime toutes les exceptions présentes
    FREE : ct_exceptions.

    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Récupération des Exceptions du MF
  &quot; -----------------------------------------------------------

  &quot; Parcours l&apos;ensemble des Exceptions
  LOOP AT gs_persistent_data-t_seosubco_exception ASSIGNING FIELD-SYMBOL(&lt;lfs_s_seosubco_exception&gt;)
                                                       FROM sy-tabix.

    CLEAR : ls_exception.

    IF &lt;lfs_s_seosubco_exception&gt;-not_found EQ abap_true.
      &quot; Aucune Exception
      &quot;&quot;  --&gt; Supprime toutes les exceptions présentes (au cas où)
      FREE : ct_exceptions.

      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

    IF &lt;lfs_s_seosubco_exception&gt;-clsname NE iv_class_name
    OR &lt;lfs_s_seosubco_exception&gt;-cmpname NE iv_method_name.
      &quot; On ne traite plus la même Méthode
      &quot;&quot;  --&gt; Arrêt de la boucle
      EXIT.

    ENDIF.

    IF &lt;lfs_s_seosubco_exception&gt;-mtdnewexc EQ abap_false.
      &quot; Exception &quot;classique&quot;
      &quot;&quot;  --&gt; Recherche si l&apos;Exception est déjà renseigné
      READ TABLE ct_exceptions WITH TABLE KEY name = &lt;lfs_s_seosubco_exception&gt;-sconame
                                 TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.
        &quot; Exception non ajoutée
        &quot;&quot;  --&gt; Ajout de l&apos;Exception
        ls_exception-name = &lt;lfs_s_seosubco_exception&gt;-sconame.
        ls_exception-value = lines( ct_exceptions ) + 1.
        INSERT ls_exception INTO TABLE ct_exceptions.

      ENDIF.

    ELSE.
      &quot; Exception basée sur classe
      &quot;&quot;  --&gt; Ajout de la Classe d&apos;Exception
      INSERT &lt;lfs_s_seosubco_exception&gt;-sconame INTO TABLE et_exceptions_class.

    ENDIF.

  ENDLOOP.      &quot;Fin de parcours des Exceptions

ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  METH_RESULT_SET
*&amp;---------------------------------------------------------------------*
*       Initialisation paramètre de retour
*----------------------------------------------------------------------*
*      --&gt; IT_PARAMETERS                   Table des paramètres d&apos;appel
*      --&gt; IT_METHOD_PARAMETERS            Table des paramètres statiques
*      --&gt; IS_TASK_DATA_COMPRESS_PARAM     Méthode de Compression
*      &lt;-- ET_TASK_RESULT                  Table de retour (statique)
*      &lt;-- EV_TASK_RESULT_DATA_COMPRESSED  Données compressées
*----------------------------------------------------------------------*
FORM meth_result_set USING it_parameters                   TYPE abap_parmbind_tab
                           it_method_parameters            TYPE ztec_t_function_parameters
                           is_task_data_compress_param     TYPE ztec_s_task_compress_param
                  CHANGING et_task_result                  TYPE ztec_t_function_parameters
                           ev_task_result_data_compressed  TYPE xstring.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_result TYPE ztec_s_function_parameters.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_abap_zip TYPE REF TO cl_abap_zip.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_value&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE  : et_task_result.
  CLEAR : ev_task_result_data_compressed.

  &quot; -----------------------------------------------------------
  &quot; Pré-Traitement
  &quot; -----------------------------------------------------------

  IF NOT is_task_data_compress_param IS INITIAL.
    &quot; Activation de la Compression globale ou Ligne par Ligne
    &quot;&quot;  --&gt; Création instance de Compression
    CREATE OBJECT lo_abap_zip.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Alimentation table de retour
  &quot; -----------------------------------------------------------

  &quot; Constitution table de sortie
  LOOP AT it_parameters ASSIGNING FIELD-SYMBOL(&lt;lfs_s_parameters&gt;).

    CLEAR : ls_result.

    &quot; Récupération données associé au paramètre
    READ TABLE it_method_parameters WITH KEY parameter_name = &lt;lfs_s_parameters&gt;-name
                                   ASSIGNING FIELD-SYMBOL(&lt;lfs_s_method_parameters&gt;).
    IF sy-subrc NE 0.
      &quot; Pas de correspondance // Cas ne devant pas se produire
      &quot;&quot;  --&gt; Passe à l&apos;itération suivante
      CONTINUE.

    ENDIF.

    &quot; Initialisation données du paramètre
    ls_result-parameter_name = &lt;lfs_s_method_parameters&gt;-parameter_name.
    ls_result-parameter_kind = &lt;lfs_s_method_parameters&gt;-parameter_kind.

    &quot; Initialisation données du contenu du paramètre
    ls_result-value_kind = &lt;lfs_s_method_parameters&gt;-value_kind.
    ls_result-value_type = &lt;lfs_s_method_parameters&gt;-value_type.

    &quot; Initialisation pointeur sur les données
    ASSIGN &lt;lfs_s_parameters&gt;-value-&gt;* TO &lt;lfs_value&gt;.

    &quot; Suivant le type de données
    CASE &lt;lfs_s_method_parameters&gt;-value_kind.

      WHEN cl_abap_typedescr=&gt;kind_elem.
        &quot; Elementaire
        &quot;&quot;  --&gt; Initialisation de la données
        ls_result-value_data = &lt;lfs_value&gt;.

      WHEN OTHERS.
        &quot; Cas structure complexe
        TRY.
            &quot;&quot;  --&gt; Initialisation des données sous format XML
            CALL TRANSFORMATION id
                         SOURCE data = &lt;lfs_value&gt;
                     RESULT XML ls_result-value_data_xml.

          CATCH cx_root.                  &quot;#EC CATCH_ALL #EC NO_HANDLER
            &quot; Erreur conversion en XML

        ENDTRY.

        IF NOT is_task_data_compress_param IS INITIAL.
          &quot; Compression des données activée
          IF NOT lo_abap_zip IS BOUND.
            &quot;&quot;  --&gt; Création instance Compression
            CREATE OBJECT lo_abap_zip.

          ENDIF.

          &quot;&quot;  --&gt; Ajout de la données dans dossier compression
          lo_abap_zip-&gt;add(
              name    = CONV string( &lt;lfs_s_method_parameters&gt;-parameter_name )
              content = ls_result-value_data_xml
          ).

          &quot;&quot;  --&gt; Suivant le type de compression
          CASE abap_true.

            WHEN is_task_data_compress_param-data_compress_line_by_line.
              &quot; Compression à la ligne
              &quot;&quot;  --&gt; Récupération données compressées
              ls_result-value_data_xml = lo_abap_zip-&gt;save( ).

              &quot;&quot;  --&gt; Initialisation indicateur données compressées ligne à ligne
              ls_result-value_is_compressed_local = abap_true.

              &quot;&quot;  --&gt; Libération instance Compression
              FREE : lo_abap_zip.

            WHEN is_task_data_compress_param-data_compress_global.
              &quot; Compression globale
              &quot;&quot;  --&gt; Libération contenu données
              FREE : ls_result-value_data_xml.

              &quot;&quot;  --&gt; Initialisation indicateur données compressées globale
              ls_result-value_is_compressed_global = abap_true.

            WHEN OTHERS.
              &quot; Autres

          ENDCASE.      &quot;Fin test Type de Compression

        ENDIF.          &quot;Fin test Compression données active

    ENDCASE.

    &quot; Ajout dans la table de sortie
    APPEND ls_result TO et_task_result.

  ENDLOOP.

  &quot; -----------------------------------------------------------
  &quot; Post-Traitement
  &quot; -----------------------------------------------------------

  IF is_task_data_compress_param-data_compress_global EQ abap_true.
    &quot; Donneés compressées au global
    &quot;&quot;  --&gt; Réstitution du dossier de compression
    ev_task_result_data_compressed = lo_abap_zip-&gt;save( ).

  ENDIF.

ENDFORM.</include_source>
   </include>
   <include NAME="LZTEC_TASK_PARALLELF03" VARCL="X" SUBC="I" APPL="S" RMAND="200" RLOAD="F" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LZTEC_TASK_PARALLELF03.
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Include         : LZTEC_TASK_PARALLELF03                            *
*&amp; Module Fonction : Z_TASK_CALL_PROCESS                               *
*&amp; Groupe Fonction : ZTEC_TASK_PARALELL                                *
*&amp; Description     : Include pour routine sur Appel Programme          *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *


*&amp;---------------------------------------------------------------------*
*&amp;      Form  REPID_CALL_PROCESS
*&amp;---------------------------------------------------------------------*
*       Appel d&apos;un Programme
*----------------------------------------------------------------------*
*      --&gt; IV_REPID_NAME                    Nom du Programme
*      --&gt; IT_REPID_PARAMETERS              Table des paramètres d&apos;appels
*      --&gt; IV_REPID_DATA_COMPRESSED         Données d&apos;appe compressées
*      --&gt; IS_TASK_DATA_COMPRESS_PARAM      Type de Compression
*      &lt;-- ET_TASK_RESULT                   Données de retour
*      &lt;-- EV_TASK_RESULT_DATA_COMPRESSED   Données de retour compressées
*----------------------------------------------------------------------*
FORM repid_call_process USING iv_repid_name                  TYPE sy-repid
                              it_repid_parameters            TYPE ztec_t_function_parameters
                              iv_repid_data_compressed       TYPE xstring
                              is_task_data_compress_param    TYPE ztec_s_task_compress_param
                     CHANGING et_task_result                 TYPE ztec_t_function_parameters
                              ev_task_result_data_compressed TYPE xstring.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_parameters TYPE pivb_rsparamsl_255_t.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_subrc    TYPE sy-subrc,                              &quot;#EC NEEDED
    lv_user     TYPE sy-uname,
    lv_variant  TYPE variant,
    lv_jobname  TYPE tbtcjob-jobname,
    lv_jobcount TYPE tbtcjob-jobcount.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR   : ev_task_result_data_compressed.
  REFRESH : et_task_result.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Initialisation tables paramètres d&apos;appel Dynamique
      &quot; -----------------------------------------------------------

      &quot; Initialisation des paramètres dynamique
      PERFORM repid_dynamic_parameters_set USING iv_repid_name
                                                 it_repid_parameters
                                                 iv_repid_data_compressed
                                        CHANGING lt_parameters
                                                 lv_variant
                                                 lv_user.

    CATCH cx_root.                                       &quot;#EC CATCH_ALL
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Arrêt du traitement
      MESSAGE ID zif_task_constant=&gt;mc_message_class_id
            TYPE &apos;E&apos;                                        &quot;#EC NOTEXT
          NUMBER 006                                        &quot;#EC NOTEXT
         RAISING dynamic_convert_error.

  ENDTRY.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Appel du Programme
      &quot; -----------------------------------------------------------

      &quot; Initialisation Nom du Job
      lv_jobname = |ZTASK_{ iv_repid_name }|.               &quot;#EC NOTEXT

      &quot; Ouverture JOB
      CALL FUNCTION &apos;JOB_OPEN&apos;
        EXPORTING
          jobname          = lv_jobname
        IMPORTING
          jobcount         = lv_jobcount
        EXCEPTIONS
          cant_create_job  = 1
          invalid_job_data = 2
          jobname_missing  = 3
          OTHERS           = 4.
      IF sy-subrc EQ 0.
        IF NOT lv_variant IS INITIAL.
          &quot; Appel du Programme avec variante
          SUBMIT (iv_repid_name) VIA JOB lv_jobname
                                  NUMBER lv_jobcount
                                    USER lv_user
                     USING SELECTION-SET lv_variant
                                     AND RETURN.

        ELSE.
          &quot; Appel du Programme avec paramètres dynamique
          SUBMIT (iv_repid_name) VIA JOB lv_jobname
                                  NUMBER lv_jobcount
                                    USER lv_user
                    WITH SELECTION-TABLE lt_parameters
                                     AND RETURN.

        ENDIF.

        &quot; Fermeture du Job
        CALL FUNCTION &apos;JOB_CLOSE&apos;
          EXPORTING
            jobcount             = lv_jobcount
            jobname              = lv_jobname
            strtimmed            = abap_true
          EXCEPTIONS
            cant_start_immediate = 1
            invalid_startdate    = 2
            jobname_missing      = 3
            job_close_failed     = 4
            job_nosteps          = 5
            job_notex            = 6
            lock_failed          = 7
            invalid_target       = 8
            OTHERS               = 9.

      ENDIF.

      IF sy-subrc NE 0.
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Lève une Exception
        MESSAGE ID sy-msgid
              TYPE &apos;E&apos;                                      &quot;#EC NOTEXT
            NUMBER sy-msgno                                 &quot;#EC NOTEXT
              WITH sy-msgv1 sy-msgv2
                   sy-msgv3 sy-msgv4
           RAISING dynamic_call_error.

      ENDIF.

    CATCH cx_root INTO DATA(lo_cx_exception).
      &quot; Une erreur est survenue durant l&apos;exécution de la méthode
      &quot;&quot;  --&gt; Arrêt du traitement
      MESSAGE ID zif_task_constant=&gt;mc_message_class_id
            TYPE &apos;E&apos;                                        &quot;#EC NOTEXT
          NUMBER 502                                        &quot;#EC NOTEXT
            WITH |{ iv_repid_name }|
                 lo_cx_exception-&gt;get_text( )
         RAISING dynamic_call_error.

  ENDTRY.

  &quot; -----------------------------------------------------------
  &quot; Initialisation table de retour
  &quot; -----------------------------------------------------------

  &quot; Initialisation table de retour
  PERFORM repid_result_set USING lv_jobname
                                 lv_jobcount
                                 is_task_data_compress_param
                        CHANGING et_task_result
                                 ev_task_result_data_compressed.

ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  REPID_DYNAMIC_PARAMETERS_SET
*&amp;---------------------------------------------------------------------*
*       Conversion des données Statiques en Dynamiques
*----------------------------------------------------------------------*
*      --&gt; IV_REPID_NAME                Nom du Programme
*      --&gt; IT_REPID_PARAMETERS          Table des paramètres d&apos;appels
*      --&gt; IV_REPID_DATA_COMPRESSED     Données d&apos;appe compressées
*      &lt;-- ET_PARAMETERS                Table paramètre dynamique
*      &lt;-- EV_VARIANT                   Variante Programme
*----------------------------------------------------------------------*
FORM repid_dynamic_parameters_set USING iv_repid_name            TYPE repid
                                        it_repid_parameters      TYPE ztec_t_function_parameters
                                        iv_repid_data_compressed TYPE xstring
                               CHANGING et_parameters            TYPE pivb_rsparamsl_255_t
                                        ev_variant               TYPE variant
                                        ev_user                  TYPE sy-uname.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_parameters TYPE rsparamsl_255.


***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_data         TYPE REF TO data,
    lo_abap_zip     TYPE REF TO cl_abap_zip,
    lo_type_descr   TYPE REF TO cl_abap_typedescr,
    lo_cx_exception TYPE REF TO cx_root.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
        lv_data_decompress TYPE xstring.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_value_data&gt;         TYPE any,
    &lt;lfs_t_value_data&gt;       TYPE ANY TABLE,
    &lt;lfs_s_repid_parameters&gt; TYPE ztec_s_function_parameters.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : et_parameters.

  &quot; -----------------------------------------------------------
  &quot; Pré-Traitement
  &quot; -----------------------------------------------------------

  IF NOT iv_repid_data_compressed IS INITIAL.
    &quot; Données compressées
    &quot;&quot;  --&gt; Chargement dossier compressées
    CREATE OBJECT lo_abap_zip.
    lo_abap_zip-&gt;support_unicode_names = abap_true.
    lo_abap_zip-&gt;load(
      EXPORTING
        zip             = iv_repid_data_compressed
      EXCEPTIONS
        zip_parse_error = 1
        OTHERS          = 2
    ).
    IF sy-subrc NE 0.
      &quot; Une erreur est survenue // Les données sont illisibles
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Récupération du Nom d&apos;Utilisateur
  &quot; -----------------------------------------------------------

  &quot; Récupération de l&apos;utilisateur
  READ TABLE it_repid_parameters WITH KEY parameter_name = zif_task_constant=&gt;mc_parameter_name_user
                                ASSIGNING &lt;lfs_s_repid_parameters&gt;.
  IF sy-subrc EQ 0.
    &quot; Usage Utilisateur spécifique trouvé
    &quot;&quot;  --&gt; Retourne le Nom de l&apos;Utilisateur
    ev_user = &lt;lfs_s_repid_parameters&gt;-value_data.

  ELSE.
    &quot; Pas d&apos;utilisateur spécifié
    &quot;&quot;  --&gt; Utilisation de l&apos;Utilisateur courant
    ev_user = sy-uname.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Recherche si Usage d&apos;une Variante
  &quot; -----------------------------------------------------------

  &quot; Récupération de la Variante
  READ TABLE it_repid_parameters WITH KEY parameter_name = zif_task_constant=&gt;mc_parameter_name_variant
                                ASSIGNING &lt;lfs_s_repid_parameters&gt;.
  IF sy-subrc EQ 0.
    &quot; Usage Variante trouvé
    &quot;&quot;  --&gt; Retourne le Nom de la Variante
    ev_variant = &lt;lfs_s_repid_parameters&gt;-value_data.

  ELSE.
    &quot; -----------------------------------------------------------
    &quot; Conversion des paramètres &quot;statique&quot; en &quot;dynamique&quot;
    &quot; -----------------------------------------------------------

    &quot; Parcours l&apos;ensemble des paramètres &quot;statique&quot;
    LOOP AT it_repid_parameters ASSIGNING &lt;lfs_s_repid_parameters&gt;.

      CLEAR    : ls_parameters, lv_data_decompress.
      UNASSIGN : &lt;lfs_value_data&gt;.

      IF &lt;lfs_s_repid_parameters&gt;-parameter_name CS zif_task_constant=&gt;mc_parameter_name_repid_prefix.
        &quot; Paramètre de Configuration
        &quot;&quot;  --&gt; Passe à l&apos;itération suivante
        CONTINUE.

      ENDIF.

      &quot; Contrôle cohérence du Type
      cl_abap_typedescr=&gt;describe_by_name(
        EXPORTING
          p_name         = &lt;lfs_s_repid_parameters&gt;-value_type
        EXCEPTIONS
          type_not_found = 1
          OTHERS         = 2
      ).
      IF sy-subrc NE 0.
        &quot; Type non défini dans le RTTS du système
        &quot;&quot;  --&gt; ToDo
        CONTINUE.

      ELSE.
        &quot;&quot;  --&gt; Création de la zone typée
        CREATE DATA lo_data TYPE (&lt;lfs_s_repid_parameters&gt;-value_type).

      ENDIF.

      &quot; Initialisation pointeur sur la donnée
      ASSIGN lo_data-&gt;* TO &lt;lfs_value_data&gt;.

      IF &lt;lfs_s_repid_parameters&gt;-value_is_compressed_global EQ abap_true
      OR NOT &lt;lfs_s_repid_parameters&gt;-value_data_xml         IS INITIAL.
        &quot; Données &quot;complexe&quot; stockées sous forme XML
        &quot;&quot;  --&gt; Suivant méthode de compression
        CASE abap_true.

          WHEN &lt;lfs_s_repid_parameters&gt;-value_is_compressed_local.
            &quot; Compression ligne à ligne
            &quot;&quot;  --&gt; Création instance compression
            CREATE OBJECT lo_abap_zip.
            lo_abap_zip-&gt;support_unicode_names = abap_true.

            &quot;&quot;  --&gt; Lecture dossier compressé
            lo_abap_zip-&gt;load(
              EXPORTING
                zip             = &lt;lfs_s_repid_parameters&gt;-value_data_xml
              EXCEPTIONS
                zip_parse_error = 1
                OTHERS          = 2
            ).
            IF sy-subrc EQ 0.
              &quot; Aucune erreur
              &quot;&quot;  --&gt; Récupération données décompressées
              lo_abap_zip-&gt;get(
                EXPORTING
                  index                   = 1
                IMPORTING
                  content                 = lv_data_decompress
                EXCEPTIONS
                  zip_index_error         = 1
                  zip_decompression_error = 2
                  OTHERS                  = 3
              ).

            ENDIF.
            IF sy-subrc NE 0.
              &quot; Une erreur est survenue
              &quot;&quot;  --&gt; Réinitialisation données
              CLEAR : lv_data_decompress.

            ENDIF.

          WHEN &lt;lfs_s_repid_parameters&gt;-value_is_compressed_global.
            &quot; Compression globale
            &quot;&quot;  --&gt; Décompression des données
            lo_abap_zip-&gt;get(
              EXPORTING
                name                    = CONV string( &lt;lfs_s_repid_parameters&gt;-parameter_name )
              IMPORTING
                content                 = lv_data_decompress
              EXCEPTIONS
                zip_index_error         = 1
                zip_decompression_error = 2
                OTHERS                  = 3
            ).
            IF sy-subrc NE 0.
              &quot; Une erreur est survenue
              &quot;&quot;  --&gt; Réinitialisation données
              CLEAR : lv_data_decompress.

            ENDIF.

          WHEN OTHERS.
            &quot; Autres
            &quot;&quot;  --&gt; Pas de décompression // Rien à faire
            lv_data_decompress = &lt;lfs_s_repid_parameters&gt;-value_data_xml.

        ENDCASE.

        IF NOT lv_data_decompress IS INITIAL.
          &quot;&quot; --&gt; Restructuration des données
          CALL TRANSFORMATION id
                   SOURCE XML lv_data_decompress
                       RESULT data = &lt;lfs_value_data&gt;.

        ENDIF.

        TRY.
            &quot; Move-Cast en Table
            ASSIGN &lt;lfs_value_data&gt; TO &lt;lfs_t_value_data&gt;.
            IF sy-subrc NE 0.
              CONTINUE.

            ENDIF.

          CATCH cx_root.
            &quot; Erreur Move-Cast
            &quot;&quot;  --&gt; Passe à l&apos;itération suivante
            CONTINUE.

        ENDTRY.

        &quot;&quot;  --&gt; Initialisation table paramètre d&apos;appel dynamique
        ls_parameters-kind    = &lt;lfs_s_repid_parameters&gt;-parameter_kind.
        ls_parameters-selname = &lt;lfs_s_repid_parameters&gt;-parameter_name.     &quot;Nom du paramètre

        LOOP AT &lt;lfs_t_value_data&gt; ASSIGNING &lt;lfs_value_data&gt;.

          &quot; Initialisation des valeurs de Range
          MOVE-CORRESPONDING &lt;lfs_value_data&gt; TO ls_parameters.

          &quot; Ajout de l&apos;entrée
          INSERT ls_parameters INTO TABLE et_parameters.

        ENDLOOP.

      ELSEIF NOT &lt;lfs_s_repid_parameters&gt;-value_data IS INITIAL.
        &quot; Type Elémentaire
        &quot;&quot;  --&gt; Initialisation table paramètre d&apos;appel dynamique
        ls_parameters-kind    = &lt;lfs_s_repid_parameters&gt;-parameter_kind.
        ls_parameters-selname = &lt;lfs_s_repid_parameters&gt;-parameter_name.     &quot;Nom du paramètre
        ls_parameters-sign    = &apos;I&apos;.                        &quot;#EC NOTEXT
        ls_parameters-option  = &apos;EQ&apos;.                       &quot;#EC NOTEXT
        ls_parameters-low     = &lt;lfs_s_repid_parameters&gt;-value_data.
        INSERT ls_parameters INTO TABLE et_parameters.                          &quot;Ajout du paramètre dynamique

      ELSE.                                                 &quot;#EC NEEDED
        &quot; Autre cas
        &quot;&quot;  --&gt; ToDo : Ajouter ici les autres cas

      ENDIF.

    ENDLOOP.

  ENDIF.

ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  REPID_RESULT_SET
*&amp;---------------------------------------------------------------------*
*       Initialisation table de retour
*----------------------------------------------------------------------*
*      --&gt; IV_JOBNAME                       Job - Nom
*      --&gt; IV_JOBCOUNT                      Job - Compteur
*      --&gt; IS_TASK_DATA_COMPRESS_PARAM      Paramètre de Compression
*      &lt;-- ET_TASK_RESULT                   Table de Résultat
*      &lt;-- EV_TASK_RESULT_DATA_COMPRESSED   Données compressées
*----------------------------------------------------------------------*
FORM repid_result_set USING iv_jobname                     TYPE tbtcjob-jobname
                            iv_jobcount                    TYPE tbtcjob-jobcount
                            is_task_data_compress_param    TYPE ztec_s_task_compress_param
                   CHANGING et_task_result                 TYPE ztec_t_function_parameters
                            ev_task_result_data_compressed TYPE xstring.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_result TYPE ztec_s_function_parameters.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_abap_zip TYPE REF TO cl_abap_zip.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_value&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE  : et_task_result.
  CLEAR : ev_task_result_data_compressed.

  &quot; -----------------------------------------------------------
  &quot; Pré-Traitement
  &quot; -----------------------------------------------------------

  IF NOT is_task_data_compress_param IS INITIAL.
    &quot; Activation de la Compression globale ou Ligne par Ligne
    &quot;&quot;  --&gt; Création instance de Compression
    CREATE OBJECT lo_abap_zip.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Alimentation table de retour
  &quot; -----------------------------------------------------------

  &quot; Initialisation données du paramètre
  ls_result-parameter_name = zif_task_constant=&gt;mc_parameter_name_job.
  ls_result-value_type     = cl_abap_typedescr=&gt;describe_by_data( zif_task_constant=&gt;mc_parameter_name_job )-&gt;absolute_name.
  ls_result-value_data     = |{ iv_jobname }/{ iv_jobcount }|.  &quot;#EC NOTEXT

  &quot; Ajout dans la table de sortie
  APPEND ls_result TO et_task_result.

  &quot; -----------------------------------------------------------
  &quot; Post-Traitement
  &quot; -----------------------------------------------------------

  IF is_task_data_compress_param-data_compress_global EQ abap_true.
    &quot; Donneés compressées au global
    &quot;&quot;  --&gt; Réstitution du dossier de compression
    ev_task_result_data_compressed = lo_abap_zip-&gt;save( ).

  ENDIF.

ENDFORM.</include_source>
   </include>
   <include NAME="LZTEC_TASK_PARALLELTOP" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RMAND="100" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
    <include_source>FUNCTION-POOL ztec_task_parallel.           &quot;MESSAGE-ID ..


***------------------------------------------------------------------***
**                              MACCRO                                **
***------------------------------------------------------------------***


***------------------------------------------------------------------***
**                             CLASSES                                **
***------------------------------------------------------------------***


***------------------------------------------------------------------***
**                              TYPES                                 **
***------------------------------------------------------------------***

&quot; Déclaration de type pour stockage contenu de table
TYPES :
  BEGIN OF ts_table_data,
    name  TYPE        typename,
    value TYPE REF TO data,
  END OF   ts_table_data.

TYPES : tt_table_data TYPE SORTED TABLE OF ts_table_data
                             WITH UNIQUE KEY primary_key COMPONENTS name.


&quot; Déclaration de type pour stockage définition champ
TYPES:
  BEGIN OF ts_data_type_descr,
    component  TYPE        string,
    data_descr TYPE REF TO cl_abap_datadescr,
  END OF   ts_data_type_descr .
TYPES:
  tt_data_type_descr TYPE SORTED TABLE OF ts_data_type_descr
                                      WITH UNIQUE KEY primary_key COMPONENTS component.

TYPES : tt_exceptions_class TYPE SORTED TABLE OF seosubco-sconame
        WITH UNIQUE KEY primary_key COMPONENTS table_line.

&quot; Déclaration de type pour stockage paramètre d&apos;Exception
TYPES :
  BEGIN OF ts_fupararef_exception,
    funcname  TYPE fupararef-funcname,
    parameter TYPE fupararef-parameter,
    pposition TYPE fupararef-pposition,
    not_found TYPE xsdboolean,
  END OF   ts_fupararef_exception.

TYPES : tt_fupararef_exception TYPE SORTED TABLE OF ts_fupararef_exception
                                      WITH UNIQUE KEY primary_key COMPONENTS funcname parameter.

TYPES :
  BEGIN OF ts_seosubco_exception,
    clsname   TYPE seosubco-clsname,
    cmpname   TYPE seosubco-cmpname,
    sconame   TYPE seosubco-sconame,
    mtdnewexc TYPE seocompodf-mtdnewexc,
    not_found TYPE xsdboolean,
  END OF   ts_seosubco_exception.

TYPES : tt_seosubco_exception TYPE SORTED TABLE OF ts_seosubco_exception
        WITH UNIQUE KEY primary_key COMPONENTS clsname cmpname sconame.

TYPES :
  BEGIN OF ts_persistent_data,
    t_seosubco_exception     TYPE tt_seosubco_exception,
    t_fupararef_exception    TYPE tt_fupararef_exception,
  END OF   ts_persistent_data.

***------------------------------------------------------------------***
**                           CONSTANTES                               **
***------------------------------------------------------------------***
CONSTANTS :
  gc_table_line TYPE string VALUE &apos;TABLE_LINE&apos;.

***------------------------------------------------------------------***
**                             RANGES                                 **
***------------------------------------------------------------------***


***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***


***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
DATA :
      gs_persistent_data TYPE ts_persistent_data.           &quot;#EC NEEDED

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***


***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***


***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
* INCLUDE LZTEC_TASK_PARALLELD...            &quot; Local class definition</include_source>
   </include>
  </includeprograms>
  <functionmodules>
   <functionmodule NAME="Z_CONVERT_TABLE_DYN_TO_STATIC" STEXT="Conversion table dynamique en statique">
    <importing PARAMETER="IT_DATA" OPTIONAL="X" REFERENCE="X" TYP="ANY TABLE"/>
    <importing PARAMETER="IOT_DATA" OPTIONAL="X" REFERENCE="X" TYP="REF TO DATA" REF_CLASS="X"/>
    <importing PARAMETER="IV_SUB_DATA_GUID" OPTIONAL="X" TYP="SYSUUID_C32"/>
    <exporting PARAMETER="ET_CONTENT_STATIC" REFERENCE="X" TYP="ZTEC_T_CONTENT_DATA"/>
    <exporting PARAMETER="ET_CONTENT_RAW" REFERENCE="X" TYP="SRM_T_BINTAB"/>
    <exporting PARAMETER="ET_CONTENT_XSTRING" REFERENCE="X" TYP="XSTRINGTAB"/>
    <documentation PARAMETER="IT_DATA" KIND="P" STEXT="Table de donnÃ©es" INDEX=" 001"/>
    <documentation PARAMETER="IOT_DATA" KIND="P" STEXT="Table de donnÃ©es (RÃ©fÃ©rence)" INDEX=" 002"/>
    <documentation PARAMETER="IV_SUB_DATA_GUID" KIND="P" STEXT="GUID Sous-Ã‰lÃ©ment" INDEX=" 003"/>
    <documentation PARAMETER="ET_CONTENT_STATIC" KIND="P" STEXT="Type de table contenu de table" INDEX=" 004"/>
    <documentation PARAMETER="ET_CONTENT_RAW" KIND="P" STEXT="Table binaire" INDEX=" 005"/>
    <documentation PARAMETER="ET_CONTENT_XSTRING" KIND="P" STEXT="Table with XStrings" INDEX=" 006"/>
    <fm_source_new>***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_content_static  TYPE ztec_t_content_data,
    lt_data_type_descr TYPE tt_data_type_descr.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_content_data    TYPE ztec_s_content_data,
    ls_data_type_descr TYPE ts_data_type_descr.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_elem_descr   TYPE REF TO cl_abap_elemdescr,
    lo_table_descr  TYPE REF TO cl_abap_tabledescr,
    lo_struct_descr TYPE REF TO cl_abap_structdescr.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_t_table&gt; TYPE ANY TABLE.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : et_content_xstring, et_content_static, et_content_raw.

  IF iot_data IS BOUND.
    &quot; Initialisation &quot;pointeur&quot; sur les données
    ASSIGN iot_data-&gt;* TO &lt;lfs_t_table&gt;.

  ELSEIF it_data IS SUPPLIED.
    &quot; Utilisation table passée en paramètre
    ASSIGN it_data TO &lt;lfs_t_table&gt;.

  ELSE.
    &quot; Aucun paramètre
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.
  IF NOT &lt;lfs_t_table&gt; IS ASSIGNED.
    &quot; Erreur lors de l&apos;initialisation du pointeur
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; Récupération composition de la table
  lo_table_descr ?= cl_abap_tabledescr=&gt;describe_by_data( &lt;lfs_t_table&gt; ).
  TRY.
      &quot; Récupération composition de la table
      lo_struct_descr ?= lo_table_descr-&gt;get_table_line_type( ).

    CATCH cx_sy_move_cast_error.
      &quot; Erreur move-cast // Il s&apos;agit peut-être d&apos;une table de type élémentaire
      TRY.
          lo_elem_descr ?= lo_table_descr-&gt;get_table_line_type( ).

        CATCH cx_root. &quot;#EC CATCH_ALL
          &quot; Erreur
          &quot;&quot;  --&gt; Arrêt du traitement
          RETURN.

      ENDTRY.

    CATCH cx_root. &quot;#EC CATCH_ALL
      &quot; Erreur
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

  ENDTRY.

  &quot; Parcours l&apos;ensemble des données
  LOOP AT &lt;lfs_t_table&gt; ASSIGNING FIELD-SYMBOL(&lt;lfs_s_table&gt;).

    CLEAR : ls_content_data.
    FREE : lt_content_static.

    &quot; Initialisation numéro de ligne
    ls_content_data-line = sy-tabix.

    IF iv_sub_data_guid IS SUPPLIED.
      &quot; Initialisation GUID de Sous-élément
      ls_content_data-sub_data_guid = iv_sub_data_guid.

    ENDIF.

    IF lo_elem_descr IS BOUND.
      &quot; Cas d&apos;un type de table élémentaire
      ls_content_data-fieldname = gc_table_line.
      ls_content_data-fieldtype = lo_elem_descr-&gt;absolute_name.
      ls_content_data-fieldkind = lo_elem_descr-&gt;kind.
      ls_content_data-value     = &lt;lfs_s_table&gt;.

      IF et_content_static IS SUPPLIED.
        &quot; Ajout dans la table &quot;Statique&quot; classique
        INSERT ls_content_data INTO TABLE et_content_static.

      ENDIF.

    ELSEIF lo_struct_descr IS BOUND.

      &quot; Parcours l&apos;ensemble des champs de la structure
      LOOP AT lo_struct_descr-&gt;components ASSIGNING FIELD-SYMBOL(&lt;lfs_s_components&gt;).

        &quot; Récupération du champ correspondant
        ASSIGN COMPONENT &lt;lfs_s_components&gt;-name OF STRUCTURE &lt;lfs_s_table&gt;
                                                           TO FIELD-SYMBOL(&lt;lfs_s_source&gt;).
        IF sy-subrc NE 0.
          &quot; Pas de correspondance // Ne devrais pas se produire
          &quot;&quot;  --&gt; Passe à l&apos;itération suivante
          CONTINUE.

        ENDIF.

        &quot; Initialisation Nom du champ
        ls_content_data-fieldname = &lt;lfs_s_components&gt;-name.

        &quot; Récupération de la composition du champ
        READ TABLE lt_data_type_descr WITH TABLE KEY component = &lt;lfs_s_components&gt;-name
                                           ASSIGNING FIELD-SYMBOL(&lt;lfs_s_data_type_descr&gt;).
        IF sy-subrc NE 0.
          &quot; Pas encore récupérée
          &quot;&quot;  --&gt; Création novelle entrée
          ls_data_type_descr-component   = &lt;lfs_s_components&gt;-name.
          ls_data_type_descr-data_descr ?= cl_abap_datadescr=&gt;describe_by_data( &lt;lfs_s_source&gt; ).
          INSERT ls_data_type_descr INTO TABLE lt_data_type_descr ASSIGNING &lt;lfs_s_data_type_descr&gt;.

        ENDIF.

        &quot; Initialisation Type (DDIC) du champ
        ls_content_data-fieldtype = &lt;lfs_s_data_type_descr&gt;-data_descr-&gt;absolute_name.

        &quot; Initialisation Type (ABAP) de champ
        ls_content_data-fieldkind = &lt;lfs_s_data_type_descr&gt;-data_descr-&gt;kind.

        &quot; Suivant le type de champ
        CASE &lt;lfs_s_data_type_descr&gt;-data_descr-&gt;kind.

          WHEN cl_abap_typedescr=&gt;kind_ref.
            &quot; Instance
            &quot;&quot;  --&gt; ToDo : Ajouter traitement

          WHEN cl_abap_typedescr=&gt;kind_class
            OR cl_abap_typedescr=&gt;kind_intf.
            &quot; Classe
            &quot;&quot;  --&gt; ToDo : Ajouter traitement

          WHEN cl_abap_typedescr=&gt;kind_table.
            &quot; Table
            TRY.
                &quot;&quot;  --&gt; Génération ID Unique
                ls_content_data-value = cl_system_uuid=&gt;create_uuid_c32_static( ).

              CATCH cx_uuid_error.
                &quot;&quot; --&gt; Génération nombre aléatoire
                ls_content_data-value = CONV sysuuid_c32( cl_abap_random=&gt;seed( ) ).

            ENDTRY.

            &quot;&quot;  --&gt; Appel récursif pour type &quot;complexe&quot;
            CALL FUNCTION &apos;Z_CONVERT_TABLE_DYN_TO_STATIC&apos;
              EXPORTING
                it_data           = &lt;lfs_s_source&gt;
                iv_sub_data_guid  = CONV sysuuid_c32( ls_content_data-value )
              IMPORTING
                et_content_static = lt_content_static.
            INSERT LINES OF lt_content_static INTO TABLE et_content_static.

          WHEN cl_abap_typedescr=&gt;kind_elem.
            &quot; Type élémentaire
            &quot;&quot;  --&gt; Initialisation de la valeur
            ls_content_data-value = &lt;lfs_s_source&gt;.

          WHEN cl_abap_typedescr=&gt;kind_struct.
            &quot; Structure
            TRY.
                &quot;&quot;  --&gt; Génération ID Unique
                ls_content_data-value = cl_system_uuid=&gt;create_uuid_c32_static( ).

              CATCH cx_uuid_error.
                &quot;&quot; --&gt; Génération nombre aléatoire
                ls_content_data-value = CONV sysuuid_c32( cl_abap_random=&gt;seed( ) ).

            ENDTRY.

            &quot;&quot;  --&gt; Appel récursif pour type &quot;complexe&quot;
            CALL FUNCTION &apos;Z_CONVERT_STRUCT_DYN_TO_STATIC&apos;
              EXPORTING
                is_data           = &lt;lfs_s_source&gt;
                iv_sub_data_guid  = CONV sysuuid_c32( ls_content_data-value )
              IMPORTING
                et_content_static = lt_content_static.
            INSERT LINES OF lt_content_static INTO TABLE et_content_static.

          WHEN OTHERS.
            &quot; Autre
            &quot;&quot;  --&gt; ToDo : Traiter les autres cas
            CONTINUE.

        ENDCASE.

        IF et_content_static IS SUPPLIED.
          &quot; Ajout dans la table &quot;Statique&quot; classique
          INSERT ls_content_data INTO TABLE et_content_static.

        ENDIF.

      ENDLOOP.        &quot;Fin parcours des champs de la table

    ENDIF.            &quot;Fin de test du type de table

  ENDLOOP.            &quot;Fin de parcours des données</fm_source_new>
    <functionModuleDocumentation/>
   </functionmodule>
   <functionmodule NAME="Z_CONVERT_TABLE_STATIC_TO_DYN" STEXT="Conversion table statique en dynamique">
    <importing PARAMETER="IV_TYPE" OPTIONAL="X" TYP="CLIKE"/>
    <importing PARAMETER="IV_SUB_DATA_GUID" OPTIONAL="X" TYP="SYSUUID_C32"/>
    <importing PARAMETER="IT_CONTENT_STATIC" OPTIONAL="X" REFERENCE="X" TYP="ZTEC_T_CONTENT_DATA"/>
    <importing PARAMETER="IT_CONTENT_RAW" OPTIONAL="X" REFERENCE="X" TYP="SRM_T_BINTAB"/>
    <importing PARAMETER="IT_CONTENT_XSTRING" OPTIONAL="X" REFERENCE="X" TYP="XSTRINGTAB"/>
    <exporting PARAMETER="ET_DATA" REFERENCE="X" TYP="ANY TABLE"/>
    <exporting PARAMETER="EOT_DATA" REFERENCE="X" TYP="REF TO DATA" REF_CLASS="X"/>
    <changing PARAMETER="CT_DATA" OPTIONAL="X" REFERENCE="X" TYP="ANY TABLE"/>
    <changing PARAMETER="COT_DATA" OPTIONAL="X" REFERENCE="X" TYP="REF TO DATA" REF_CLASS="X"/>
    <documentation PARAMETER="IV_TYPE" KIND="P" STEXT="Type de table" INDEX=" 001"/>
    <documentation PARAMETER="IV_SUB_DATA_GUID" KIND="P" STEXT="GUID Sous-Ã‰lÃ©ment" INDEX=" 002"/>
    <documentation PARAMETER="IT_CONTENT_STATIC" KIND="P" STEXT="Type de table contenu de table" INDEX=" 003"/>
    <documentation PARAMETER="IT_CONTENT_RAW" KIND="P" STEXT="Table binaire" INDEX=" 004"/>
    <documentation PARAMETER="IT_CONTENT_XSTRING" KIND="P" STEXT="Table with XStrings" INDEX=" 005"/>
    <documentation PARAMETER="ET_DATA" KIND="P" INDEX=" 006"/>
    <documentation PARAMETER="EOT_DATA" KIND="P" STEXT="Table dynamique" INDEX=" 007"/>
    <documentation PARAMETER="CT_DATA" KIND="P" INDEX=" 008"/>
    <documentation PARAMETER="COT_DATA" KIND="P" INDEX=" 009"/>
    <fm_source_new>***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lot_data       TYPE REF TO data,
    los_data       TYPE REF TO data,
    lo_table_descr TYPE REF TO cl_abap_tabledescr.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_tabix TYPE sy-tabix.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_s_data&gt;           TYPE            any,
    &lt;lfs_t_data&gt;           TYPE ANY TABLE,
    &lt;lfs_sub_data&gt;         TYPE            any,
    &lt;lfs_s_content_static&gt; TYPE            ztec_s_content_data.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : eot_data, et_data.

  &quot; -----------------------------------------------------------
  &quot; Contrôle paramètre d&apos;Import
  &quot; -----------------------------------------------------------

  IF  it_content_raw     IS SUPPLIED
  AND it_content_static  IS SUPPLIED
  AND it_content_xstring IS SUPPLIED.
    &quot; Un seul paramètre doit être renseigné
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Création et Alimentation de la table de sortie
  &quot; -----------------------------------------------------------

  IF eot_data IS SUPPLIED.
    &quot; Gestion par référence
    &quot;&quot;  --&gt; Rcupération composition de la table
    lo_table_descr ?= cl_abap_typedescr=&gt;describe_by_name( iv_type ).

    &quot;&quot;  --&gt; Création de la table
    CREATE DATA eot_data TYPE (lo_table_descr-&gt;absolute_name).

    &quot;&quot;  --&gt; Initialisation pointeur sur les données de la table
    ASSIGN eot_data-&gt;* TO &lt;lfs_t_data&gt;.

  ELSEIF et_data IS SUPPLIED.
    &quot; Gestion par table de données
    &quot;&quot;  --&gt; Initialisation pointeur sur les données de la table
    ASSIGN et_data TO &lt;lfs_t_data&gt;.

    &quot;&quot;  --&gt; Rcupération composition de la table
    lo_table_descr ?= cl_abap_typedescr=&gt;describe_by_data( &lt;lfs_t_data&gt; ).

  ELSEIF cot_data IS SUPPLIED.
    &quot; Gestion par référence déjà créé
    &quot;&quot;  --&gt; Initialisation pointeur sur les données de la table
    ASSIGN cot_data-&gt;* TO &lt;lfs_t_data&gt;.

    &quot;&quot;  --&gt; Rcupération composition de la table
    lo_table_descr ?= cl_abap_typedescr=&gt;describe_by_data( &lt;lfs_t_data&gt; ).

  ELSEIF ct_data IS SUPPLIED.
    &quot; Gestion par table de données
    &quot;&quot;  --&gt; Initialisation pointeur sur les données de la table
    ASSIGN ct_data TO &lt;lfs_t_data&gt;.

    &quot;&quot;  --&gt; Rcupération composition de la table
    lo_table_descr ?= cl_abap_typedescr=&gt;describe_by_data( &lt;lfs_t_data&gt; ).

  ENDIF.

  IF it_content_static IS SUPPLIED.
    &quot; Utilisation table statique
    IF NOT iv_sub_data_guid IS INITIAL.
      &quot; GUID de Sous-Elément valorisé
      &quot;&quot;  --&gt; Récupération position première occurence
      READ TABLE it_content_static WITH KEY sub_data_guid = iv_sub_data_guid
                               TRANSPORTING NO FIELDS BINARY SEARCH.
      IF sy-subrc EQ 0.
        &quot; Première position déterminée
        &quot;&quot;  --&gt; Initialisation Index
        lv_tabix = sy-tabix.

      ELSE.
        &quot; Aucune correspondance
        &quot;&quot;  --&gt; Arrêt du traitement
        RETURN.

      ENDIF.

    ELSE.
      &quot; Il ne s&apos;agit pas d&apos;un Sous-Elément
      &quot;&quot; --&gt; Initialisation Index première entrée
      lv_tabix = 1.

    ENDIF.

    LOOP AT it_content_static ASSIGNING &lt;lfs_s_content_static&gt;
                                   FROM lv_tabix.

      IF &lt;lfs_s_content_static&gt;-sub_data_guid NE iv_sub_data_guid.
        &quot; On ne traite pas le bon sous-élement
        &quot;&quot;  --&gt; Passe à l&apos;itération suivante
        EXIT.

      ENDIF.

      AT NEW line.
        &quot; A chaque changement de ligne
        IF &lt;lfs_s_data&gt; IS ASSIGNED AND NOT &lt;lfs_s_data&gt; IS INITIAL.
          &quot;&quot;  --&gt; Ajout de la l&apos;entrée
          INSERT &lt;lfs_s_data&gt; INTO TABLE &lt;lfs_t_data&gt;.

        ENDIF.

        &quot;&quot;  --&gt; Réinitialisation des données
        CREATE DATA los_data TYPE LINE OF (lo_table_descr-&gt;absolute_name).
        ASSIGN los_data-&gt;* TO &lt;lfs_s_data&gt;.

      ENDAT.

      &quot; Initialisation pointeur sur champ de la structure
      IF &lt;lfs_s_content_static&gt;-fieldname EQ gc_table_line.
        &quot; Cas d&apos;une table de type élémentaire
        &lt;lfs_s_data&gt; = &lt;lfs_s_content_static&gt;-value.

      ELSE.
        &quot; Cas d&apos;une structure &quot;complexe&quot;
        ASSIGN COMPONENT &lt;lfs_s_content_static&gt;-fieldname OF STRUCTURE &lt;lfs_s_data&gt;
                                                                    TO FIELD-SYMBOL(&lt;lfs_value_target&gt;).
        IF sy-subrc NE 0.
          &quot; Pas de correspondance // Ce cas ne devrais pas se produire
          &quot;&quot;  --&gt; Passe à l&apos;itération suivante
          CONTINUE.

        ENDIF.

        &quot; Suivant le type de champ
        CASE &lt;lfs_s_content_static&gt;-fieldkind.

          WHEN cl_abap_typedescr=&gt;kind_ref.
            &quot; Instance
            &quot;&quot;  --&gt; ToDo : Ajouter traitement

          WHEN cl_abap_typedescr=&gt;kind_class
            OR cl_abap_typedescr=&gt;kind_intf.
            &quot; Classe
            &quot;&quot;  --&gt; ToDo : Ajouter traitement

          WHEN cl_abap_typedescr=&gt;kind_table.
            &quot; Table
            &quot;&quot;  --&gt; Appel récursif pour type &quot;complexe&quot;
            CALL FUNCTION &apos;Z_CONVERT_TABLE_STATIC_TO_DYN&apos;
              EXPORTING
                iv_type           = &lt;lfs_s_content_static&gt;-fieldtype
                iv_sub_data_guid  = CONV sysuuid_c32( &lt;lfs_s_content_static&gt;-value )
                it_content_static = it_content_static
              IMPORTING
                eot_data          = lot_data.

            &quot;&quot;  --&gt; Alimentation de la zone
            ASSIGN lot_data-&gt;* TO &lt;lfs_sub_data&gt;.
            &lt;lfs_value_target&gt; = &lt;lfs_sub_data&gt;.

          WHEN cl_abap_typedescr=&gt;kind_elem.
            &quot; Type élémentaire
            &quot;&quot;  --&gt; Initialisation de la valeur
            &lt;lfs_value_target&gt; = &lt;lfs_s_content_static&gt;-value.

          WHEN cl_abap_typedescr=&gt;kind_struct.
            &quot; Structure
            &quot;&quot;  --&gt; Appel récursif pour type &quot;complexe&quot;
            CALL FUNCTION &apos;Z_CONVERT_STRUCT_STATIC_TO_DYN&apos;
              EXPORTING
                iv_type           = &lt;lfs_s_content_static&gt;-fieldtype
                iv_sub_data_guid  = CONV sysuuid_c32( &lt;lfs_s_content_static&gt;-value )
                it_content_static = it_content_static
              IMPORTING
                eos_data          = los_data.

            &quot;&quot;  --&gt; Alimentation de la zone
            ASSIGN los_data-&gt;* TO &lt;lfs_sub_data&gt;.
            &lt;lfs_value_target&gt; = &lt;lfs_sub_data&gt;.

          WHEN OTHERS.
            &quot; Autre
            &quot;&quot;  --&gt; ToDo : Traiter les autres cas
            CONTINUE.

        ENDCASE.

      ENDIF.

    ENDLOOP.

    IF &lt;lfs_s_data&gt; IS ASSIGNED AND NOT &lt;lfs_s_data&gt; IS INITIAL.
      &quot;&quot;  --&gt; Ajout de la l&apos;entrée
      INSERT &lt;lfs_s_data&gt; INTO TABLE &lt;lfs_t_data&gt;.

    ENDIF.

  ENDIF.</fm_source_new>
    <functionModuleDocumentation/>
   </functionmodule>
   <functionmodule NAME="Z_CONVERT_STRUCT_DYN_TO_STATIC" STEXT="Conversion structure dynamique en statique">
    <importing PARAMETER="IS_DATA" OPTIONAL="X" REFERENCE="X" TYP="ANY"/>
    <importing PARAMETER="IOS_DATA" OPTIONAL="X" REFERENCE="X" TYP="REF TO DATA" REF_CLASS="X"/>
    <importing PARAMETER="IV_SUB_DATA_GUID" OPTIONAL="X" REFERENCE="X" TYP="SYSUUID_C32"/>
    <exporting PARAMETER="ET_CONTENT_STATIC" REFERENCE="X" TYP="ZTEC_T_CONTENT_DATA"/>
    <documentation PARAMETER="IS_DATA" KIND="P" STEXT="Structure de donnÃ©es" INDEX=" 001"/>
    <documentation PARAMETER="IOS_DATA" KIND="P" STEXT="Structure de donnÃ©es (RÃ©fÃ©rence)" INDEX=" 002"/>
    <documentation PARAMETER="IV_SUB_DATA_GUID" KIND="P" STEXT="16 Byte UUID in 16 Bytes (Raw Format)" INDEX=" 003"/>
    <documentation PARAMETER="ET_CONTENT_STATIC" KIND="P" STEXT="Type de table contenu de table" INDEX=" 004"/>
    <fm_source_new>***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_content_static  TYPE ztec_t_content_data,
    lt_data_type_descr TYPE tt_data_type_descr.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
    ls_content_data    TYPE ztec_s_content_data,
    ls_data_type_descr TYPE ts_data_type_descr.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_elem_descr   TYPE REF TO cl_abap_elemdescr,
    lo_struct_descr TYPE REF TO cl_abap_structdescr.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_s_structure&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : et_content_static.

  &quot; -----------------------------------------------------------
  &quot; Récupération composante de la Structure
  &quot; -----------------------------------------------------------

  IF ios_data IS BOUND.
    &quot; Initialisation &quot;pointeur&quot; sur les données
    ASSIGN ios_data-&gt;* TO &lt;lfs_s_structure&gt;.

  ELSEIF is_data IS SUPPLIED.
    &quot; Utilisation structure passée en paramètre
    ASSIGN is_data TO &lt;lfs_s_structure&gt;.

  ELSE.
    &quot; Aucun paramètre
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.
  IF NOT &lt;lfs_s_structure&gt; Is ASSIGNED.
    &quot; Erreur lors de l&apos;initialisation du pointeur
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  TRY.
      &quot; Récupération composition de la structure
      lo_struct_descr ?= cl_abap_structdescr=&gt;describe_by_data( &lt;lfs_s_structure&gt; ).

    CATCH cx_sy_move_cast_error.
      &quot; Erreur move-cast // Il s&apos;agit peut-être d&apos;une table de type élémentaire
      TRY.
          lo_elem_descr ?= cl_abap_structdescr=&gt;describe_by_data( &lt;lfs_s_structure&gt; ).

        CATCH cx_root. &quot;#EC CATCH_ALL
          &quot; Erreur
          &quot;&quot;  --&gt; Arrêt du traitement
          RETURN.

      ENDTRY.

    CATCH cx_root. &quot;#EC CATCH_ALL
      &quot; Erreur
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

  ENDTRY.

  &quot; -----------------------------------------------------------
  &quot; Initialisation table de données statique
  &quot; -----------------------------------------------------------

  IF lo_elem_descr IS BOUND.
    &quot; Cas d&apos;un type de table élémentaire
    ls_content_data-fieldname = gc_table_line.
    ls_content_data-fieldtype = lo_elem_descr-&gt;absolute_name.
    ls_content_data-fieldkind = lo_elem_descr-&gt;kind.
    ls_content_data-value     = &lt;lfs_s_structure&gt;.

    IF et_content_static IS SUPPLIED.
      &quot; Ajout dans la table &quot;Statique&quot; classique
      INSERT ls_content_data INTO TABLE et_content_static.

    ENDIF.

  ELSEIF lo_struct_descr IS BOUND.

    &quot; Parcours l&apos;ensemble des champs de la structure
    LOOP AT lo_struct_descr-&gt;components ASSIGNING FIELD-SYMBOL(&lt;lfs_s_components&gt;).

      FREE : lt_content_static.

      &quot; Récupération du champ correspondant
      ASSIGN COMPONENT &lt;lfs_s_components&gt;-name OF STRUCTURE &lt;lfs_s_structure&gt;
                                                         TO FIELD-SYMBOL(&lt;lfs_s_source&gt;).
      IF sy-subrc NE 0.
        &quot; Pas de correspondance // Ne devrais pas se produire
        &quot;&quot;  --&gt; Passe à l&apos;itération suivante
        CONTINUE.

      ENDIF.

      &quot; Initialisation Nom du champ
      ls_content_data-fieldname = &lt;lfs_s_components&gt;-name.

      &quot; Récupération de la composition du champ
      READ TABLE lt_data_type_descr WITH TABLE KEY component = &lt;lfs_s_components&gt;-name
                                         ASSIGNING FIELD-SYMBOL(&lt;lfs_s_data_type_descr&gt;).
      IF sy-subrc NE 0.
        &quot; Pas encore récupérée
        &quot;&quot;  --&gt; Création novelle entrée
        ls_data_type_descr-component   = &lt;lfs_s_components&gt;-name.
        ls_data_type_descr-data_descr ?= cl_abap_datadescr=&gt;describe_by_data( &lt;lfs_s_source&gt; ).
        INSERT ls_data_type_descr INTO TABLE lt_data_type_descr ASSIGNING &lt;lfs_s_data_type_descr&gt;.

      ENDIF.

      &quot; Initialisation Type (DDIC) du champ
      ls_content_data-fieldtype = &lt;lfs_s_data_type_descr&gt;-data_descr-&gt;absolute_name.

      &quot; Initialisation Type (ABAP) de champ
      ls_content_data-fieldkind = &lt;lfs_s_data_type_descr&gt;-data_descr-&gt;kind.

      &quot; Suivant le type de champ
      CASE &lt;lfs_s_data_type_descr&gt;-data_descr-&gt;kind.

        WHEN cl_abap_typedescr=&gt;kind_ref.
          &quot; Instance
          &quot;&quot;  --&gt; ToDo : Ajouter traitement

        WHEN cl_abap_typedescr=&gt;kind_class
          OR cl_abap_typedescr=&gt;kind_intf.
          &quot; Classe
          &quot;&quot;  --&gt; ToDo : Ajouter traitement

        WHEN cl_abap_typedescr=&gt;kind_table.
          &quot; Table
          TRY.
              &quot;&quot;  --&gt; Génération ID Unique
              ls_content_data-value = cl_system_uuid=&gt;create_uuid_c32_static( ).

            CATCH cx_uuid_error.
              &quot;&quot; --&gt; Génération nombre aléatoire
              ls_content_data-value = CONV sysuuid_c32( cl_abap_random=&gt;seed( ) ).

          ENDTRY.

          &quot;&quot;  --&gt; Appel récursif pour type &quot;complexe&quot;
          CALL FUNCTION &apos;Z_CONVERT_TABLE_DYN_TO_STATIC&apos;
            EXPORTING
              it_data           = &lt;lfs_s_source&gt;
              iv_sub_data_guid  = CONV sysuuid_c32( ls_content_data-value )
            IMPORTING
              et_content_static = lt_content_static.
          INSERT LINES OF lt_content_static INTO TABLE et_content_static.

        WHEN cl_abap_typedescr=&gt;kind_elem.
          &quot; Type élémentaire
          &quot;&quot;  --&gt; Initialisation de la valeur
          ls_content_data-value = &lt;lfs_s_source&gt;.

        WHEN cl_abap_typedescr=&gt;kind_struct.
          &quot; Structure
          TRY.
              &quot;&quot;  --&gt; Génération ID Unique
              ls_content_data-value = cl_system_uuid=&gt;create_uuid_c32_static( ).

            CATCH cx_uuid_error.
              &quot;&quot; --&gt; Génération nombre aléatoire
              ls_content_data-value = CONV sysuuid_c32( cl_abap_random=&gt;seed( ) ).

          ENDTRY.

          &quot;&quot;  --&gt; Appel récursif pour type &quot;complexe&quot;
          CALL FUNCTION &apos;Z_CONVERT_STRUCT_DYN_TO_STATIC&apos;
            EXPORTING
              is_data           = &lt;lfs_s_source&gt;
              iv_sub_data_guid  = CONV sysuuid_c32( ls_content_data-value )
            IMPORTING
              et_content_static = lt_content_static.
          INSERT LINES OF lt_content_static INTO TABLE et_content_static.

        WHEN OTHERS.
          &quot; Autre
          &quot;&quot;  --&gt; ToDo : Traiter les autres cas
          CONTINUE.

      ENDCASE.

      IF et_content_static IS SUPPLIED.
        &quot; Ajout dans la table &quot;Statique&quot; classique
        INSERT ls_content_data INTO TABLE et_content_static.

      ENDIF.

    ENDLOOP.        &quot;Fin parcours des champs de la table

  ENDIF.            &quot;Fin de test du type de table</fm_source_new>
    <functionModuleDocumentation/>
   </functionmodule>
   <functionmodule NAME="Z_CONVERT_STRUCT_STATIC_TO_DYN" STEXT="Conversion table statique en dynamique">
    <importing PARAMETER="IV_TYPE" TYP="CLIKE"/>
    <importing PARAMETER="IV_SUB_DATA_GUID" OPTIONAL="X" TYP="SYSUUID_C32"/>
    <importing PARAMETER="IT_CONTENT_STATIC" REFERENCE="X" TYP="ZTEC_T_CONTENT_DATA"/>
    <exporting PARAMETER="ES_DATA" REFERENCE="X" TYP="ANY"/>
    <exporting PARAMETER="EOS_DATA" REFERENCE="X" TYP="REF TO DATA" REF_CLASS="X"/>
    <documentation PARAMETER="IV_TYPE" KIND="P" STEXT="Type de table" INDEX=" 001"/>
    <documentation PARAMETER="IV_SUB_DATA_GUID" KIND="P" STEXT="GUID Sous-Ã‰lÃ©ment" INDEX=" 002"/>
    <documentation PARAMETER="IT_CONTENT_STATIC" KIND="P" STEXT="Type de table contenu de table" INDEX=" 003"/>
    <documentation PARAMETER="ES_DATA" KIND="P" INDEX=" 004"/>
    <documentation PARAMETER="EOS_DATA" KIND="P" STEXT="Structure dynamique" INDEX=" 005"/>
    <fm_source_new>***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    los_data        TYPE REF TO data,
    lot_data        TYPE REF TO data,
    lo_struct_descr TYPE REF TO cl_abap_structdescr.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_s_data&gt;   TYPE any,
    &lt;lfs_sub_data&gt; TYPE any.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  FREE : eos_data, es_data.

  &quot; -----------------------------------------------------------
  &quot; Création et Alimentation de la table de sortie
  &quot; -----------------------------------------------------------

  &quot; Rcupération composition de la structure
  lo_struct_descr ?= cl_abap_typedescr=&gt;describe_by_name( iv_type ).

  IF eos_data IS SUPPLIED.
    &quot; Gestion par référence
    &quot;&quot;  --&gt; Création de la structure
    CREATE DATA eos_data TYPE (lo_struct_descr-&gt;absolute_name).

    &quot;&quot;  --&gt; Initialisation pointeur sur les données de la structure
    ASSIGN eos_data-&gt;* TO &lt;lfs_s_data&gt;.

  ELSE.
    &quot; Gestion &quot;simple&quot;
    &quot;&quot;  --&gt; Initialisation pointeur sur les données de la structure
    ASSIGN es_data TO &lt;lfs_s_data&gt;.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Alimentation de la structure de sortie
  &quot; -----------------------------------------------------------

  &quot; Utilisation table statique
  LOOP AT it_content_static ASSIGNING FIELD-SYMBOL(&lt;lfs_s_content_static&gt;).

    &quot; Initialisation pointeur sur champ de la structure
    IF &lt;lfs_s_content_static&gt;-fieldname EQ gc_table_line.
      &quot; Cas d&apos;une table de type élémentaire
      &lt;lfs_s_data&gt; = &lt;lfs_s_content_static&gt;-value.

    ELSE.
      &quot; Cas d&apos;une structure &quot;complexe&quot;
      ASSIGN COMPONENT &lt;lfs_s_content_static&gt;-fieldname OF STRUCTURE &lt;lfs_s_data&gt;
                                                                  TO FIELD-SYMBOL(&lt;lfs_value_target&gt;).
      IF sy-subrc NE 0.
        &quot; Pas de correspondance // Ce cas ne devrais pas se produire
        &quot;&quot;  --&gt; Passe à l&apos;itération suivante
        CONTINUE.

      ENDIF.

      &quot; Suivant le type de champ
      CASE &lt;lfs_s_content_static&gt;-fieldkind.

        WHEN cl_abap_typedescr=&gt;kind_ref.
          &quot; Instance
          &quot;&quot;  --&gt; ToDo : Ajouter traitement

        WHEN cl_abap_typedescr=&gt;kind_class
          OR cl_abap_typedescr=&gt;kind_intf.
          &quot; Classe
          &quot;&quot;  --&gt; ToDo : Ajouter traitement

        WHEN cl_abap_typedescr=&gt;kind_table.
          &quot; Table
          &quot;&quot;  --&gt; Appel récursif pour type &quot;complexe&quot;
          CALL FUNCTION &apos;Z_CONVERT_TABLE_STATIC_TO_DYN&apos;
            EXPORTING
              iv_type           = &lt;lfs_s_content_static&gt;-fieldtype
              iv_sub_data_guid  = CONV sysuuid_c32( &lt;lfs_s_content_static&gt;-value )
              it_content_static = it_content_static
            IMPORTING
              eot_data          = lot_data.

          &quot;&quot;  --&gt; Alimentation de la zone
          ASSIGN lot_data-&gt;* TO &lt;lfs_sub_data&gt;.
          &lt;lfs_value_target&gt; = &lt;lfs_sub_data&gt;.

        WHEN cl_abap_typedescr=&gt;kind_elem.
          &quot; Type élémentaire
          &quot;&quot;  --&gt; Initialisation de la valeur
          &lt;lfs_value_target&gt; = &lt;lfs_s_content_static&gt;-value.

        WHEN cl_abap_typedescr=&gt;kind_struct.
          &quot; Structure
          &quot;&quot;  --&gt; Appel récursif pour type &quot;complexe&quot;
          CALL FUNCTION &apos;Z_CONVERT_STRUCT_STATIC_TO_DYN&apos;
            EXPORTING
              iv_type           = &lt;lfs_s_content_static&gt;-fieldtype
              iv_sub_data_guid  = CONV sysuuid_c32( &lt;lfs_s_content_static&gt;-value )
              it_content_static = it_content_static
            IMPORTING
              eos_data          = los_data.

          &quot;&quot;  --&gt; Alimentation de la zone
          ASSIGN los_data-&gt;* TO &lt;lfs_sub_data&gt;.
          &lt;lfs_value_target&gt; = &lt;lfs_sub_data&gt;.

        WHEN OTHERS.
          &quot; Autre
          &quot;&quot;  --&gt; ToDo : Traiter les autres cas
          CONTINUE.

      ENDCASE.

    ENDIF.

  ENDLOOP.</fm_source_new>
    <functionModuleDocumentation/>
   </functionmodule>
   <functionmodule NAME="Z_TASK_CALL_PROCESS" REMOTE="R" STEXT="Appel traitement //">
    <importing PARAMETER="IS_TASK_CALL_PROCESS" TYP="ZTEC_S_TASK_CALL_PROCESS"/>
    <importing PARAMETER="IT_TASK_CALL_PARAMETERS" TYP="ZTEC_T_FUNCTION_PARAMETERS"/>
    <importing PARAMETER="IV_TASK_CALL_DATA_COMPRESSED" OPTIONAL="X" TYP="ASR_CONTAINER_CONTENT"/>
    <importing PARAMETER="IS_TASK_DATA_COMPRESS_PARAM" TYP="ZTEC_S_TASK_COMPRESS_PARAM"/>
    <exporting PARAMETER="ET_TASK_RESULT" TYP="ZTEC_T_FUNCTION_PARAMETERS"/>
    <exporting PARAMETER="EV_TASK_RESULT_DATA_COMPRESSED" TYP="XSTRING"/>
    <exceptions EXCEPTION="DYNAMIC_CONVERT_ERROR"/>
    <exceptions EXCEPTION="CALL_PROCESS_ERROR"/>
    <exceptions EXCEPTION="DURING_PROCESS_ERROR"/>
    <documentation PARAMETER="IS_TASK_CALL_PROCESS" KIND="P" STEXT="Tâche - Traitement à lancer" INDEX=" 001"/>
    <documentation PARAMETER="IT_TASK_CALL_PARAMETERS" KIND="P" STEXT="Type de table paramètre d&apos;appel Statique" INDEX=" 002"/>
    <documentation PARAMETER="IV_TASK_CALL_DATA_COMPRESSED" KIND="P" STEXT="Contenu d&apos;un conteneur de données" INDEX=" 003"/>
    <documentation PARAMETER="IS_TASK_DATA_COMPRESS_PARAM" KIND="P" STEXT="Tâche - Paramètres de compression" INDEX=" 004"/>
    <documentation PARAMETER="ET_TASK_RESULT" KIND="P" STEXT="Table paramètres d&apos;appel statique" INDEX=" 005"/>
    <documentation PARAMETER="EV_TASK_RESULT_DATA_COMPRESSED" KIND="P" STEXT="Données compressées" INDEX=" 006"/>
    <documentation PARAMETER="DYNAMIC_CONVERT_ERROR" KIND="X" STEXT="Erreur lors de la conversion des paramètres dynamiques" INDEX=" 007"/>
    <documentation PARAMETER="CALL_PROCESS_ERROR" KIND="X" STEXT="Erreur lors de l&apos;appel du traitement" INDEX=" 008"/>
    <documentation PARAMETER="DURING_PROCESS_ERROR" KIND="X" STEXT="Erreur lors du traitement à appeler" INDEX=" 009"/>
    <fm_source_new>*&amp;---------------------------------------------------------------------*
*&amp; Module Fonction : Z_TASK_CALL_PROCESS                               *
*&amp; Groupe Fonction : ZTEC_TASK_PARALELL                                *
*&amp; Description     : Appel traitement                                  *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 22/07/2015                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR   : ev_task_result_data_compressed.
  REFRESH : et_task_result.

  IF NOT is_task_call_process-function_name IS INITIAL.
    &quot; -----------------------------------------------------------
    &quot; Appel d&apos;un Module Fonction
    &quot; -----------------------------------------------------------

    &quot; Appel du Module Fonction
    PERFORM function_call_process USING is_task_call_process-function_name
                                        it_task_call_parameters
                                        iv_task_call_data_compressed
                                        is_task_data_compress_param
                               CHANGING et_task_result
                                        ev_task_result_data_compressed.


  ELSEIF NOT is_task_call_process-class_name  IS INITIAL
     AND NOT is_task_call_process-method_name IS INITIAL.
    &quot; -----------------------------------------------------------
    &quot; Appel d&apos;une Méthode Statique
    &quot; -----------------------------------------------------------

    &quot; Appel de la Méthode Statique
    PERFORM method_call_process USING is_task_call_process-class_name
                                      is_task_call_process-method_name
                                      it_task_call_parameters
                                      iv_task_call_data_compressed
                                      is_task_data_compress_param
                             CHANGING et_task_result
                                      ev_task_result_data_compressed.

  ELSEIF NOT is_task_call_process-repid_name IS INITIAL.
    &quot; -----------------------------------------------------------
    &quot; Appel d&apos;un Programme
    &quot; -----------------------------------------------------------

    &quot; Appel d&apos;un Programme
    PERFORM repid_call_process USING is_task_call_process-repid_name
                                     it_task_call_parameters
                                     iv_task_call_data_compressed
                                     is_task_data_compress_param
                            CHANGING et_task_result
                                     ev_task_result_data_compressed.

  ELSE.
    &quot; Aucun traitement à exécuter
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.</fm_source_new>
    <functionModuleDocumentation/>
   </functionmodule>
   <functionmodule NAME="Z_TASK_TRACE_SAVE_TO_DB" REMOTE="R" STEXT="Trace Tâche - Sauvegarde dans la DB">
    <importing PARAMETER="IT_ZTASK_TRACE" TYP="ZTASK_TRACE_H_T"/>
    <importing PARAMETER="IV_COMMIT" OPTIONAL="X" TYP="FLAG"/>
    <exporting PARAMETER="EV_SUBRC" TYP="SY-SUBRC"/>
    <documentation PARAMETER="IT_ZTASK_TRACE" KIND="P" STEXT="Trace Tâche - Type de table" INDEX=" 001"/>
    <documentation PARAMETER="IV_COMMIT" KIND="P" STEXT="Commit des données ?" INDEX=" 002"/>
    <documentation PARAMETER="EV_SUBRC" KIND="P" STEXT="Zone système ABAP : code retour des instructions ABAP" INDEX=" 003"/>
    <fm_source>***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle des données
  &quot; -----------------------------------------------------------

  IF it_ztask_trace[] IS INITIAL.
    &quot; Aucune données
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Sauvegarde les Traces d&apos;exécution des Tâches
      &quot; -----------------------------------------------------------

      &quot; Modification données en DB
      MODIFY ztask_trace_h FROM TABLE it_ztask_trace.
      ev_subrc = sy-subrc.

      IF iv_commit EQ abap_true.
        &quot; Commit
        COMMIT WORK.

      ENDIF.

    CATCH cx_root. &quot;#EC CATCH_ALL
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Initialisation code retour en erreur
      ev_subrc = 4.

  ENDTRY.</fm_source>
    <functionModuleDocumentation/>
   </functionmodule>
  </functionmodules>
 </FUGR>
 <FUGR AREA="ZTASK_WIZARD" SPRAS="F" AREAT="ZTASK_WIZARD">
  <functionGroupDocumentation/>
  <mainprogram NAME="SAPLZTASK_WIZARD" VARCL="X" DBAPL="S" DBNA="D$" SUBC="F" APPL="S" RMAND="000" RLOAD="F" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
   <textPool>
    <language SPRAS="F">
     <textElement ID="I" KEY="001" ENTRY="Commencer" LENGTH="60 "/>
     <textElement ID="I" KEY="002" ENTRY="Sélection programme" LENGTH="60 "/>
     <textElement ID="I" KEY="003" ENTRY="Sélection Traitement à paralléliser - MF" LENGTH="60 "/>
     <textElement ID="I" KEY="004" ENTRY="Sélection Traitement à paralléliser - Méthode" LENGTH="60 "/>
     <textElement ID="I" KEY="005" ENTRY="Sélection Traitement à paralléliser - Programme" LENGTH="60 "/>
     <textElement ID="I" KEY="006" ENTRY="Configuration de la parallélisation" LENGTH="60 "/>
     <textElement ID="I" KEY="007" ENTRY="Terminer" LENGTH="18 "/>
     <textElement ID="I" KEY="TTL" ENTRY="Tâche - Assistant de création" LENGTH="60 "/>
    </language>
   </textPool>
   <dynpros>
    <dynpro PROG="SAPLZTASK_WIZARD" DNUM="0200" TYPE="I" FNUM="0000" BZMX="12 " BZBR="64 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="12 " NOCO="64 " VALP="0 " CUAN="G" SPRA="F" DTEXT="Sélection du programme cadre">
     <dynprofield FNAM="TITLE_REPID_TARGET" DIDX="0008" FLG1="00" FLG2="00" FLG3="00" FILL="R" FMB1="30" FMB2="00" LENG="40" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="101" AGLT="00" ADEZ="00" STXT="Sélection programme cadre"/>
     <dynprofield FNAM="TARGET_REPID_TITLE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="0F" LINE="02" COLN="03" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Programme cadre" RES1="                                                                                                                                                                                                                                                        X"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-TARGET_REPID" DIDX="0000" FLG1="80" FLG2="00" FLG3="A0" FMB1="08" FMB2="08" LENG="1E" LINE="02" COLN="13" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" DMAC="PROGNAME" ITYP="C" AGLT="00" ADEZ="00" STXT="______________________________"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-TARGET_FRAMEWORK_INCL_USE" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="C" FMB1="00" FMB2="00" LENG="01" LINE="03" COLN="03" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="102" GRP1="100" ITYP="C" AGLT="00" ADEZ="00" RES1="                                                                                                                                                                       PTASK_INCL_U"/>
     <dynprofield FNAM="TARGET_INCLUDE_USE_TITLE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="12" LINE="03" COLN="05" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" GRP1="100" ITYP="0" AGLT="00" ADEZ="00" STXT="Cadriciel Incl. :" RES1="                                                                                                                                                                                                                                                        XX"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-TARGET_FRAMEWORK_INCL_DATA-INCLUDE_NAME" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="00" FMB2="00" LENG="1E" LINE="03" COLN="18" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" GRP1="100" GRP2="110" ITYP="C" AGLT="00" ADEZ="00" STXT="______________________________"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-TARGET_FRAMEWORK_INCL_DATA-INCLUDE_CREATE" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="A" FMB1="00" FMB2="00" LENG="01" LINE="03" COLN="37" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="103" GRP1="100" GRP2="110" ITYP="C" AGLT="00" ADEZ="00" RES1="                                                                                                                                                                       PTASK_INCL_R"/>
     <dynprofield FNAM="FRAMEWORK_INCL_CREATE_TITLE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="05" LINE="03" COLN="39" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" GRP1="100" GRP2="110" ITYP="0" AGLT="00" ADEZ="00" STXT="Créer" RES1="                                                                                                                                                                                                                                                         X"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-TARGET_FRAMEWORK_INCL_DATA-INCLUDE_CHANGE" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="A" FMB1="00" FMB2="00" LENG="01" LINE="04" COLN="37" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="103" GRP1="100" GRP2="110" ITYP="C" AGLT="00" ADEZ="00" RES1="                                                                                                                                                                       PTASK_INCL_R"/>
     <dynprofield FNAM="FRAMEWORK_INCL_CHANGE_RB_TITLE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="08" LINE="04" COLN="39" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" GRP1="100" GRP2="110" ITYP="0" AGLT="00" ADEZ="00" STXT="Modifier" RES1="                                                                                                                                                                                                                                                         X"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-TARGET_SELSCREEN_ADD" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="C" FMB1="00" FMB2="00" LENG="01" LINE="05" COLN="03" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="104" GRP1="100" ITYP="C" AGLT="00" ADEZ="00" RES1="                                                                                                                                                                       PSEL_ADD"/>
     <dynprofield FNAM="TARGET_SELSCREEN_USE_TILTLE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="38" LINE="05" COLN="05" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" GRP1="100" ITYP="0" AGLT="00" ADEZ="00" STXT="Ajout paramètres configuration dans l&apos;écran de sélection" RES1="                                                                                                                                                                                                                                                         X"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-TARGET_SELSCREEN_INCL_USE" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="C" FMB1="00" FMB2="00" LENG="01" LINE="06" COLN="05" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="105" GRP1="100" GRP2="120" ITYP="C" AGLT="00" ADEZ="00" RES1="                                                                                                                                                                       PSEL_INCL_U"/>
     <dynprofield FNAM="TARGET_SELSCREEN_ADD_TITLE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="10" LINE="06" COLN="07" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" GRP1="100" GRP2="120" GRP3="121" ITYP="0" AGLT="00" ADEZ="00" STXT="Utiliser Incl. :" RES1="                                                                                                                                                                                                                                                        XX"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-TARGET_SELSCREEN_INCL_DATA-INCLUDE_NAME" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="00" FMB2="00" LENG="1E" LINE="06" COLN="18" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" GRP1="100" GRP2="120" GRP3="121" ITYP="C" AGLT="00" ADEZ="00" STXT="______________________________"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-TARGET_SELSCREEN_INCL_DATA-INCLUDE_CREATE" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="A" FMB1="00" FMB2="00" LENG="01" LINE="06" COLN="37" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="106" GRP1="100" GRP2="120" GRP3="121" ITYP="C" AGLT="00" ADEZ="00" RES1="                                                                                                                                                                       PSEL_INCL_R"/>
     <dynprofield FNAM="%#AUTOTEXT001" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="05" LINE="06" COLN="39" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" GRP1="100" GRP2="120" GRP3="121" ITYP="0" AGLT="00" ADEZ="00" STXT="Créer" RES1="                                                                                                                                                                                                                                                         X"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-TARGET_SELSCREEN_INCL_DATA-INCLUDE_CHANGE" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="A" FMB1="00" FMB2="00" LENG="01" LINE="07" COLN="37" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="106" GRP1="100" GRP2="120" GRP3="121" ITYP="C" AGLT="00" ADEZ="00" RES1="                                                                                                                                                                       PSEL_INCL_R"/>
     <dynprofield FNAM="TARGET_SELSCREEN_INCL_CHANGE_TITLE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="08" LINE="07" COLN="39" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" GRP1="100" GRP2="120" GRP3="121" ITYP="0" AGLT="00" ADEZ="00" STXT="Modifier" RES1="                                                                                                                                                                                                                                                         X"/>
     <dynprofield FNAM="TASK_TEMPLATE" DIDX="0004" FLG1="00" FLG2="00" FLG3="00" FILL="R" FMB1="30" FMB2="00" LENG="40" LINE="09" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="107" AGLT="00" ADEZ="00" STXT="Sélection Template Cadriciel Tâche"/>
     <dynprofield FNAM="TASK_TEMPLATE_REPID_TITLE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="15" LINE="0A" COLN="03" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Template Cadriciel" RES1="                                                                                                                                                                                                                                                        X"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-TASK_TEMPLATE_REPID" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="30" FMB2="00" LENG="1E" LINE="0A" COLN="19" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="______________________________"/>
     <dynprofield FNAM="TASK_CLASS_REPLACE_TITLE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="15" LINE="0B" COLN="03" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Nouveau Nom cadriciel" RES1="                                                                                                                                                                                                                                                        X"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-TASK_CLASS_REPLACE" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="00" FMB2="00" LENG="1E" LINE="0B" COLN="19" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                                                                                                                                                                                                                                             X"/>
     <dynprofield DIDX="0000" FLG1="80" FLG2="10" FLG3="08" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
     <dynproflowsource>PROCESS BEFORE OUTPUT.
  MODULE pbo_0200.

PROCESS AFTER INPUT.
  MODULE wz_user_command_wizard.
* user defined modules

  MODULE usr_check_consistency_0200.</dynproflowsource>
    </dynpro>
    <dynpro PROG="SAPLZTASK_WIZARD" DNUM="0500" TYPE="I" FNUM="0000" BZMX="11 " BZBR="64 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="11 " NOCO="64 " VALP="0 " CUAN="G" SPRA="F" DTEXT="Sélection des traitements à paralléliser - Programme">
     <dynprofield FNAM="CC_ALV_0500" DIDX="000B" FLG1="00" FLG2="00" FLG3="00" FILL="U" FMB1="30" FMB2="00" LENG="40" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" AUTH="101" AGLT="01" ADEZ="01"/>
     <dynprofield DIDX="0000" FLG1="80" FLG2="10" FLG3="08" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
     <dynproflowsource>PROCESS BEFORE OUTPUT.
  MODULE pbo_0500.

PROCESS AFTER INPUT.
  MODULE wz_user_command_wizard.
* user defined modules

  MODULE usr_check_consistency_0500.</dynproflowsource>
    </dynpro>
    <dynpro PROG="SAPLZTASK_WIZARD" DNUM="0300" TYPE="I" FNUM="0000" BZMX="11 " BZBR="64 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="11 " NOCO="64 " VALP="0 " CUAN="G" SPRA="F" DTEXT="Sélection des traitements à paralléliser - MF">
     <dynprofield FNAM="CC_ALV_0300" DIDX="000B" FLG1="00" FLG2="00" FLG3="00" FILL="U" FMB1="30" FMB2="00" LENG="40" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" AUTH="101" AGLT="01" ADEZ="01"/>
     <dynprofield DIDX="0000" FLG1="80" FLG2="10" FLG3="08" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
     <dynproflowsource>PROCESS BEFORE OUTPUT.
  MODULE pbo_0300.

PROCESS AFTER INPUT.
  MODULE wz_user_command_wizard.
* user defined modules

  MODULE usr_check_consistency_0300.</dynproflowsource>
    </dynpro>
    <dynpro PROG="SAPLZTASK_WIZARD" DNUM="0600" TYPE="I" FNUM="0000" BZMX="12 " BZBR="48 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="12 " NOCO="64 " VALP="0 " CUAN="G" SPRA="F" DTEXT="Configuration de la parallélisation">
     <dynprofield FNAM="CADRE_GRFC" DIDX="0006" FLG1="00" FLG2="00" FLG3="00" FILL="R" FMB1="30" FMB2="00" LENG="30" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="101" AGLT="00" ADEZ="00" STXT="Groupe de Serveur"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-SERVER_DEFAULT" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="A" FMB1="00" FMB2="00" LENG="01" LINE="02" COLN="04" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="102" ITYP="C" AGLT="00" ADEZ="00" RES1="                                                                                                                                                                       PGRFC_SEL"/>
     <dynprofield FNAM="SERVER_DEFAULT_TITLE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="25" LINE="02" COLN="06" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Utiliser Groupe de Serveur par défaut" RES1="                                                                                                                                                                                                                                                         X"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-SERVER_USER" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="A" FMB1="00" FMB2="00" LENG="01" LINE="03" COLN="04" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="102" ITYP="C" AGLT="00" ADEZ="00" RES1="                                                                                                                                                                       PGRFC_SEL"/>
     <dynprofield FNAM="SERVER_USER_TITLE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="1E" LINE="03" COLN="06" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Sélectionner Groupe de Serveur" RES1="                                                                                                                                                                                                                                                         X"/>
     <dynprofield FNAM="GRFC_TITLE" DIDX="0015" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="30" LINE="04" COLN="06" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="@X9@ Groupe de Serveur" RES1="                                                                                                                                                                                                                                                        X"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-GRFC" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="00" FMB2="08" LENG="12" LINE="04" COLN="1C" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" DMAC="SWESRVGRP" GRP1="100" ITYP="C" AGLT="00" ADEZ="00" STXT="__________________" RES1="                                                                                                                                                                                                                                                             X"/>
     <dynprofield FNAM="TASK_MAX_TITLE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="0F" LINE="05" COLN="04" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Nombre de Tâche" RES1="                                                                                                                                                                                                                                                        X"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-TASK_MAX" DIDX="0007" FLG1="80" FLG2="00" FLG3="A0" FMB1="00" FMB2="00" LENG="07" LINE="05" COLN="14" LANF="00" LBLK="00" LREP="00" TYPE="INT4" ITYP="C" AGLT="00" ADEZ="00" STXT="_______" RES1="                                       00"/>
     <dynprofield FNAM="PARAMETER_TASK_MANAGER" DIDX="0006" FLG1="00" FLG2="00" FLG3="00" FILL="R" FMB1="30" FMB2="00" LENG="30" LINE="07" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="103" AGLT="00" ADEZ="00" STXT="Options supplémentaires"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-COMPRESS_ACTIV" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="C" FMB1="00" FMB2="00" LENG="01" LINE="08" COLN="03" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="104" ITYP="C" AGLT="00" ADEZ="00" RES1="                                                                                                                                                                       PCOMP_SEL"/>
     <dynprofield FNAM="COMPRESS_ACTIV_TITLE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="16" LINE="08" COLN="05" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Activer la Compression" RES1="                                                                                                                                                                                                                                                         X"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-COMPRESS_MODE-DATA_COMPRESS_LINE_BY_LINE" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="A" FMB1="00" FMB2="00" LENG="01" LINE="09" COLN="05" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="105" GRP1="200" ITYP="C" AGLT="00" ADEZ="00" RES1="                                                                                                                                                                       PCOMP_M_SEL"/>
     <dynprofield FNAM="COMPRESS_MODE_LINE_BY_LINE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="19" LINE="09" COLN="07" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Compression Ligne-à-Ligne" RES1="                                                                                                                                                                                                                                                         X"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-COMPRESS_MODE-DATA_COMPRESS_GLOBAL" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="A" FMB1="00" FMB2="00" LENG="01" LINE="0A" COLN="05" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="105" GRP1="200" ITYP="C" AGLT="00" ADEZ="00" RES1="                                                                                                                                                                       PCOMP_M_SEL"/>
     <dynprofield FNAM="COMPRESS_MODE_GLOBAL_TITLE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="13" LINE="0A" COLN="07" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Compression Globale" RES1="                                                                                                                                                                                                                                                         X"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-SHM_MANAGEMENT" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="C" FMB1="00" FMB2="00" LENG="01" LINE="0B" COLN="03" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="106" ITYP="C" AGLT="00" ADEZ="00" RES1="                                                                                                                                                                       PSHM_SEL"/>
     <dynprofield FNAM="SHM_MANAGEMENT_TITLE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="17" LINE="0B" COLN="05" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Gestion auto. de la SHM" RES1="                                                                                                                                                                                                                                                         X"/>
     <dynprofield FNAM="GS_GLOBAL_DATA-S_TASK_WIZARD_DATA-TRACE_ACTIV" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="C" FMB1="00" FMB2="00" LENG="01" LINE="0B" COLN="21" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="107" ITYP="C" AGLT="00" ADEZ="00" RES1="                                                                                                                                                                       PTRACE_SEL"/>
     <dynprofield FNAM="TRACE_ACTIV_TITLE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="0D" LINE="0B" COLN="23" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Activer Trace" RES1="                                                                                                                                                                                                                                                         X"/>
     <dynprofield DIDX="0000" FLG1="80" FLG2="10" FLG3="08" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
     <dynproflowsource>PROCESS BEFORE OUTPUT.
  MODULE pbo_0600.

PROCESS AFTER INPUT.
  MODULE wz_user_command_wizard.
* user defined modules

  MODULE usr_check_consistency_0600.</dynproflowsource>
    </dynpro>
    <dynpro PROG="SAPLZTASK_WIZARD" DNUM="0400" TYPE="I" FNUM="0000" BZMX="11 " BZBR="64 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="11 " NOCO="64 " VALP="0 " CUAN="G" SPRA="F" DTEXT="Sélection des traitements à paralléliser - Méthode">
     <dynprofield FNAM="CC_ALV_0400" DIDX="000B" FLG1="00" FLG2="00" FLG3="00" FILL="U" FMB1="30" FMB2="00" LENG="40" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" AUTH="101" AGLT="01" ADEZ="01"/>
     <dynprofield DIDX="0000" FLG1="80" FLG2="10" FLG3="08" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
     <dynproflowsource>PROCESS BEFORE OUTPUT.
  MODULE pbo_0400.

PROCESS AFTER INPUT.
  MODULE wz_user_command_wizard.
* user defined modules

  MODULE usr_check_consistency_0400.</dynproflowsource>
    </dynpro>
   </dynpros>
   <pfstatus>
    <pfstatus_sta CODE="CTX_MENU_WZ_TASK" MODAL="C" INT_NOTE="Tâche - Wizard - Menu contextuel" CTXCODE="000001"/>
    <pfstatus_fun CODE="WZ_TASK_C" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Implémenter Tâche"/>
    <pfstatus_men CODE="000001" NO="01" REF_TYPE="F" REF_CODE="WZ_TASK_C" REF_NO="001"/>
    <pfstatus_mtx CODE="000001" TEXT_TYPE="S" TEXT="Wizard" INT_NOTE="Tâche - Wizard - Menu contextuel"/>
    <pfstatus_set STATUS="CTX_MENU_WZ_TASK" FUNCTION="WZ_TASK_C"/>
   </pfstatus>
   <source>*******************************************************************
*   System-defined Include-files.                                 *
*******************************************************************
  INCLUDE LZTASK_WIZARDTOP.                     &quot; Global Data
  INCLUDE LZTASK_WIZARDUXX.                     &quot; Function Mod

*******************************************************************
*   User-defined Include-files (if necessary).                    *
*******************************************************************

INCLUDE lztask_wizardd01.
INCLUDE lztask_wizardp01.
INCLUDE lztask_wizardo01.

INCLUDE LZTASK_WIZARDFWZ.
*INCLUDE LSBPT_WIZARD_TEMPLATEFWZ.
*INCLUDE LSWZ_WIZARD_TEMPLATEFWZ.
*INCLUDE LSTB_WZ_WIZARD_TEMPLATEFWZ.

INCLUDE LZTASK_WIZARDFCB.
*INCLUDE LSBPT_WIZARD_TEMPLATEFCB.
*INCLUDE LSWZ_WIZARD_TEMPLATEFCB.
*INCLUDE LSTB_WZ_WIZARD_TEMPLATEFCB.


*&amp;WZ_PATTERN_INCLUDE_PROCESS_SUBSCREEN&amp;

INCLUDE LZTASK_WIZARDUSR.
*INCLUDE LSBPT_WIZARD_TEMPLATEUSR.
*INCLUDE LSWZ_WIZARD_TEMPLATEUSR.</source>
  </mainprogram>
  <includeprograms>
   <include NAME="LZTASK_WIZARDD01" VARCL="X" SUBC="I" APPL="S" RMAND="200" RLOAD="F" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LZTASK_WIZARDD01.
*----------------------------------------------------------------------*


*----------------------------------------------------------------------*
*       CLASS LCL_ALV_HANDLER_GENERIC DEFINIION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_alv_handler_generic DEFINITION FINAL.

*-- Publique
  PUBLIC SECTION.

***------------------------------------------------------------------***
**                              TYPES                                 **
***------------------------------------------------------------------***

*   Déclaration de type

***------------------------------------------------------------------***
**                           MÉTHODES                                 **
***------------------------------------------------------------------***

*	Déclaration de méthodes

    &quot; Constructeur
    METHODS constructor
      IMPORTING
        io_alv_grid      TYPE REF TO cl_gui_alv_grid
        iot_display_data TYPE REF TO data.

    &quot; Handler Aide à la recherche
    METHODS handler_onf4
      FOR EVENT onf4
          OF cl_gui_alv_grid
      IMPORTING
          e_display e_fieldname e_fieldvalue er_event_data es_row_no et_bad_cells. &quot;#EC NEEDED

    &quot; Handler clique bouton
    METHODS handler_button_click
      FOR EVENT button_click
          OF cl_gui_alv_grid
      IMPORTING
          es_col_id es_row_no.                              &quot;#EC NEEDED

    &quot; Handler évènement double clique
    METHODS handler_double_click
      FOR EVENT double_click
                  OF cl_gui_alv_grid
      IMPORTING e_row e_column es_row_no.                   &quot;#EC NEEDED

    &quot; Handler Sélection HotSpot
    METHODS handler_hotspot_click
      FOR EVENT hotspot_click
                  OF cl_gui_alv_grid
      IMPORTING e_column_id e_row_id es_row_no.             &quot;#EC NEEDED

    &quot; Handler Toolbar
    METHODS handler_toolbar
      FOR EVENT toolbar
                  OF cl_gui_alv_grid
      IMPORTING e_interactive e_object sender.              &quot;#EC NEEDED

    &quot; Handler Action utilisateur
    METHODS handler_user_command
      FOR EVENT user_command
                  OF cl_gui_alv_grid
      IMPORTING e_ucomm sender.                             &quot;#EC NEEDED

    &quot; Handler modification données
    METHODS handler_data_changed
      FOR EVENT data_changed
                  OF cl_gui_alv_grid
      IMPORTING er_data_changed e_ucomm e_onf4 e_onf4_after e_onf4_before. &quot;#EC NEEDED

    &quot; Handler fin modification données
    METHODS handler_data_changed_finished
      FOR EVENT data_changed_finished
          OF cl_gui_alv_grid
      IMPORTING
          e_modified et_good_cells.                         &quot;#EC NEEDED

***------------------------------------------------------------------***
**                            ATTRIBUTS                               **
***------------------------------------------------------------------***

*	Déclaration d&apos;attributs


*-- Privée
  PRIVATE SECTION.

***------------------------------------------------------------------***
**                              TYPES                                 **
***------------------------------------------------------------------***

*   Déclaration de type

***------------------------------------------------------------------***
**                           MÉTHODES                                 **
***------------------------------------------------------------------***

*	Déclaration de méthodes

    &quot; Souscriptions aux évènements
    METHODS event_register.

    &quot; Contrôle - MF
    METHODS __funcname_check
      IMPORTING
                !is_mod_cells    TYPE lvc_s_modi
      RETURNING VALUE(rs_return) TYPE bapiret2.

    &quot; Contrôle - Méthode
    METHODS __methodname_check
      IMPORTING
                !is_mod_cells    TYPE lvc_s_modi
                !ir_data_changed TYPE REF TO cl_alv_changed_data_protocol
      RETURNING VALUE(rs_return) TYPE bapiret2.


***------------------------------------------------------------------***
**                            ATTRIBUTS                               **
***------------------------------------------------------------------***

*	Déclaration d&apos;attributs

    DATA : mo_alv_grid TYPE REF TO cl_gui_alv_grid.
    DATA : mot_display_data TYPE REF TO data.

ENDCLASS.             &quot;LCL_ALV_HANDLER_GENERIC DEFINITION


*----------------------------------------------------------------------*
*       CLASS LCL_ALV_GENERIC DEFINIION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_alv_generic DEFINITION FINAL.

*-- Publique
  PUBLIC SECTION.

***------------------------------------------------------------------***
**                              TYPES                                 **
***------------------------------------------------------------------***

*   Déclaration de type

***------------------------------------------------------------------***
**                           MÉTHODES                                 **
***------------------------------------------------------------------***

*	Déclaration de méthodes

    &quot; Constructeur
    METHODS constructor
      IMPORTING
        iv_container_name TYPE clike
      RAISING
        cx_create_error.

    &quot; Contrôle données saisies
    METHODS check
      RETURNING VALUE(rv_error) TYPE sy-input.

    &quot; Affichage
    METHODS display
      IMPORTING
        it_fieldcatalog TYPE lvc_t_fcat OPTIONAL
      CHANGING
        ct_display_data TYPE STANDARD TABLE
      RAISING
        cx_salv_call_after_1st_display.

***------------------------------------------------------------------***
**                            ATTRIBUTS                               **
***------------------------------------------------------------------***

*	Déclaration d&apos;attributs


*-- Privée
  PRIVATE SECTION.

***------------------------------------------------------------------***
**                              TYPES                                 **
***------------------------------------------------------------------***

*   Déclaration de type

    &quot; ALV Generic - Container de Données
    TYPES :
      BEGIN OF ts_container_data,
        t_display_data TYPE REF TO data,
      END OF   ts_container_data.

    &quot; ALV Generic - Elèments pour l&apos;Affichage
    TYPES :
      BEGIN OF ts_display_element,
        s_layout            TYPE        lvc_s_layo,
        t_fieldcatalog      TYPE        lvc_t_fcat,
        t_toolbar_excluding TYPE ui_functions,
        o_event             TYPE REF TO lcl_alv_handler_generic,
        o_alv_grid          TYPE REF TO cl_gui_alv_grid,
        o_ccontainer        TYPE REF TO cl_gui_custom_container,
      END OF   ts_display_element.

    &quot; ALV Generic - Ensemble des composantes
    TYPES :
      BEGIN OF ts_alv_generic,
        data            TYPE ts_container_data,
        display_element TYPE ts_display_element,
      END OF   ts_alv_generic.

***------------------------------------------------------------------***
**                           MÉTHODES                                 **
***------------------------------------------------------------------***

*	Déclaration de méthodes

    &quot; Initialisation Toolbar
    METHODS toolbar_set.

    &quot; Affichage
    METHODS __display
      RAISING
        cx_salv_call_after_1st_display.

    &quot; Initialisation des élèments d&apos;Affichage
    METHODS display_element_set
      IMPORTING
        it_fieldcatalog TYPE lvc_t_fcat OPTIONAL
      CHANGING
        ct_display_data TYPE STANDARD TABLE.

    &quot; Initialisation FC
    METHODS fieldcatalog_generic_set
      IMPORTING
        it_display_data TYPE STANDARD TABLE.

***------------------------------------------------------------------***
**                            ATTRIBUTS                               **
***------------------------------------------------------------------***

*	Déclaration d&apos;attributs

    DATA : mv_first_display_done TYPE xsdboolean.
    DATA : ms_display_element TYPE ts_alv_generic.

ENDCLASS.             &quot;LCL_ALV_GENERIC DEFINITION</include_source>
   </include>
   <include NAME="LZTASK_WIZARDFCB" VARCL="X" SUBC="I" LEVL="740" RMAND="000" RLOAD="D" LDBNAME="D$S" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LWZ_WIZARDFCB .
*----------------------------------------------------------------------*
*&amp;WZ_PATTERN_WIZARD_CALLBACK&amp;
*&amp;---------------------------------------------------------------
*&amp;      FORM  CB_PROCESS_STEP_START
*&amp;---------------------------------------------------------------
FORM cb_process_step_start                                  &quot;#EC CALLED
        TABLES
           container
        USING
           command.
* begin of local data definition
  DATA:
    l_wizard    TYPE swf_wizard.
* end of local data definition

* first screen (button &apos;back&apos; will be automatically switched off
* and there will be NO popup &apos;you will lose data&apos;...)
  l_wizard-screen_typ = wizard_screen_start.

* initialize wizard step
* the wizard has one unique title while it is running
  l_wizard-title      = text-ttl.
  l_wizard-descobject = &apos;ZTASK_WIZARD_001&apos;
  . &quot;this is a text in dialog (SE61)
* call wizard screen
  CALL FUNCTION &apos;SWF_WIZARD_CALL&apos;
    EXPORTING
      wizard_data                 = l_wizard
    EXCEPTIONS
      operation_cancelled_by_user = 01
      back                        = 02.
  swf_evaluate command.

ENDFORM.                    &quot; CB_PROCESS_STEP_START
*&amp;---------------------------------------------------------------
*&amp;      FORM  CB_PROCESS_STEP_0200
*&amp;---------------------------------------------------------------
FORM cb_process_step_0200                                   &quot;#EC CALLED
        TABLES
           container
        USING
           command.
* begin of local data definition
  DATA:
    l_wizard    TYPE swf_wizard.
* end of local data definition

* initialize wizard step
* the wizard has one unique title while it is running
  l_wizard-title      = text-ttl.
  l_wizard-descobject = &apos;ZTASK_WIZARD_002&apos;
  . &quot;this is a text in dialog (SE61)
  l_wizard-subscreen1 = &apos;0200&apos;.
  l_wizard-subscpool1 = &apos;SAPLZTASK_WIZARD&apos;.

* set subscreen data (transport data out of global wizard data
* to global screen data )
  PERFORM usr_set_subscreen_data_0200.

* call wizard screen
  CALL FUNCTION &apos;SWF_WIZARD_CALL&apos;
    EXPORTING
      wizard_data                 = l_wizard
    EXCEPTIONS
      operation_cancelled_by_user = 01
      back                        = 02.
  swf_evaluate command.

* set subscreen data from global screen data back to the global
* wizard area
  PERFORM usr_get_subscreen_data_0200.

ENDFORM.                    &quot; CB_PROCESS_STEP_0200
*&amp;---------------------------------------------------------------
*&amp;      FORM  CB_PROCESS_STEP_0300
*&amp;---------------------------------------------------------------
FORM cb_process_step_0300                                   &quot;#EC CALLED
        TABLES
           container
        USING
           command.
* begin of local data definition
  DATA:
    l_wizard    TYPE swf_wizard.
* end of local data definition

* initialize wizard step
* the wizard has one unique title while it is running
  l_wizard-title      = text-ttl.
  l_wizard-descobject = &apos;ZTASK_WIZARD_003&apos;
  . &quot;this is a text in dialog (SE61)
  l_wizard-subscreen1 = &apos;0300&apos;.
  l_wizard-subscpool1 = &apos;SAPLZTASK_WIZARD&apos;.

* set subscreen data (transport data out of global wizard data
* to global screen data )
  PERFORM usr_set_subscreen_data_0300.

* call wizard screen
  CALL FUNCTION &apos;SWF_WIZARD_CALL&apos;
    EXPORTING
      wizard_data                 = l_wizard
    EXCEPTIONS
      operation_cancelled_by_user = 01
      back                        = 02.
  swf_evaluate command.

* set subscreen data from global screen data back to the global
* wizard area
  PERFORM usr_get_subscreen_data_0300.

ENDFORM.                    &quot; CB_PROCESS_STEP_0300

*&amp;---------------------------------------------------------------
*&amp;      FORM  CB_PROCESS_STEP_0400
*&amp;---------------------------------------------------------------
FORM cb_process_step_0400                                   &quot;#EC CALLED
        TABLES
           container
        USING
           command.
* begin of local data definition
  DATA:
    l_wizard    TYPE swf_wizard.
* end of local data definition

* initialize wizard step
* the wizard has one unique title while it is running
  l_wizard-title      = text-ttl.
  l_wizard-descobject = &apos;ZTASK_WIZARD_004&apos;
  . &quot;this is a text in dialog (SE61)
  l_wizard-subscreen1 = &apos;0400&apos;.
  l_wizard-subscpool1 = &apos;SAPLZTASK_WIZARD&apos;.

* set subscreen data (transport data out of global wizard data
* to global screen data )
  PERFORM usr_set_subscreen_data_0400.

* call wizard screen
  CALL FUNCTION &apos;SWF_WIZARD_CALL&apos;
    EXPORTING
      wizard_data                 = l_wizard
    EXCEPTIONS
      operation_cancelled_by_user = 01
      back                        = 02.
  swf_evaluate command.

* set subscreen data from global screen data back to the global
* wizard area
  PERFORM usr_get_subscreen_data_0400.

ENDFORM.                    &quot; CB_PROCESS_STEP_0400


*&amp;---------------------------------------------------------------
*&amp;      FORM  CB_PROCESS_STEP_0500
*&amp;---------------------------------------------------------------
FORM cb_process_step_0500                                   &quot;#EC CALLED
        TABLES
           container
        USING
           command.
* begin of local data definition
  DATA:
    l_wizard    TYPE swf_wizard.
* end of local data definition

* initialize wizard step
* the wizard has one unique title while it is running
  l_wizard-title      = text-ttl.
  l_wizard-descobject = &apos;ZTASK_WIZARD_005&apos;
  . &quot;this is a text in dialog (SE61)
  l_wizard-subscreen1 = &apos;0500&apos;.
  l_wizard-subscpool1 = &apos;SAPLZTASK_WIZARD&apos;.

* set subscreen data (transport data out of global wizard data
* to global screen data )
  PERFORM usr_set_subscreen_data_0500.

* call wizard screen
  CALL FUNCTION &apos;SWF_WIZARD_CALL&apos;
    EXPORTING
      wizard_data                 = l_wizard
    EXCEPTIONS
      operation_cancelled_by_user = 01
      back                        = 02.
  swf_evaluate command.

* set subscreen data from global screen data back to the global
* wizard area
  PERFORM usr_get_subscreen_data_0500.

ENDFORM.                    &quot; CB_PROCESS_STEP_0400

*&amp;---------------------------------------------------------------
*&amp;      FORM  CB_PROCESS_STEP_0600
*&amp;---------------------------------------------------------------
FORM cb_process_step_0600                                   &quot;#EC CALLED
        TABLES
           container
        USING
           command.
* begin of local data definition
  DATA:
    l_wizard    TYPE swf_wizard.
* end of local data definition

* initialize wizard step
* the wizard has one unique title while it is running
  l_wizard-title      = text-ttl.
  l_wizard-descobject = &apos;ZTASK_WIZARD_006&apos;
  . &quot;this is a text in dialog (SE61)
  l_wizard-subscreen1 = &apos;0600&apos;.
  l_wizard-subscpool1 = &apos;SAPLZTASK_WIZARD&apos;.

* set subscreen data (transport data out of global wizard data
* to global screen data )
  PERFORM usr_set_subscreen_data_0600.

* call wizard screen
  CALL FUNCTION &apos;SWF_WIZARD_CALL&apos;
    EXPORTING
      wizard_data                 = l_wizard
    EXCEPTIONS
      operation_cancelled_by_user = 01
      back                        = 02.
  swf_evaluate command.

* set subscreen data from global screen data back to the global
* wizard area
  PERFORM usr_get_subscreen_data_0600.

ENDFORM.                    &quot; CB_PROCESS_STEP_0600

*&amp;---------------------------------------------------------------
*&amp;      FORM  CB_PROCESS_STEP_FINISH
*&amp;---------------------------------------------------------------
FORM cb_process_step_finish                                 &quot;#EC CALLED
        TABLES
           container
        USING
           command.
* begin of local data definition
  DATA:
    l_wizard    TYPE swf_wizard.
* end of local data definition

* initialize wizard step
* the wizard has one unique title while it is running
  l_wizard-title      = text-ttl.
  l_wizard-descobject = &apos;ZTASK_WIZARD_007&apos;
  . &quot;this is a text in dialog (SE61)
* last screen (button &apos;continue&apos; will be called &apos;done&apos;)
  l_wizard-screen_typ = wizard_screen_end.

* call wizard screen
  CALL FUNCTION &apos;SWF_WIZARD_CALL&apos;
    EXPORTING
      wizard_data                 = l_wizard
    EXCEPTIONS
      operation_cancelled_by_user = 01
      back                        = 02.
  swf_evaluate command.

* process data collected by wizard
  PERFORM usr_process_wizard_data.

ENDFORM.                    &quot; CB_PROCESS_STEP_FINISH</include_source>
   </include>
   <include NAME="LZTASK_WIZARDFWZ" VARCL="X" SUBC="I" LEVL="740" RMAND="000" RLOAD="D" LDBNAME="D$S" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LWZ_WIZARDFWZ .
*----------------------------------------------------------------------*
************************************************************************
* Wizard data:
*   All data collected by the wizard
************************************************************************



************************************************************************
* FORM-Routines
************************************************************************
*&amp;---------------------------------------------------------------------*
*&amp;      Form  WZ_DEFINE_WIZARD_STEPS
*&amp;---------------------------------------------------------------------*
FORM wz_define_wizard_steps TABLES
           p_wizard_steps   STRUCTURE swf_wizdef.
  DATA:
    l_wizard_step   TYPE swf_wizdef.

*&amp;WZ_PATTERN_WIZARD_STEPS_START&amp;
  l_wizard_step-program   = &apos;SAPLZTASK_WIZARD&apos;.             &quot;#EC NOTEXT

  l_wizard_step-form      = &apos;CB_PROCESS_STEP_START&apos;.        &quot;#EC NOTEXT
  l_wizard_step-text      = text-001.
  APPEND l_wizard_step TO p_wizard_steps.

  l_wizard_step-form      = &apos;CB_PROCESS_STEP_0200&apos;.         &quot;#EC NOTEXT
  l_wizard_step-text      = text-002.
  APPEND l_wizard_step TO p_wizard_steps.

  l_wizard_step-form      = &apos;CB_PROCESS_STEP_0300&apos;.         &quot;#EC NOTEXT
  l_wizard_step-text      = text-003.
  APPEND l_wizard_step TO p_wizard_steps.

  l_wizard_step-form      = &apos;CB_PROCESS_STEP_0400&apos;.         &quot;#EC NOTEXT
  l_wizard_step-text      = text-004.
  APPEND l_wizard_step TO p_wizard_steps.

  l_wizard_step-form      = &apos;CB_PROCESS_STEP_0500&apos;.         &quot;#EC NOTEXT
  l_wizard_step-text      = text-005.
  APPEND l_wizard_step TO p_wizard_steps.

  l_wizard_step-form      = &apos;CB_PROCESS_STEP_0600&apos;.         &quot;#EC NOTEXT
  l_wizard_step-text      = text-006.
  APPEND l_wizard_step TO p_wizard_steps.

  l_wizard_step-form      = &apos;CB_PROCESS_STEP_FINISH&apos;.       &quot;#EC NOTEXT
  l_wizard_step-text      = text-007.
  APPEND l_wizard_step TO p_wizard_steps.
*&amp;WZ_PATTERN_WIZARD_STEPS_END&amp;

ENDFORM.                    &quot; WZ_DEFINE_WIZARD_STEPS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  WZ_WIZARD_PROCESS
*&amp;---------------------------------------------------------------------*
FORM wz_wizard_process
        TABLES
           p_wizard_steps   STRUCTURE  swf_wizdef
        CHANGING
           p_subrc          TYPE       sy-subrc.

  CALL FUNCTION &apos;SWF_WIZARD_PROCESS&apos;
    EXPORTING
      container_compensation      = wizard_true
      process_logging             = wizard_true
      roadmap                     = wizard_true
      start_column                = 10
      start_row                   = 5
    TABLES
      definition                  = p_wizard_steps
    EXCEPTIONS
      operation_cancelled_by_user = 1
      process_in_error            = 2
      OTHERS                      = 3.
  p_subrc = sy-subrc.

ENDFORM.                    &quot; WZ_WIZARD_PROCESS

************************************************************************
* MODULES
************************************************************************
*&amp;---------------------------------------------------------------------*
*&amp;      Module  WZ_USER_COMMAND_WIZARD  INPUT
*&amp;---------------------------------------------------------------------*
MODULE wz_user_command_wizard INPUT.
  swf_okcode_get g_ok_code.
  g_save_ok_code = g_ok_code.
  CLEAR g_ok_code.
ENDMODULE.                 &quot; WZ_USER_COMMAND_WIZARD  INPUT</include_source>
   </include>
   <include NAME="LZTASK_WIZARDO01" VARCL="X" SUBC="I" APPL="S" RMAND="200" RLOAD="F" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LZTASK_WIZARDO01.
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Module  PBO_0200  OUTPUT
*&amp;---------------------------------------------------------------------*
*       Module Affichage Ecran 0200
*----------------------------------------------------------------------*
MODULE pbo_0200 OUTPUT.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Modification de l&apos;Affichage
  &quot; -----------------------------------------------------------

  LOOP AT SCREEN.

    &quot; Suivant le Groupe d&apos;élèment de niveau 1
    CASE screen-group1.

      WHEN &apos;100&apos;.                                           &quot;#EC NOTEXT
        &quot;&quot;  --&gt; Suivant le type de Programme cible
        CASE gs_global_data-v_subc.

          WHEN &apos;1&apos;.                                         &quot;#EC NOTEXT
            &quot; Programme Exécutable
            &quot;&quot;  --&gt; Active les Zones dépéndantes
            screen-input  = 1.

          WHEN OTHERS.
            &quot; Autres
            &quot;&quot;  --&gt; Désactive les Zones dépéndantes
            screen-input = 0.

        ENDCASE.

        &quot;&quot;  --&gt; Suivant le Groupe d&apos;élèment de niveau 2
        CASE screen-group2.

          WHEN &apos;110&apos;.                                       &quot;#EC NOTEXT
            &quot; Groupe 110 - Sous-Groupe du Niveau 1
            &quot;&quot;  --&gt; (Dés)Active le groupe en fonction de la coche d&apos;utilisation Include Prg Cadre
            screen-input = SWITCH int1( gs_global_data-s_task_wizard_data-target_framework_incl_use
              WHEN abap_true THEN 1   &quot;Zone cochée &quot;&quot; --&gt; Active la saisie
              ELSE 0                  &quot;Zone vide &quot;&quot; --&gt; Désactive la saisie
            ).

          WHEN &apos;120&apos;.
            &quot; Groupe 120 - Sous-Groupe du Niveau 1
            &quot;&quot;  --&gt; (Dés)Active le groupe en fonction de la coche d&apos;Ajout de l&apos;Ecran de Sélection
            screen-input = SWITCH int1( gs_global_data-s_task_wizard_data-target_selscreen_add
              WHEN abap_true THEN 1   &quot;Zone cochée &quot;&quot; --&gt; Active la saisie
              ELSE 0                  &quot;Zone vide &quot;&quot; --&gt; Désactive la saisie
            ).

          WHEN OTHERS.
            &quot; Autres

        ENDCASE.

        &quot;&quot;  --&gt; Suivant le Groupe d&apos;élèment de niveau 3
        CASE screen-group3.

          WHEN &apos;121&apos;.
            &quot; Groupe 121 - Sous-Groupe du Groupe 120
            &quot;&quot;  --&gt; (Dés)Active le groupe en fonction de la coche de l&apos;Utilisation Include Ecran de Sélection
            screen-input = SWITCH int1( gs_global_data-s_task_wizard_data-target_selscreen_incl_use
              WHEN abap_true THEN 1   &quot;Zone cochée &quot;&quot; --&gt; Active la saisie
              ELSE 0                  &quot;Zone vide &quot;&quot; --&gt; Désactive la saisie
            ).

          WHEN OTHERS.
            &quot; Autres

        ENDCASE.

      WHEN OTHERS.
        &quot; Autre groupe
        &quot;&quot;  --&gt; Passe à l&apos;itération suivante
        CONTINUE.

    ENDCASE.

    &quot; Modification des propriétées d&apos;affichage
    MODIFY SCREEN.

  ENDLOOP.

ENDMODULE.

*&amp;---------------------------------------------------------------------*
*&amp;      Module  PBO_0300  OUTPUT
*&amp;---------------------------------------------------------------------*
*       Module Affichage Ecran 0300
*----------------------------------------------------------------------*
MODULE pbo_0300 OUTPUT.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Affichage de l&apos;ALV
  &quot; -----------------------------------------------------------

  PERFORM 0300_alv_display.

ENDMODULE.

*&amp;---------------------------------------------------------------------*
*&amp;      Module  PBO_0400  OUTPUT
*&amp;---------------------------------------------------------------------*
*       Module Affichage Ecran 0400
*----------------------------------------------------------------------*
MODULE pbo_0400 OUTPUT.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Affichage de l&apos;ALV
  &quot; -----------------------------------------------------------

  PERFORM 0400_alv_display.

ENDMODULE.

*&amp;---------------------------------------------------------------------*
*&amp;      Module  PBO_0500  OUTPUT
*&amp;---------------------------------------------------------------------*
*       Module Affichage Ecran 0500
*----------------------------------------------------------------------*
MODULE pbo_0500 OUTPUT.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Affichage de l&apos;ALV
  &quot; -----------------------------------------------------------

  PERFORM 0500_alv_display.

ENDMODULE.

*&amp;---------------------------------------------------------------------*
*&amp;      Module  PBO_0600  OUTPUT
*&amp;---------------------------------------------------------------------*
*       Module Affichage Ecran 0600
*----------------------------------------------------------------------*
MODULE pbo_0600 OUTPUT.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Modification de l&apos;Affichage
  &quot; -----------------------------------------------------------

  LOOP AT SCREEN.

    &quot; Suivant le Groupe d&apos;élèment de niveau 1
    CASE screen-group1.

      WHEN &apos;100&apos;.
        &quot; Groupe 100
        &quot;&quot;  --&gt; Suivant le Groupe de Serveur
        screen-input = SWITCH int1( gs_global_data-s_task_wizard_data-server_default
          WHEN abap_false THEN 1   &quot;Désactive la zone si sélection Groupe de Serveur par défaut
          ELSE 0                   &quot;Active la zone si sélection manuel du Groupe de Serveur
        ).

      WHEN &apos;200&apos;.
        &quot; Groupe 200
        &quot;&quot;  --&gt; Suivant l&apos;Activation de la Compression
        screen-input = SWITCH int1( gs_global_data-s_task_wizard_data-compress_activ
          WHEN abap_true THEN 1   &quot;Compression Activée
          ELSE 0                  &quot;Compression Désactivée
        ).

      WHEN OTHERS.
        &quot; Autres
        &quot;&quot;  --&gt; Passe à l&apos;itération suivante
        CONTINUE.

    ENDCASE.

    &quot; Modification des propriétées d&apos;affichage
    MODIFY SCREEN.

  ENDLOOP.

ENDMODULE.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  0300_ALV_DISPLAY
*&amp;---------------------------------------------------------------------*
*       Affichage de l&apos;ALV
*----------------------------------------------------------------------*
FORM 0300_alv_display .

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Affichage de l&apos;ALV
  &quot; -----------------------------------------------------------

  IF NOT gs_global_data-s_alv_container-s_alv_container_0300-o_alv IS BOUND.
    TRY.
        &quot; -----------------------------------------------------------
        &quot; Initialisation de l&apos;ALV
        &quot; -----------------------------------------------------------

        &quot; Création de l&apos;instance de l&apos;ALV
        CREATE OBJECT gs_global_data-s_alv_container-s_alv_container_0300-o_alv
          EXPORTING
            iv_container_name = &apos;CC_ALV_0300&apos;.  &quot;#EC NOTEXT

      CATCH cx_create_error.
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Arrêt du traitement
        RETURN.

    ENDTRY.

    &quot; -----------------------------------------------------------
    &quot; Initialisation du FC
    &quot; -----------------------------------------------------------

    PERFORM 0300_fieldcatalog_set.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Affichage de l&apos;ALV
      &quot; -----------------------------------------------------------

      &quot; Affichage des données
      gs_global_data-s_alv_container-s_alv_container_0300-o_alv-&gt;display(
        EXPORTING
          it_fieldcatalog = gs_global_data-s_alv_container-s_alv_container_0300-t_fieldcatalog
        CHANGING
          ct_display_data = gs_global_data-s_alv_container-s_alv_container_0300-t_data
      ).

    CATCH cx_salv_call_after_1st_display.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

  ENDTRY.


ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  0300_FIELDCATALOG_SET
*&amp;---------------------------------------------------------------------*
*       Initialisation du FC
*----------------------------------------------------------------------*
FORM 0300_fieldcatalog_set.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
        ls_fieldcatalog TYPE lvc_s_fcat.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_tabledescr  TYPE REF TO cl_abap_tabledescr,
    lo_structdescr TYPE REF TO cl_abap_structdescr.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Sélection des données
  &quot; -----------------------------------------------------------

  lo_tabledescr ?= cl_abap_structdescr=&gt;describe_by_data( gs_global_data-s_alv_container-s_alv_container_0300-t_data ).
  lo_structdescr ?= lo_tabledescr-&gt;get_table_line_type( ).

  &quot;&quot;  --&gt; Initialisation du FC
  LOOP AT cl_salv_data_descr=&gt;read_structdescr( lo_structdescr )
      ASSIGNING FIELD-SYMBOL(&lt;lfs_s_dfies&gt;).

    CLEAR : ls_fieldcatalog.

    &quot; Initialisation des données
    MOVE-CORRESPONDING &lt;lfs_s_dfies&gt; TO ls_fieldcatalog.

    &quot; Initialisation de la Position
    ls_fieldcatalog-col_pos = sy-tabix.

    &quot; Initialisatino Indicateur Aide à la Recherche Disponible
    ls_fieldcatalog-f4availabl = abap_true.

    &quot; Initialisation Référence DDIC
    ls_fieldcatalog-ref_table = &apos;SRM_S_QUEUE_DEL&apos;.          &quot;#EC NOTEXT
    ls_fieldcatalog-ref_field = &apos;FUNCNAME&apos;.                 &quot;#EC NOTEXT

    &quot; Ajout de l&apos;entrée
    APPEND ls_fieldcatalog TO gs_global_data-s_alv_container-s_alv_container_0300-t_fieldcatalog.

  ENDLOOP.

ENDFORM.


*&amp;---------------------------------------------------------------------*
*&amp;      Form  0400_ALV_DISPLAY
*&amp;---------------------------------------------------------------------*
*       Affichage de l&apos;ALV
*----------------------------------------------------------------------*
FORM 0400_alv_display .

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Affichage de l&apos;ALV
  &quot; -----------------------------------------------------------

  IF NOT gs_global_data-s_alv_container-s_alv_container_0400-o_alv IS BOUND.
    TRY.
        &quot; -----------------------------------------------------------
        &quot; Initialisation de l&apos;ALV
        &quot; -----------------------------------------------------------

        &quot; Création de l&apos;instance de l&apos;ALV
        CREATE OBJECT gs_global_data-s_alv_container-s_alv_container_0400-o_alv
          EXPORTING
            iv_container_name = &apos;CC_ALV_0400&apos;.  &quot;#EC NOTEXT

      CATCH cx_create_error.
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Arrêt du traitement
        RETURN.

    ENDTRY.

    &quot; -----------------------------------------------------------
    &quot; Initialisation du FC
    &quot; -----------------------------------------------------------

    PERFORM 0400_fieldcatalog_set.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Affichage de l&apos;ALV
      &quot; -----------------------------------------------------------

      &quot; Affichage des données
      gs_global_data-s_alv_container-s_alv_container_0400-o_alv-&gt;display(
        EXPORTING
          it_fieldcatalog = gs_global_data-s_alv_container-s_alv_container_0400-t_fieldcatalog
        CHANGING
          ct_display_data = gs_global_data-s_alv_container-s_alv_container_0400-t_data
      ).

    CATCH cx_salv_call_after_1st_display.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

  ENDTRY.


ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  0400_FIELDCATALOG_SET
*&amp;---------------------------------------------------------------------*
*       Initialisation du FC
*----------------------------------------------------------------------*
FORM 0400_fieldcatalog_set.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
        ls_fieldcatalog TYPE lvc_s_fcat.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_tabledescr  TYPE REF TO cl_abap_tabledescr,
    lo_structdescr TYPE REF TO cl_abap_structdescr.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Sélection des données
  &quot; -----------------------------------------------------------

  lo_tabledescr ?= cl_abap_structdescr=&gt;describe_by_data( gs_global_data-s_alv_container-s_alv_container_0400-t_data ).
  lo_structdescr ?= lo_tabledescr-&gt;get_table_line_type( ).

  &quot;&quot;  --&gt; Initialisation du FC
  LOOP AT cl_salv_data_descr=&gt;read_structdescr( lo_structdescr )
      ASSIGNING FIELD-SYMBOL(&lt;lfs_s_dfies&gt;).

    CLEAR : ls_fieldcatalog.

    &quot; Initialisation des données
    MOVE-CORRESPONDING &lt;lfs_s_dfies&gt; TO ls_fieldcatalog.

    &quot; Initialisation de la Position
    ls_fieldcatalog-col_pos = sy-tabix.

    &quot; Initialisatino Indicateur Aide à la Recherche Disponible
    ls_fieldcatalog-f4availabl = abap_true.

    CASE &lt;lfs_s_dfies&gt;-fieldname.

      WHEN &apos;CLASSNAME&apos;.                                     &quot;#EC NOTEXT
        &quot; Classe
        &quot;&quot;  -&gt; Initialisation Référence DDIC
        ls_fieldcatalog-ref_table = &apos;EWA_EL_CLASSNAME&apos;.     &quot;#EC NOTEXT
        ls_fieldcatalog-ref_field = &apos;CLASSNAME&apos;.            &quot;#EC NOTEXT

      WHEN &apos;METHODNAME&apos;.                                    &quot;#EC NOTEXT
        &quot; Méthode
        &quot;&quot;  -&gt; Initialisation Référence DDIC
        ls_fieldcatalog-ref_table = &apos;J_3RVATDSFIGV&apos;.        &quot;#EC NOTEXT
        ls_fieldcatalog-ref_field = &apos;METHOD_VAL&apos;.           &quot;#EC NOTEXT

      WHEN OTHERS.
        &quot; Autres

    ENDCASE.

    &quot; Ajout de l&apos;entrée
    APPEND ls_fieldcatalog TO gs_global_data-s_alv_container-s_alv_container_0400-t_fieldcatalog.

  ENDLOOP.

ENDFORM.


*&amp;---------------------------------------------------------------------*
*&amp;      Form  0500_ALV_DISPLAY
*&amp;---------------------------------------------------------------------*
*       Affichage de l&apos;ALV
*----------------------------------------------------------------------*
FORM 0500_alv_display .

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Affichage de l&apos;ALV
  &quot; -----------------------------------------------------------

  IF NOT gs_global_data-s_alv_container-s_alv_container_0500-o_alv IS BOUND.
    TRY.
        &quot; -----------------------------------------------------------
        &quot; Initialisation de l&apos;ALV
        &quot; -----------------------------------------------------------

        &quot; Création de l&apos;instance de l&apos;ALV
        CREATE OBJECT gs_global_data-s_alv_container-s_alv_container_0500-o_alv
          EXPORTING
            iv_container_name = &apos;CC_ALV_0500&apos;.  &quot;#EC NOTEXT

      CATCH cx_create_error.
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Arrêt du traitement
        RETURN.

    ENDTRY.

    &quot; -----------------------------------------------------------
    &quot; Initialisation du FC
    &quot; -----------------------------------------------------------

    PERFORM 0500_fieldcatalog_set.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Affichage de l&apos;ALV
      &quot; -----------------------------------------------------------

      &quot; Affichage des données
      gs_global_data-s_alv_container-s_alv_container_0500-o_alv-&gt;display(
        EXPORTING
          it_fieldcatalog = gs_global_data-s_alv_container-s_alv_container_0500-t_fieldcatalog
        CHANGING
          ct_display_data = gs_global_data-s_alv_container-s_alv_container_0500-t_data
      ).

    CATCH cx_salv_call_after_1st_display.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

  ENDTRY.

ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  0500_FIELDCATALOG_SET
*&amp;---------------------------------------------------------------------*
*       Initialisation du FC
*----------------------------------------------------------------------*
FORM 0500_fieldcatalog_set.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
        ls_fieldcatalog TYPE lvc_s_fcat.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_tabledescr  TYPE REF TO cl_abap_tabledescr,
    lo_structdescr TYPE REF TO cl_abap_structdescr.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Sélection des données
  &quot; -----------------------------------------------------------

  lo_tabledescr ?= cl_abap_structdescr=&gt;describe_by_data( gs_global_data-s_alv_container-s_alv_container_0500-t_data ).
  lo_structdescr ?= lo_tabledescr-&gt;get_table_line_type( ).

  &quot;&quot;  --&gt; Initialisation du FC
  LOOP AT cl_salv_data_descr=&gt;read_structdescr( lo_structdescr )
      ASSIGNING FIELD-SYMBOL(&lt;lfs_s_dfies&gt;).

    CLEAR : ls_fieldcatalog.

    &quot; Initialisation des données
    MOVE-CORRESPONDING &lt;lfs_s_dfies&gt; TO ls_fieldcatalog.

    &quot; Initialisation de la Position
    ls_fieldcatalog-col_pos = sy-tabix.

    &quot; Initialisatino Indicateur Aide à la Recherche Disponible
    ls_fieldcatalog-f4availabl = abap_true.

    CASE &lt;lfs_s_dfies&gt;-fieldname.

      WHEN &apos;REPID&apos;.                                         &quot;#EC NOTEXT
        &quot; Progamme
        &quot;&quot;  -&gt; Initialisation Référence DDIC
        ls_fieldcatalog-ref_table = &apos;TRDIR&apos;.       &quot;#EC NOTEXT
        ls_fieldcatalog-ref_field = &apos;NAME&apos;.                 &quot;#EC NOTEXT

      WHEN OTHERS.
        &quot; Autres

    ENDCASE.

    &quot; Ajout de l&apos;entrée
    APPEND ls_fieldcatalog TO gs_global_data-s_alv_container-s_alv_container_0500-t_fieldcatalog.

  ENDLOOP.

ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  USR_WIZARD_RETURN_DATA_SET
*&amp;---------------------------------------------------------------------*
*       Initialisation données de sortie
*----------------------------------------------------------------------*
*      &lt;-- ES_TASK_WIZARD_DATA        Données Wizard
*----------------------------------------------------------------------*
FORM usr_wizard_return_data_set CHANGING es_task_wizard_data TYPE ztec_s_task_wizard_data.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
        ls_task_call_process TYPE ztec_s_task_call_process.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR : es_task_wizard_data.

  &quot; -----------------------------------------------------------
  &quot; Initialisation données de sortie
  &quot; -----------------------------------------------------------

  &quot; Initialisation données communes
  es_task_wizard_data = gs_global_data-s_task_wizard_data.

  &quot; Réconfiguration données liées au Radio-Boutton
  IF gs_global_data-s_task_wizard_data-compress_activ EQ abap_false.
    &quot; Compression Inactive
    &quot;&quot;  --&gt; Réinitialisation Mode de Compression
    CLEAR : es_task_wizard_data-compress_mode.

  ENDIF.

  &quot; Alimentation table des traitements MF
  LOOP AT gs_global_data-s_alv_container-s_alv_container_0300-t_data ASSIGNING FIELD-SYMBOL(&lt;lfs_s_data_0300&gt;).

    CLEAR : ls_task_call_process.

    &quot; Initialisation
    ls_task_call_process-function_name = &lt;lfs_s_data_0300&gt;-funcname.

    &quot; Ajout de l&apos;entrée
    APPEND ls_task_call_process TO es_task_wizard_data-t_task_call_process.

  ENDLOOP.

  &quot; Alimentation table des traitements Méthode
  LOOP AT gs_global_data-s_alv_container-s_alv_container_0400-t_data ASSIGNING FIELD-SYMBOL(&lt;lfs_s_data_0400&gt;).

    CLEAR : ls_task_call_process.

    &quot; Initialisation
    ls_task_call_process-class_name  = &lt;lfs_s_data_0400&gt;-classname.
    ls_task_call_process-method_name = &lt;lfs_s_data_0400&gt;-methodname.

    &quot; Ajout de l&apos;entrée
    APPEND ls_task_call_process TO es_task_wizard_data-t_task_call_process.

  ENDLOOP.

  &quot; Alimentation table des traitements Programme
  LOOP AT gs_global_data-s_alv_container-s_alv_container_0500-t_data ASSIGNING FIELD-SYMBOL(&lt;lfs_s_data_0500&gt;).

    CLEAR : ls_task_call_process.

    &quot; Initialisation
    ls_task_call_process-repid_name = &lt;lfs_s_data_0500&gt;-repid.

    &quot; Ajout de l&apos;entrée
    APPEND ls_task_call_process TO es_task_wizard_data-t_task_call_process.

  ENDLOOP.

ENDFORM.</include_source>
   </include>
   <include NAME="LZTASK_WIZARDP01" VARCL="X" SUBC="I" APPL="S" RMAND="200" RLOAD="F" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LZTASK_WIZARDP01.
*----------------------------------------------------------------------*


*----------------------------------------------------------------------*
*       CLASS LCL_ALV_HANDLER_GENERIC IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_alv_handler_generic IMPLEMENTATION.

  METHOD constructor.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Initialisation des Attributs
    &quot; -----------------------------------------------------------

    &quot; Initialisation attribut
    me-&gt;mo_alv_grid      = io_alv_grid.
    me-&gt;mot_display_data = iot_display_data.

    &quot; -----------------------------------------------------------
    &quot; Souscription aux évènements
    &quot; -----------------------------------------------------------

    me-&gt;event_register( ).

  ENDMETHOD.

  METHOD event_register.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Souscription aux évènement
    &quot; -----------------------------------------------------------

    &quot; Handler  Aide à la recherche
    SET HANDLER me-&gt;handler_onf4 FOR me-&gt;mo_alv_grid.

    &quot; Handler Toolbar
    SET HANDLER me-&gt;handler_toolbar FOR me-&gt;mo_alv_grid.

    &quot; Handler Clique bouton
    SET HANDLER me-&gt;handler_button_click FOR me-&gt;mo_alv_grid.

    &quot; Handler Double clique
    SET HANDLER me-&gt;handler_double_click FOR me-&gt;mo_alv_grid.

    &quot; Handler Action Utilisateur
    SET HANDLER me-&gt;handler_user_command FOR me-&gt;mo_alv_grid.

    &quot; Handler clique HotSpot
    SET HANDLER me-&gt;handler_hotspot_click FOR me-&gt;mo_alv_grid.

    &quot; Handler Modification des données
    SET HANDLER me-&gt;handler_data_changed FOR me-&gt;mo_alv_grid.

    &quot; Handler Fin modification des données
    SET HANDLER me-&gt;handler_data_changed_finished FOR me-&gt;mo_alv_grid.

    &quot; -----------------------------------------------------------
    &quot; Modification de l&apos;évèment d&apos;Edition
    &quot; -----------------------------------------------------------

    &quot; A chaque modification
    CALL METHOD me-&gt;mo_alv_grid-&gt;register_edit_event
      EXPORTING
        i_event_id = cl_gui_alv_grid=&gt;mc_evt_modified.

    &quot; Lors de l&apos;Appui sur Entrée
    CALL METHOD me-&gt;mo_alv_grid-&gt;register_edit_event
      EXPORTING
        i_event_id = cl_gui_alv_grid=&gt;mc_evt_enter.

  ENDMETHOD.

  METHOD handler_user_command.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Sélection des données
    &quot; -----------------------------------------------------------



  ENDMETHOD.

  METHOD handler_toolbar.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Sélection des données
    &quot; -----------------------------------------------------------



  ENDMETHOD.

  METHOD handler_button_click.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Initialisation des Attributs
    &quot; -----------------------------------------------------------

  ENDMETHOD.

  METHOD handler_data_changed.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
    DATA :
          lt_row_id TYPE SORTED TABLE OF sy-tabix WITH UNIQUE KEY table_line.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
    DATA :
          ls_bapiret2 TYPE bapiret2.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
    DATA :
          lv_protocol_display TYPE xsdboolean.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Contrôle saisie
    &quot; -----------------------------------------------------------

    LOOP AT er_data_changed-&gt;mt_mod_cells
      ASSIGNING FIELD-SYMBOL(&lt;lfs_s_mod_cells&gt;).

      CLEAR : ls_bapiret2.

      &quot; Suivant le champ modifié
      CASE &lt;lfs_s_mod_cells&gt;-fieldname.

        WHEN &apos;FUNCNAME&apos;.                                    &quot;#EC NOTEXT
          &quot; Module Fonction
          IF NOT &lt;lfs_s_mod_cells&gt;-value IS INITIAL.
            &quot;&quot;  --&gt; Contrôle sur MF saisis
            ls_bapiret2 = me-&gt;__funcname_check( &lt;lfs_s_mod_cells&gt; ).

          ENDIF.

        WHEN &apos;CLASSNAME&apos; OR &apos;METHODNAME&apos;.                   &quot;#EC NOTEXT
          &quot; Classe / Méthode
          IF NOT line_exists( lt_row_id[ &lt;lfs_s_mod_cells&gt;-row_id ] ).
            &quot; Ligne non contrôlée
            &quot;&quot;  --&gt; Contrôle sur Classe / Méthode (les deux sont dépendants l&apos;un de l&apos;autre)
            ls_bapiret2 = me-&gt;__methodname_check(
              is_mod_cells    = &lt;lfs_s_mod_cells&gt;   &quot;Fourni
              ir_data_changed = er_data_changed
            ).

            &quot;&quot;  --&gt; Ajout de la ligne
            INSERT &lt;lfs_s_mod_cells&gt;-row_id INTO TABLE lt_row_id.

          ENDIF.

        WHEN OTHERS.
          &quot; Autres

      ENDCASE.

      IF NOT ls_bapiret2 IS INITIAL.
        &quot; Message initialisé
        &quot;&quot;  --&gt; Ajout du message dans le Protocole
        er_data_changed-&gt;add_protocol_entry(
          EXPORTING
            i_msgid     = ls_bapiret2-id
            i_msgty     = ls_bapiret2-type
            i_msgno     = ls_bapiret2-number
            i_msgv1     = ls_bapiret2-message_v1
            i_msgv2     = ls_bapiret2-message_v2
            i_msgv3     = ls_bapiret2-message_v3
            i_msgv4     = ls_bapiret2-message_v4
            i_fieldname = &lt;lfs_s_mod_cells&gt;-fieldname
            i_row_id    = ls_bapiret2-row
            i_tabix     = ls_bapiret2-row
        ).

        &quot;&quot;  --&gt; Initialisation indicateur Affichage Protocole
        lv_protocol_display = abap_true.

      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD __funcname_check.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
    DATA :
          lv_count TYPE sy-dbcnt.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Contrôle sur le MF
    &quot; -----------------------------------------------------------

    &quot; Pour être éligible le MF doit remplir les Conditions suivantes :
    &quot;   - Exister
    &quot;   - Pas de paramètre de type &quot;REF TO&quot;

    &quot; -----------------------------------------------------------
    &quot; Contrôle l&apos;existence du MF
    &quot; -----------------------------------------------------------

    &quot; Contrôle existence du MF
    SELECT SINGLE funcname FROM tfdir   &quot;Entrée bufférisée
                          WHERE funcname EQ @is_mod_cells-value
                           INTO @DATA(lv_funcname).
    IF sy-subrc NE 0.
      &quot; Le MF n&apos;existe pas
      &quot;&quot;  --&gt; Retourne le message
      rs_return-id         = &apos;3G&apos;.                          &quot;#EC NOTEXT
      rs_return-row        = is_mod_cells-row_id.
      rs_return-type       = gc_display_like.               &quot;#EC NOTEXT
      rs_return-number     = 733.
      rs_return-message_v1 = is_mod_cells-value.

      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Contrôle des paramètres du MF
    &quot; -----------------------------------------------------------

    &quot; Contrôle présence de paramètre non éligible
    SELECT COUNT( * ) FROM fupararef
     WHERE funcname  EQ @lv_funcname
       AND ref_class EQ @abap_true
      INTO @lv_count.
    IF lv_count GT 0.
      &quot; Au moins un paramètre Référence
      &quot;&quot;  --&gt; Retourne le message
      rs_return-id     = &apos;FL&apos;.                              &quot;#EC NOTEXT
      rs_return-row    = is_mod_cells-row_id.
      rs_return-type   = gc_display_like.                   &quot;#EC NOTEXT
      rs_return-number = 393.

      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

  ENDMETHOD.

  METHOD __methodname_check.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
    DATA :
      lv_cmpname TYPE seocompodf-cmpname,
      lv_clsname TYPE seocompodf-clsname.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
    FIELD-SYMBOLS :
      &lt;lfs_s_mod_cells&gt;    TYPE lvc_s_modi,
      &lt;lfs_t_display_data&gt; TYPE tt_alv_display_data_0400.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Contrôle la Méthode saisie
    &quot; -----------------------------------------------------------

    &quot; Pour être éligible la méthode doit remplir les Conditions suivantes :
    &quot;   - Exister
    &quot;   - Être public
    &quot;   - Être Statique
    &quot;   - Pas de paramètre de type &quot;REF TO&quot;

    &quot; -----------------------------------------------------------
    &quot; Initialisation des variables
    &quot; -----------------------------------------------------------

    &quot; Suivant le champ modifié
    CASE is_mod_cells-fieldname.

      WHEN &apos;CLASSNAME&apos;.                                     &quot;#EC NOTEXT
        &quot; Modification de la Classe
        &quot;&quot;  --&gt; Initialisation Nom de la Classe
        lv_clsname = is_mod_cells-value.

        &quot;&quot;  --&gt; Récupération de la Méthode associée
        READ TABLE ir_data_changed-&gt;mt_mod_cells WITH KEY row_id    = is_mod_cells-row_id
                                                          fieldname = &apos;METHODNAME&apos; &quot;#EC NOTEXT
                                                ASSIGNING &lt;lfs_s_mod_cells&gt;.
        IF sy-subrc EQ 0.
          &quot; Correspondance trouvée
          &quot;&quot;  --&gt; Initialisation Nom de la Méthode
          lv_cmpname = &lt;lfs_s_mod_cells&gt;-value.

        ELSE.
          &quot; Pas dans les données modifiées
          &quot;&quot;  --&gt; Récupération dans les données déjà saisies
          ASSIGN ir_data_changed-&gt;mp_mod_rows-&gt;* TO &lt;lfs_t_display_data&gt;.
          IF sy-subrc EQ 0.
            TRY.
                &quot; Récupération Nom de la Méthode dans données validées
                lv_cmpname = &lt;lfs_t_display_data&gt;[ is_mod_cells-row_id ]-methodname.

              CATCH cx_sy_itab_line_not_found.
                &quot; Entrée non trouvée

            ENDTRY.

          ENDIF.

        ENDIF.

      WHEN &apos;METHODNAME&apos;.                                    &quot;#EC NOTEXT
        &quot; Modification de la Méthode
        &quot;&quot;  --&gt; Initialisation Nom de la Méthode
        lv_cmpname = is_mod_cells-value.

        &quot;&quot;  --&gt; Récupération de la Classe associée
        READ TABLE ir_data_changed-&gt;mt_mod_cells WITH KEY row_id    = is_mod_cells-row_id
                                                          fieldname = &apos;CLASSNAME&apos; &quot;#EC NOTEXT
                                                ASSIGNING &lt;lfs_s_mod_cells&gt;.
        IF sy-subrc EQ 0.
          &quot; Correspondance trouvée
          &quot;&quot;  --&gt; Initialisation Nom de la Classe
          lv_clsname = &lt;lfs_s_mod_cells&gt;-value.

        ELSE.
          &quot; Pas dans les données modifiées
          &quot;&quot;  --&gt; Récupération dans les données déjà saisies
          ASSIGN ir_data_changed-&gt;mp_mod_rows-&gt;* TO &lt;lfs_t_display_data&gt;.
          IF sy-subrc EQ 0.
            TRY.
                &quot; Récupération Nom de la Méthode dans données validées
                lv_clsname = &lt;lfs_t_display_data&gt;[ is_mod_cells-row_id ]-classname.

              CATCH cx_sy_itab_line_not_found.
                &quot; Entrée non trouvée

            ENDTRY.

          ENDIF.

        ENDIF.

      WHEN OTHERS.
        &quot; Autre

    ENDCASE.

    &quot; Contrôle données récupérées
    IF lv_clsname IS INITIAL AND lv_cmpname IS INITIAL.
      &quot; Aucune saisie
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ELSE.
      IF lv_clsname IS INITIAL
      OR lv_cmpname IS INITIAL.
        &quot; Pas de Méthode saisie ou pas de Classe
        &quot;&quot;  --&gt; Initialisation message de retour
        rs_return-type = gc_display_like.
        rs_return-row  = is_mod_cells-row_id.

        IF lv_clsname IS INITIAL.
          &quot; Classe non saisie
          &quot;&quot;  --&gt; Initialisation variable dépendante
          rs_return-id     = &apos;ZTASK&apos;.                       &quot;#EC NOTEXT
          rs_return-number = 602.

        ELSE.
          &quot; Méthode non saisie
          &quot;&quot;  --&gt; Initialisation variable dépendante
          rs_return-id     = &apos;ZTASK&apos;.                       &quot;#EC NOTEXT
          rs_return-number = 603.

        ENDIF.

        &quot;&quot;  --&gt; Arrêt du traitement
        RETURN.

      ENDIF.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Contrôle existence de la Méthode
    &quot; -----------------------------------------------------------

    &quot; Contrôle existence Méthode
    SELECT SINGLE version  FROM seocompodf
            WHERE clsname    EQ @lv_clsname
              AND cmpname    EQ @lv_cmpname
              AND version    EQ &apos;1&apos; &quot;Actif &quot;#EC NOTEXT
              AND exposure   EQ &apos;2&apos; &quot;Publique &quot;#EC NOTEXT
              AND mtddecltyp EQ &apos;1&apos; &quot;Statique &quot;#EC NOTEXT
             INTO @DATA(lv_version).
    IF sy-subrc NE 0.
      &quot; Méthode non éligible
      &quot;&quot;  --&gt; Retourne message d&apos;erreur
      rs_return-id         = &apos;ZTASK&apos;.                       &quot;#EC NOTEXT
      rs_return-number     = 601.
      rs_return-message_v1 = lv_clsname.
      rs_return-message_v2 = lv_cmpname.

      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Contrôle les paramètres de la Méthode
    &quot; -----------------------------------------------------------

    &quot; Contrôle les paramètres de la Méthode
    SELECT COUNT( * ) FROM seosubcodf
                     WHERE clsname EQ @lv_clsname
                       AND cmpname EQ @lv_cmpname
                       AND typtype EQ &apos;3&apos;  &quot;Type REF To &quot;#EC NOTEXT
                      INTO @DATA(lv_count).
    IF lv_count GT 0.
      &quot; Au moins un paramètre Référence
      &quot;&quot;  --&gt; Retourne le message
      rs_return-id     = &apos;UBD_REMOTE&apos;.                      &quot;#EC NOTEXT
      rs_return-row    = is_mod_cells-row_id.
      rs_return-type   = gc_display_like.                   &quot;#EC NOTEXT
      rs_return-number = 003.

      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

  ENDMETHOD.

  METHOD handler_data_changed_finished.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Initialisation des Attributs
    &quot; -----------------------------------------------------------


  ENDMETHOD.

  METHOD handler_double_click.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Initialisation des Attributs
    &quot; -----------------------------------------------------------

  ENDMETHOD.

  METHOD handler_hotspot_click.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Initialisation des Attributs
    &quot; -----------------------------------------------------------


  ENDMETHOD.

  METHOD handler_onf4.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Initialisation des Attributs
    &quot; -----------------------------------------------------------

  ENDMETHOD.

ENDCLASS.


*----------------------------------------------------------------------*
*       CLASS LCL_ALV_GENERIC IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_alv_generic IMPLEMENTATION.

  METHOD constructor.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
    DATA :
          ls_textid TYPE scx_t100key.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Initialisation des Attributs
    &quot; -----------------------------------------------------------

    &quot; Initialisation Toolbar
    me-&gt;toolbar_set( ).

    &quot; Initialisation du Layout
    me-&gt;ms_display_element-display_element-s_layout-edit  = abap_true.
    me-&gt;ms_display_element-display_element-s_layout-zebra = abap_true.

    &quot; Création du Custom Container
    CREATE OBJECT me-&gt;ms_display_element-display_element-o_ccontainer
      EXPORTING
        container_name              = iv_container_name
      EXCEPTIONS
        cntl_error                  = 1
        cntl_system_error           = 2
        create_error                = 3
        lifetime_error              = 4
        lifetime_dynpro_dynpro_link = 5
        OTHERS                      = 6.
    IF sy-subrc EQ 0.
      &quot; Création de la Grille ALV
      CREATE OBJECT me-&gt;ms_display_element-display_element-o_alv_grid
        EXPORTING
          i_parent          = me-&gt;ms_display_element-display_element-o_ccontainer
          i_appl_events     = abap_true
        EXCEPTIONS
          error_cntl_create = 1
          error_cntl_init   = 2
          error_cntl_link   = 3
          error_dp_create   = 4
          OTHERS            = 5.

    ENDIF.

    IF sy-subrc NE 0.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Lève une Exception
      ls_textid-msgid = sy-msgid. ls_textid-msgno = sy-msgno.
      ls_textid-attr1 = sy-msgv1. ls_textid-attr2 = sy-msgv2.
      ls_textid-attr3 = sy-msgv3. ls_textid-attr4 = sy-msgv4.
      RAISE EXCEPTION TYPE cx_create_error
        EXPORTING
          textid = ls_textid.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Gestion des évènements
    &quot; -----------------------------------------------------------

    &quot; Création de l&apos;Instance Handler d&apos;Evènement
    CREATE OBJECT me-&gt;ms_display_element-display_element-o_event
      EXPORTING
        io_alv_grid      = me-&gt;ms_display_element-display_element-o_alv_grid
        iot_display_data = me-&gt;ms_display_element-data-t_display_data.

  ENDMETHOD.

  METHOD check.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; ---------------------------------------------------- -------
    &quot; Affichage de l&apos;ALV
    &quot; -----------------------------------------------------------

    &quot; Contrôle les données saisies
    me-&gt;ms_display_element-display_element-o_alv_grid-&gt;check_changed_data(
      IMPORTING
        e_valid = rv_error
    ).

    &quot; Inverse le booléen
    rv_error = boolc( rv_error EQ abap_false ).

  ENDMETHOD.

  METHOD toolbar_set.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Exclusion des Fonctions de la Toolbar
    &quot; -----------------------------------------------------------

    APPEND cl_gui_alv_grid=&gt;mc_fc_sum             TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_info            TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_sort            TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_find            TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_print           TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_graph           TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_check           TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_count           TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_detail          TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_subtot          TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_filter          TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_refresh         TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_refresh         TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_pc_file         TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_call_xxl        TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_sort_asc        TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_sort_dsc        TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_find_more       TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_view_excel      TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_print_prev      TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_print_back      TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_call_report     TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.
    APPEND cl_gui_alv_grid=&gt;mc_fc_current_variant TO me-&gt;ms_display_element-display_element-t_toolbar_excluding.

  ENDMETHOD.

  METHOD display.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    IF me-&gt;mv_first_display_done EQ abap_false.
      &quot; -----------------------------------------------------------
      &quot; Initialisation des élèments d&apos;Affichage
      &quot; -----------------------------------------------------------

      me-&gt;display_element_set(
        EXPORTING
          it_fieldcatalog = it_fieldcatalog
        CHANGING
          ct_display_data = ct_display_data
      ).

    ENDIF.

    TRY.
        &quot; -----------------------------------------------------------
        &quot; Affichage des données
        &quot; -----------------------------------------------------------

        &quot; Affichage de l&apos;ALV
        me-&gt;__display( ).

      CATCH cx_salv_call_after_1st_display INTO DATA(lo_cx_exception).
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Lève l&apos;Exception
        RAISE EXCEPTION TYPE cx_salv_call_after_1st_display
          EXPORTING
            previous = lo_cx_exception.

    ENDTRY.

  ENDMETHOD.

  METHOD __display.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
    DATA :
          ls_textid TYPE scx_t100key.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
    FIELD-SYMBOLS :
                   &lt;lfs_t_outtab&gt; TYPE STANDARD TABLE.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Affichage de l&apos;ALV
    &quot; -----------------------------------------------------------

    IF me-&gt;mv_first_display_done EQ abap_false.
      &quot; Premier Affichage
      &quot;&quot;  --&gt; Initialisation pointeur sur données à Afficher
      ASSIGN me-&gt;ms_display_element-data-t_display_data-&gt;* TO &lt;lfs_t_outtab&gt;.
      IF sy-subrc NE 0.
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Arrêt du traitement
        RETURN.

      ENDIF.

      &quot;&quot;  --&gt; Affichage de l&apos;ALV
      me-&gt;ms_display_element-display_element-o_alv_grid-&gt;set_table_for_first_display(
        EXPORTING
          is_layout                     = me-&gt;ms_display_element-display_element-s_layout
          it_toolbar_excluding          = me-&gt;ms_display_element-display_element-t_toolbar_excluding
        CHANGING
          it_outtab                     = &lt;lfs_t_outtab&gt;
          it_fieldcatalog               = me-&gt;ms_display_element-display_element-t_fieldcatalog
        EXCEPTIONS
          invalid_parameter_combination = 1
          program_error                 = 2
          too_many_lines                = 3
          OTHERS                        = 4
      ).
      IF sy-subrc NE 0.
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Lève une Exception
        ls_textid-msgid = sy-msgid. ls_textid-msgno = sy-msgno.
        ls_textid-attr1 = sy-msgv1. ls_textid-attr2 = sy-msgv2.
        ls_textid-attr3 = sy-msgv3. ls_textid-attr4 = sy-msgv4.
        RAISE EXCEPTION TYPE cx_salv_call_after_1st_display
          EXPORTING
            textid = ls_textid.

      ENDIF.

      &quot;&quot;  --&gt; Initialisation Indicateur First Display fait
      me-&gt;mv_first_display_done = abap_true.

    ENDIF.

    &quot; Active l&apos;édition
    me-&gt;ms_display_element-display_element-o_alv_grid-&gt;set_ready_for_input( 1 ).

  ENDMETHOD.

  METHOD display_element_set.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Initialisation du FieldCatalog
    &quot; -----------------------------------------------------------

    IF it_fieldcatalog      IS SUPPLIED
    AND NOT it_fieldcatalog IS INITIAL.
      &quot; FieldCatalog fourni
      &quot;&quot;  --&gt; Utilisation de ce FC
      me-&gt;ms_display_element-display_element-t_fieldcatalog[] = it_fieldcatalog[].

    ELSE.
      &quot; FieldCatalog non fourni
      &quot;&quot;  --&gt; Récupération structure d&apos;affichage
      me-&gt;fieldcatalog_generic_set( ct_display_data ).

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Initialisation Table
    &quot; -----------------------------------------------------------

    me-&gt;ms_display_element-data-t_display_data = REF #( ct_display_data ).

  ENDMETHOD.

  METHOD fieldcatalog_generic_set.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
    DATA :
          ls_fieldcatalog TYPE lvc_s_fcat.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
    DATA :
      lo_tabledescr  TYPE REF TO cl_abap_tabledescr,
      lo_structdescr TYPE REF TO cl_abap_structdescr.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Sélection des données
    &quot; -----------------------------------------------------------

    lo_tabledescr ?= cl_abap_structdescr=&gt;describe_by_data( it_display_data ).
    lo_structdescr ?= lo_tabledescr-&gt;get_table_line_type( ).

    &quot;&quot;  --&gt; Initialisation du FC
    LOOP AT cl_salv_data_descr=&gt;read_structdescr( lo_structdescr )
        ASSIGNING FIELD-SYMBOL(&lt;lfs_s_dfies&gt;).

      CLEAR : ls_fieldcatalog.

      &quot; Initialisation des données
      MOVE-CORRESPONDING &lt;lfs_s_dfies&gt; TO ls_fieldcatalog.

      &quot; Initialisation de la Position
      ls_fieldcatalog-col_pos = sy-tabix.

      &quot; Ajout de l&apos;entrée
      APPEND ls_fieldcatalog TO me-&gt;ms_display_element-display_element-t_fieldcatalog.

    ENDLOOP.

  ENDMETHOD.

ENDCLASS.</include_source>
   </include>
   <include NAME="LZTASK_WIZARDTOP" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RMAND="200" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
    <include_source>FUNCTION-POOL ztask_wizard.                    &quot;MESSAGE-ID ..

* wizard system include (do not remove)
INCLUDE &lt;wizard&gt;.

************************************************************************
* Wizard:
*   general data
************************************************************************
DATA:
  g_ok_code      TYPE sy-ucomm,
  g_save_ok_code TYPE sy-ucomm,
  g_error        TYPE sy-input.



************************************************************************
* Userdefined wizard data
************************************************************************
*&amp;WZ_PATTERN_INCLUDE_USER_DATA&amp;

CLASS lcl_alv_generic DEFINITION DEFERRED.
CLASS lcl_alv_handler_generic DEFINITION DEFERRED.

TYPES :
  BEGIN OF ts_alv_display_data_0300,
    funcname TYPE rs38l_fnam,
  END OF   ts_alv_display_data_0300.

TYPES : tt_alv_display_data_0300 TYPE STANDARD TABLE OF ts_alv_display_data_0300
        WITH NON-UNIQUE KEY primary_key COMPONENTS funcname.

TYPES :
  BEGIN OF ts_alv_display_data_0400,
    classname  TYPE seoclsname,
    methodname TYPE seocpdname,
  END OF   ts_alv_display_data_0400.

TYPES : tt_alv_display_data_0400 TYPE STANDARD TABLE OF ts_alv_display_data_0400
        WITH NON-UNIQUE KEY primary_key COMPONENTS classname methodname.

TYPES :
  BEGIN OF ts_alv_display_data_0500,
    repid TYPE trdir-name,
  END OF   ts_alv_display_data_0500.

TYPES : tt_alv_display_data_0500 TYPE STANDARD TABLE OF ts_alv_display_data_0500
        WITH NON-UNIQUE KEY primary_key COMPONENTS repid.

TYPES :
  BEGIN OF ts_alv_container_0300,
    o_alv          TYPE REF TO lcl_alv_generic,
    t_data         TYPE tt_alv_display_data_0300,
    t_fieldcatalog TYPE lvc_t_fcat,
  END OF   ts_alv_container_0300.

TYPES :
  BEGIN OF ts_alv_container_0400,
    o_alv          TYPE REF TO lcl_alv_generic,
    t_data         TYPE tt_alv_display_data_0400,
    t_fieldcatalog TYPE lvc_t_fcat,
  END OF   ts_alv_container_0400.

TYPES :
  BEGIN OF ts_alv_container_0500,
    o_alv          TYPE REF TO lcl_alv_generic,
    t_data         TYPE tt_alv_display_data_0500,
    t_fieldcatalog TYPE lvc_t_fcat,
  END OF   ts_alv_container_0500.

TYPES :
  BEGIN OF ts_alv_container,
    s_alv_container_0300 TYPE ts_alv_container_0300,
    s_alv_container_0400 TYPE ts_alv_container_0400,
    s_alv_container_0500 TYPE ts_alv_container_0500,
  END OF   ts_alv_container.

TYPES :
  BEGIN OF ts_global_data,
    v_subc              TYPE reposrc-subc,
    v_target_repid_last TYPE sy-repid,
    s_alv_container     TYPE ts_alv_container,
    s_task_wizard_data  TYPE ztec_s_task_wizard_data,
  END OF   ts_global_data.

DATA : gs_global_data TYPE ts_global_data.


CONSTANTS : gc_display_like TYPE sy-msgty VALUE &apos;E&apos;.        &quot;#EC NOTEXT</include_source>
   </include>
   <include NAME="LZTASK_WIZARDUSR" VARCL="X" SUBC="I" LEVL="740" RMAND="000" RLOAD="D" LDBNAME="D$S" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LSWZ_WIZARD_TEMPLATEUSR .
*----------------------------------------------------------------------*

*&amp;---------------------------------------------------------------------*
*&amp;      FORM  USR_INITIALIZA_WIZARD_DATA
*&amp;---------------------------------------------------------------------*
*     --&gt; IV_TARGET_REPID       Programme Cadre
*     &lt;-- ES_GLOBAL_DATA        Données Globales
*&amp;---------------------------------------------------------------------*
FORM usr_initialize_wizard_data USING iv_target_repid TYPE sy-repid
                             CHANGING es_global_data  TYPE ts_global_data.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
        lv_error TYPE sy-input.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

  CLEAR : es_global_data.

  &quot; -----------------------------------------------------------
  &quot; Initialisation valeur par défaut
  &quot; -----------------------------------------------------------

  &quot; Initialisation Programme Cadre par défaut
  es_global_data-s_task_wizard_data-target_repid = iv_target_repid.
  IF iv_target_repid(1) EQ &apos;Z&apos;.                             &quot;#EC NOTEXT
    &quot; Programme spécifique
    &quot;&quot;  --&gt; Modification des variables dépéndantes du Programme
    SELECT SINGLE subc FROM tadir
                 INNER JOIN reposrc
                         ON reposrc~progname EQ tadir~obj_name
                      WHERE pgmid    EQ &apos;R3TR&apos;              &quot;#EC NOTEXT
                        AND object   EQ &apos;PROG&apos;              &quot;#EC NOTEXT
                        AND obj_name EQ @iv_target_repid
                       INTO @es_global_data-v_subc.

  ENDIF.

  &quot; Sélection du Groupe de Serveur manuel
  es_global_data-s_task_wizard_data-server_user    = abap_true.
  es_global_data-s_task_wizard_data-server_default = abap_false.

  &quot; Initialisation Nombre de Tâche
  es_global_data-s_task_wizard_data-task_max = 5.

  &quot; Initialisation Mode Gestion Include Cadriciel
  es_global_data-s_task_wizard_data-target_selscreen_incl_data-include_create = abap_true.
  es_global_data-s_task_wizard_data-target_selscreen_incl_data-include_change = abap_false.

  &quot; Initialisation Mode Gestion Include Ecran de Sélection
  es_global_data-s_task_wizard_data-target_framework_incl_data-include_create = abap_true.
  es_global_data-s_task_wizard_data-target_framework_incl_data-include_change = abap_false.

  &quot; Initialisation Options Supplémentaires
  es_global_data-s_task_wizard_data-shm_management = abap_true.
  es_global_data-s_task_wizard_data-compress_activ = abap_true.
  es_global_data-s_task_wizard_data-compress_mode-data_compress_line_by_line = abap_true.

  &quot; Initialisation Programme Template
  es_global_data-s_task_wizard_data-task_class_replace  = &apos;LCL_TASK&apos;. &quot;#EC NOTEXT
  es_global_data-s_task_wizard_data-task_template_repid = &apos;ZTASK_TEMPLATE&apos;. &quot;#EC NOTEXT

ENDFORM.                    &quot; USR_INITIALIZE_WIZARD_DATA
*&amp;---------------------------------------------------------------------*
*&amp;      FORM  USR_PROCESS_WIZARD_DATA
*&amp;---------------------------------------------------------------------*
FORM usr_process_wizard_data.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

*** process global data collected by wizard

ENDFORM.                    &quot; USR_PROCESS_WIZARD_DATA

***==================================================================***
**                              0200                                  **
***==================================================================***

*&amp;--------------------------------------------------------------*
*&amp;      Form  USR_SET_SUBSCREEN_DATA_0200
*&amp;--------------------------------------------------------------*
FORM usr_set_subscreen_data_0200.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

ENDFORM.                    &quot; USR_SET_SUBSCREEN_DATA_0200
*&amp;--------------------------------------------------------------*
*&amp;      Form  USR_GET_SUBSCREEN_DATA_0200
*&amp;--------------------------------------------------------------*
FORM usr_get_subscreen_data_0200.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

ENDFORM.                    &quot; USR_GET_SUBSCREEN_DATA_0200
*&amp;--------------------------------------------------------------*
*&amp;      Module  USR_CHECK_CONSISTENCY_0200
*&amp;--------------------------------------------------------------*
MODULE usr_check_consistency_0200 INPUT.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

  &quot; -----------------------------------------------------------
  &quot; Traitement après Action Utilisateur
  &quot; -----------------------------------------------------------

  &quot; Suivant l&apos;Action utilisateur
  CASE g_save_ok_code.

    WHEN wizard_command_continue.
      &quot; L&apos;utilisateur appuie sur &quot;Continuer&quot;
      &quot;&quot;  --&gt; Contrôle saisie utilisateur
      PERFORM usr_check_consistency_0200 CHANGING g_error.

    WHEN &apos;SEL_ADD&apos;                                          &quot;#EC NOTEXT
      OR &apos;SEL_INCL_U&apos;.                                      &quot;#EC NOTEXT
      &quot; Ajout des paramètres dans l&apos;Ecran de Sélection
      &quot;&quot;  --&gt; Modification des variables dépéndantes du Programme
      PERFORM target_selscreen_data_set USING gs_global_data-s_task_wizard_data-target_repid
                                     CHANGING g_error.

    WHEN &apos;TASK_INCL_U&apos;.                                     &quot;#EC NOTEXT
      &quot; Utilisation Include Cadriciel
      &quot;&quot;  --&gt; Modification des variables dépéndantes du Programme
      PERFORM target_framework_data_set USING gs_global_data-s_task_wizard_data-target_repid
                                     CHANGING g_error.

    WHEN &apos;SEL_INCL_R&apos;.                                      &quot;#EC NOTEXT
      &quot; Modif. Radio-Boutton Include Ecran de Sélection
      &quot;&quot;  --&gt; Contrôle cohérence sur Include Ecran de Sélection
      PERFORM target_selscreen_incl_check CHANGING g_error.

    WHEN &apos;TASK_INCL_R&apos;.                                     &quot;#EC NOTEXT
      &quot; Modif. Radio-Boutton Include Cadriciel
      &quot;&quot;  --&gt; Contrôle cohérence sur Include Cadriciel
      PERFORM target_framework_incl_check CHANGING g_error.

    WHEN OTHERS.
      &quot; Autres commande
      IF gs_global_data-s_task_wizard_data-target_repid NE gs_global_data-v_target_repid_last.
        &quot; -----------------------------------------------------------
        &quot; Traitement après modification du Programme Cadre
        &quot; -----------------------------------------------------------

        &quot; Modification du Programme Cadre
        &quot;&quot;  --&gt; Contrôle Programme Cadre
        PERFORM target_repid_check USING gs_global_data-s_task_wizard_data-target_repid
                                CHANGING gs_global_data-v_subc
                                         g_error.

        IF g_error IS INITIAL.
          &quot; Modification des variables dépéndantes du Programme
          PERFORM repid_dependent_var_set USING gs_global_data-s_task_wizard_data-target_repid
                                       CHANGING g_error.

        ENDIF.

        &quot;&quot;  --&gt; Modification du dernier Programme Cadre saisie
        gs_global_data-v_target_repid_last = gs_global_data-s_task_wizard_data-target_repid.

      ENDIF.

  ENDCASE.

  &quot; -----------------------------------------------------------
  &quot; Traitement de Fin
  &quot; -----------------------------------------------------------

  IF NOT g_error IS INITIAL.
    &quot; Une erreur est survenue
    &quot;&quot;  --&gt; ??
    swf_refresh.

  ENDIF.

ENDMODULE.                  &quot; USR_CHECK_CONSISTENCY_0200 INPUT

*&amp;--------------------------------------------------------------*
*&amp;      Form  USR_CHECK_CONSISTENCY_0200
*&amp;--------------------------------------------------------------*
FORM usr_check_consistency_0200 CHANGING p_error TYPE sy-input.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

* here we check if all entries on this screen are consistent
* (field checks have to be done on the screen, not here)

* initialize error indicator
  CLEAR: p_error, gs_global_data-v_subc.

  &quot; -----------------------------------------------------------
  &quot; Contrôle saisie utilisateur sur Programme Cadre
  &quot; -----------------------------------------------------------

  &quot; Contrôle Programme Cadre
  PERFORM target_repid_check USING gs_global_data-s_task_wizard_data-target_repid
                          CHANGING gs_global_data-v_subc
                                   p_error.

  IF  p_error IS INITIAL
  AND gs_global_data-s_task_wizard_data-target_selscreen_add EQ abap_true
  AND gs_global_data-s_task_wizard_data-target_selscreen_incl_use EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Contrôle cohérence Include Ecran de Sélection
    &quot; -----------------------------------------------------------

    &quot; Contrôle Cohérence Include Ecran de Sélection
    PERFORM target_selscreen_incl_check CHANGING p_error.

  ENDIF.

  IF p_error IS INITIAL
  AND gs_global_data-s_task_wizard_data-target_framework_incl_use EQ abap_true.
    &quot; -----------------------------------------------------------
    &quot; Contrôle cohérence Include Cadriciel
    &quot; -----------------------------------------------------------

    &quot; Contrôle Cohérence Include Cadriciel
    PERFORM target_framework_incl_check CHANGING p_error.

  ENDIF.

  IF p_error IS INITIAL.
    &quot; -----------------------------------------------------------
    &quot; Contrôle programme Template
    &quot; -----------------------------------------------------------

    &quot; Contrôle existence programme Template
    PERFORM task_template_repid_check USING gs_global_data-s_task_wizard_data-task_template_repid
                                   CHANGING p_error.

  ENDIF.

  IF p_error EQ abap_true.
    &quot; Une erreur est survenue
    &quot;&quot;  --&gt; Arrêt du traitemtn
    RETURN.

  ENDIF.

ENDFORM.                    &quot; USR_CHECK_CONSISTENCY_0200

***==================================================================***
**                              0300                                  **
***==================================================================***

*&amp;--------------------------------------------------------------*
*&amp;      Form  USR_SET_SUBSCREEN_DATA_0300
*&amp;--------------------------------------------------------------*
FORM usr_set_subscreen_data_0300.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

ENDFORM.                    &quot; USR_SET_SUBSCREEN_DATA_0300
*&amp;--------------------------------------------------------------*
*&amp;      Form  USR_GET_SUBSCREEN_DATA_0300
*&amp;--------------------------------------------------------------*
FORM usr_get_subscreen_data_0300.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

ENDFORM.                    &quot; USR_GET_SUBSCREEN_DATA_0300
*&amp;--------------------------------------------------------------*
*&amp;      Module  USR_CHECK_CONSISTENCY_0300
*&amp;--------------------------------------------------------------*
MODULE usr_check_consistency_0300 INPUT.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

  &quot; -----------------------------------------------------------
  &quot; Traitement après Action Utilisateur
  &quot; -----------------------------------------------------------

  &quot; Suivant l&apos;Action utilisateur
  CASE g_save_ok_code.

    WHEN wizard_command_continue.
      &quot; L&apos;utilisateur appuie sur &quot;Continuer&quot;
      &quot;&quot;  --&gt; Contrôle saisie utilisateur
      PERFORM usr_check_consistency_0300 CHANGING g_error.

    WHEN OTHERS.
      &quot; Autres commande

  ENDCASE.

  &quot; -----------------------------------------------------------
  &quot; Traitement de Fin
  &quot; -----------------------------------------------------------

  IF NOT g_error IS INITIAL.
    &quot; Une erreur est survenue
    &quot;&quot;  --&gt; Reste sur l&apos;écran actuel
    swf_refresh.

  ENDIF.

ENDMODULE.                  &quot; USR_CHECK_CONSISTENCY_0300 INPUT
*&amp;--------------------------------------------------------------*
*&amp;      Form  USR_CHECK_CONSISTENCY_0300
*&amp;--------------------------------------------------------------*
FORM usr_check_consistency_0300 CHANGING p_error TYPE sy-input.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

* here we check if all entries on this screen are consistent
* (field checks have to be done on the screen, not here)

* initialize error indicator
  CLEAR: p_error.

  &quot; -----------------------------------------------------------
  &quot; Contrôle sur les données saisies
  &quot; -----------------------------------------------------------

  p_error = gs_global_data-s_alv_container-s_alv_container_0300-o_alv-&gt;check( ).

ENDFORM.                    &quot; USR_CHECK_CONSISTENCY_0300

***==================================================================***
**                              0400                                  **
***==================================================================***

*&amp;--------------------------------------------------------------*
*&amp;      Form  USR_SET_SUBSCREEN_DATA_0400
*&amp;--------------------------------------------------------------*
FORM usr_set_subscreen_data_0400.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

ENDFORM.                    &quot; USR_SET_SUBSCREEN_DATA_0400
*&amp;--------------------------------------------------------------*
*&amp;      Form  USR_GET_SUBSCREEN_DATA_0400
*&amp;--------------------------------------------------------------*
FORM usr_get_subscreen_data_0400.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

ENDFORM.                    &quot; USR_GET_SUBSCREEN_DATA_0400
*&amp;--------------------------------------------------------------*
*&amp;      Module  USR_CHECK_CONSISTENCY_0400
*&amp;--------------------------------------------------------------*
MODULE usr_check_consistency_0400 INPUT.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

  &quot; -----------------------------------------------------------
  &quot; Traitement après Action Utilisateur
  &quot; -----------------------------------------------------------

  &quot; Suivant l&apos;Action utilisateur
  CASE g_save_ok_code.

    WHEN wizard_command_continue.
      &quot; L&apos;utilisateur appuie sur &quot;Continuer&quot;
      &quot;&quot;  --&gt; Contrôle saisie utilisateur
      PERFORM usr_check_consistency_0400 CHANGING g_error.

    WHEN OTHERS.
      &quot; Autres commande

  ENDCASE.

  &quot; -----------------------------------------------------------
  &quot; Traitement de Fin
  &quot; -----------------------------------------------------------

  IF NOT g_error IS INITIAL.
    &quot; Une erreur est survenue
    &quot;&quot;  --&gt; Reste sur l&apos;écran actuel
    swf_refresh.

  ENDIF.

ENDMODULE.                  &quot; USR_CHECK_CONSISTENCY_0400 INPUT
*&amp;--------------------------------------------------------------*
*&amp;      Form  USR_CHECK_CONSISTENCY_0400
*&amp;--------------------------------------------------------------*
FORM usr_check_consistency_0400 CHANGING p_error TYPE sy-input.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

* here we check if all entries on this screen are consistent
* (field checks have to be done on the screen, not here)

* initialize error indicator
  CLEAR: p_error.

ENDFORM.                    &quot; USR_CHECK_CONSISTENCY_0400

***==================================================================***
**                              0500                                  **
***==================================================================***

*&amp;--------------------------------------------------------------*
*&amp;      Form  USR_SET_SUBSCREEN_DATA_0500
*&amp;--------------------------------------------------------------*
FORM usr_set_subscreen_data_0500.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

ENDFORM.                    &quot; USR_SET_SUBSCREEN_DATA_0500

*&amp;--------------------------------------------------------------*
*&amp;      Form  USR_GET_SUBSCREEN_DATA_0500
*&amp;--------------------------------------------------------------*
FORM usr_get_subscreen_data_0500.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

ENDFORM.                    &quot; USR_GET_SUBSCREEN_DATA_0500

*&amp;--------------------------------------------------------------*
*&amp;      Module  USR_CHECK_CONSISTENCY_0500
*&amp;--------------------------------------------------------------*
MODULE usr_check_consistency_0500 INPUT.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

  &quot; -----------------------------------------------------------
  &quot; Traitement après Action Utilisateur
  &quot; -----------------------------------------------------------

  &quot; Suivant l&apos;Action utilisateur
  CASE g_save_ok_code.

    WHEN wizard_command_continue.
      &quot; L&apos;utilisateur appuie sur &quot;Continuer&quot;
      &quot;&quot;  --&gt; Contrôle saisie utilisateur
      PERFORM usr_check_consistency_0500 CHANGING g_error.

    WHEN OTHERS.
      &quot; Autres commande

  ENDCASE.

  &quot; -----------------------------------------------------------
  &quot; Traitement de Fin
  &quot; -----------------------------------------------------------

  IF NOT g_error IS INITIAL.
    &quot; Une erreur est survenue
    &quot;&quot;  --&gt; Reste sur l&apos;écran actuel
    swf_refresh.

  ENDIF.

ENDMODULE.                  &quot; USR_CHECK_CONSISTENCY_0500 INPUT

*&amp;--------------------------------------------------------------*
*&amp;      Form  USR_CHECK_CONSISTENCY_0500
*&amp;--------------------------------------------------------------*
FORM usr_check_consistency_0500 CHANGING p_error TYPE sy-input.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

* here we check if all entries on this screen are consistent
* (field checks have to be done on the screen, not here)

* initialize error indicator
  CLEAR: p_error.

ENDFORM.                    &quot; USR_CHECK_CONSISTENCY_0500

***==================================================================***
**                              0600                                  **
***==================================================================***

*&amp;--------------------------------------------------------------*
*&amp;      Form  USR_SET_SUBSCREEN_DATA_0600
*&amp;--------------------------------------------------------------*
FORM usr_set_subscreen_data_0600.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

ENDFORM.                    &quot; USR_SET_SUBSCREEN_DATA_0600

*&amp;--------------------------------------------------------------*
*&amp;      Form  USR_GET_SUBSCREEN_DATA_0600
*&amp;--------------------------------------------------------------*
FORM usr_get_subscreen_data_0600.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

ENDFORM.                    &quot; USR_GET_SUBSCREEN_DATA_0600

*&amp;--------------------------------------------------------------*
*&amp;      Module  USR_CHECK_CONSISTENCY_0600
*&amp;--------------------------------------------------------------*
MODULE usr_check_consistency_0600 INPUT.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

  &quot; -----------------------------------------------------------
  &quot; Traitement après Action Utilisateur
  &quot; -----------------------------------------------------------

  &quot; Suivant l&apos;Action utilisateur
  CASE g_save_ok_code.

    WHEN wizard_command_continue.
      &quot; L&apos;utilisateur appuie sur &quot;Continuer&quot;
      &quot;&quot;  --&gt; Contrôle saisie utilisateur
      PERFORM usr_check_consistency_0600 CHANGING g_error.

    WHEN OTHERS.
      &quot; Autres commande

  ENDCASE.

  &quot; -----------------------------------------------------------
  &quot; Traitement de Fin
  &quot; -----------------------------------------------------------

  IF NOT g_error IS INITIAL.
    &quot; Une erreur est survenue
    &quot;&quot;  --&gt; Reste sur l&apos;écran actuel
    swf_refresh.

  ENDIF.

ENDMODULE.                  &quot; USR_CHECK_CONSISTENCY_0600 INPUT

*&amp;--------------------------------------------------------------*
*&amp;      Form  USR_CHECK_CONSISTENCY_0600
*&amp;--------------------------------------------------------------*
FORM usr_check_consistency_0600 CHANGING p_error TYPE sy-input.

***===========================================================***
**                       TRAITEMENT                            **
***===========================================================***

* here we check if all entries on this screen are consistent
* (field checks have to be done on the screen, not here)

* initialize error indicator
  CLEAR: p_error.

  IF gs_global_data-s_task_wizard_data-server_user EQ abap_true.
    &quot; Groupe de Serveur choisi manuellement
    &quot;&quot;  --&gt; Contrôle Groupe de Serveur saisie
    PERFORM grfc_check CHANGING p_error.

  ENDIF.

ENDFORM.                    &quot; USR_CHECK_CONSISTENCY_0600

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GRFC_CHECK
*&amp;---------------------------------------------------------------------*
*       Contrôle Groupe de Serveur
*----------------------------------------------------------------------*
*      &lt;-- EV_ERROR             Erreur
*----------------------------------------------------------------------*
FORM grfc_check CHANGING ev_error TYPE sy-input.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR : ev_error.

  IF gs_global_data-s_task_wizard_data-grfc IS INITIAL.
    &quot; Serveur choisi par l&apos;Utilisateur mais non renseigné
    &quot;&quot;  --&gt; Affiche message d&apos;erreur
    MESSAGE i122(b1) DISPLAY LIKE gc_display_like.

    &quot;&quot;  --&gt; Retourne Code en erreur
    ev_error = abap_true.

  ELSE.
    &quot; Contrôle existence et statut du Groupe de Serveur
    SELECT SINGLE classname
             FROM rzllitab
            WHERE classname EQ @gs_global_data-s_task_wizard_data-grfc
             INTO @DATA(lv_classname).
    IF sy-subrc NE 0.
      &quot; Aucune Correspondance
      &quot;&quot;  --&gt; Affiche message d&apos;erreur
      MESSAGE i063(8z) WITH gs_global_data-s_task_wizard_data-grfc DISPLAY LIKE gc_display_like.

      &quot;&quot;  --&gt; Retourne Code en erreur
      ev_error = abap_true.

    ENDIF.

  ENDIF.

ENDFORM.


*&amp;---------------------------------------------------------------------*
*&amp;      Form  TARGET_REPID_CHECK
*&amp;---------------------------------------------------------------------*
*       Contrôle Programme Cadre
*----------------------------------------------------------------------*
*      --&gt; IV_TARGET_REPID      Programme Cible
*      &lt;-- EV_ERROR             Erreur
*      &lt;-- EV_SUBC              Type de Programme
*----------------------------------------------------------------------*
FORM target_repid_check USING iv_target_repid TYPE sy-repid
                     CHANGING ev_subc         TYPE reposrc-subc
                              ev_error        TYPE sy-input.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
        lv_subrc TYPE sy-subrc.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR : ev_error, ev_subc.

  &quot; -----------------------------------------------------------
  &quot; Contrôle saisie utilisateur sur Programme Cadre
  &quot; -----------------------------------------------------------

  IF |{ iv_target_repid(1) CASE = UPPER }| NE &apos;Z&apos;.          &quot;#EC NOTEXT
    &quot; Pas un programme spécifique
    &quot;&quot;  --&gt; Affiche message d&apos;erreur
    MESSAGE i074(bt) WITH iv_target_repid DISPLAY LIKE gc_display_like. &quot;#EC NOTEXT

    &quot;&quot;  --&gt; Initialisation code retour en erreur
    ev_error = abap_true.

    &quot;&quot; --&gt; Arrêt du traitement
    RETURN.

  ELSE.
    &quot; Programme spécifique
    &quot;&quot;  --&gt; Contrôle existence
    SELECT SINGLE subc FROM tadir
                 INNER JOIN reposrc
                         ON reposrc~progname EQ tadir~obj_name
                      WHERE pgmid    EQ &apos;R3TR&apos;              &quot;#EC NOTEXT
                        AND object   EQ &apos;PROG&apos;              &quot;#EC NOTEXT
                        AND obj_name EQ @iv_target_repid
                       INTO @ev_subc.
    IF sy-subrc NE 0.
      &quot; Programme inexistant
      &quot;&quot;  --&gt; Affiche message d&apos;erreur
      MESSAGE i541(00) WITH iv_target_repid DISPLAY LIKE gc_display_like. &quot;#EC NOTEXT

      &quot;&quot;  --&gt; Initialisation code retour en erreur
      ev_error = abap_true.

      &quot;&quot; --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

    IF iv_target_repid EQ gs_global_data-s_task_wizard_data-task_template_repid.
      &quot; Programme Cadre = Template Cadriciel
      &quot;&quot;  --&gt; Affiche message d&apos;erreur
      MESSAGE i604(ztask) DISPLAY LIKE gc_display_like.

      &quot;&quot;  --&gt; Initialisation code retour en erreur
      ev_error = abap_true.

      &quot;&quot; --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

  ENDIF.

ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  TASK_TEMPLATE_REPID_CHECK
*&amp;---------------------------------------------------------------------*
*       Contrôle saisie Programme Template
*----------------------------------------------------------------------*
*      --&gt; IV_TASK_TEMPLATE_REPID   Programme contenant le Template
*      &lt;-- EV_ERROR                 Erreur ?
*----------------------------------------------------------------------*
FORM task_template_repid_check USING iv_task_template_repid TYPE sy-repid
                            CHANGING ev_error               TYPE sy-input.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR : ev_error.

  &quot; -----------------------------------------------------------
  &quot; Contrôle programme Template
  &quot; -----------------------------------------------------------

  &quot; Contrôle existence programme Template
  SELECT SINGLE obj_name FROM tadir
                        WHERE pgmid    EQ &apos;R3TR&apos;            &quot;#EC NOTEXT
                          AND object   EQ &apos;PROG&apos;            &quot;#EC NOTEXT
                          AND obj_name EQ @iv_task_template_repid
                         INTO @DATA(lv_obj_name).
  IF sy-subrc NE 0.
    &quot; Programme inexistant
    &quot;&quot;  --&gt; Affiche message d&apos;erreur
    MESSAGE a541(00) WITH iv_task_template_repid.    &quot;Aborted

    &quot;&quot;  --&gt; Initialisation code retour en erreur
    ev_error = abap_true.

  ENDIF.

ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  TARGET_SELSCREEN_DATA_SET
*&amp;---------------------------------------------------------------------*
*       Modification des données liées à l&apos;Include Ecran de Sélection
*----------------------------------------------------------------------*
*      --&gt; IV_TARGET_REPID      Programme Cadre
*      &lt;-- EV_ERROR             Erreur ?
*----------------------------------------------------------------------*
FORM target_selscreen_data_set USING iv_target_repid TYPE sy-repid
                            CHANGING ev_error        TYPE sy-input.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_subc      TYPE reposrc-subc,
    lv_iteration TYPE numc2.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  IF gs_global_data-s_task_wizard_data-target_selscreen_add EQ abap_false.
    &quot; Pas d&apos;Ajout Ecran de Sélection
    &quot;&quot;  --&gt; Réinitialisation données liées
    CLEAR : gs_global_data-s_task_wizard_data-target_selscreen_incl_data-include_name,
            gs_global_data-s_task_wizard_data-target_selscreen_incl_use.

  ELSEIF gs_global_data-s_task_wizard_data-target_selscreen_incl_use EQ abap_false.
    &quot; Pas d&apos;Utilisation d&apos;Include
    &quot;&quot;  --&gt; Réinitialisation données liées
    CLEAR : gs_global_data-s_task_wizard_data-target_selscreen_incl_data-include_name.

  ELSE.
    &quot; Utilisation d&apos;Include
    IF gs_global_data-s_task_wizard_data-target_selscreen_incl_data-include_create EQ abap_true.
      &quot;&quot;  --&gt; Récupération Nombre d&apos;Itération d&apos;Include Ecran de Sélection
      DATA(lv_progname) = |{ iv_target_repid }_SEL%|.       &quot;#EC NOTEXT
      SELECT COUNT( * ) FROM reposrc WHERE progname LIKE @lv_progname
                                      INTO @DATA(lv_count).
      IF sy-subrc NE 0.
        &quot; Include inexistant
        &quot;&quot;  --&gt; Initialisation Nom par défaut
        lv_progname = |{ iv_target_repid }_SEL|.            &quot;#EC NOTEXT

      ELSE.
        &quot; Include Existant
        &quot;&quot;  --&gt; Initialisation Nom Incrémenter
        lv_iteration = lv_count + 1.
        lv_progname  = |{ iv_target_repid }_SEL{ lv_iteration WIDTH = 2 }|. &quot;#EC NOTEXT

      ENDIF.

      &quot; Initialisation Nom de l&apos;Include à utiliser
      gs_global_data-s_task_wizard_data-target_selscreen_incl_data-include_name = lv_progname.

      IF strlen( gs_global_data-s_task_wizard_data-target_selscreen_incl_data-include_name ) GT 30.
        &quot; Nom généré supérieur à la limite standard
        &quot;&quot;  --&gt; Tronque la racine du Programme
        gs_global_data-s_task_wizard_data-target_selscreen_incl_data-include_name =
          |{ iv_target_repid(24) }_SEL{ lv_iteration WIDTH = 2 }|. &quot;#EC NOTEXT

      ENDIF.

      &quot;&quot;  --&gt; Contrôle Nom du Programme généré
      PERFORM repid_name_check USING gs_global_data-s_task_wizard_data-target_selscreen_incl_data-include_name
                            CHANGING ev_error.

    ELSE.
      &quot; Utilisation Include existant
      &quot;&quot;  --&gt; Contrôle existence de l&apos;Include
      PERFORM target_repid_check USING gs_global_data-s_task_wizard_data-target_selscreen_incl_data-include_name
                              CHANGING lv_subc
                                       ev_error.

    ENDIF.

  ENDIF.

ENDFORM.


*&amp;---------------------------------------------------------------------*
*&amp;      Form  TARGET_FRAMEWORK_DATA_SET
*&amp;---------------------------------------------------------------------*
*       Modification des données liées à l&apos;Include Cadriciel
*----------------------------------------------------------------------*
*      --&gt; IV_TARGET_REPID      Programme Cadre
*      &lt;-- EV_ERROR             Erreur ?
*----------------------------------------------------------------------*
FORM target_framework_data_set USING iv_target_repid TYPE sy-repid
                            CHANGING ev_error        TYPE sy-input.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_subc      TYPE reposrc-subc,
    lv_iteration TYPE numc2.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Gestion de l&apos;Include Cadriciel
  &quot; -----------------------------------------------------------

  IF gs_global_data-s_task_wizard_data-target_framework_incl_use EQ abap_false.
    &quot; Pas d&apos;utilisation d&apos;Include
    &quot;&quot;  --&gt; Réinitialisation données liées
    CLEAR : gs_global_data-s_task_wizard_data-target_framework_incl_data-include_name.

  ELSE.
    &quot; Utilisation d&apos;Include
    IF gs_global_data-s_task_wizard_data-target_framework_incl_data-include_create EQ abap_true.
      &quot; Création d&apos;Include
      &quot;&quot;  --&gt; Récupération Nombre d&apos;Itération d&apos;Include Classe
      DATA(lv_progname) = |{ iv_target_repid }_C%|.         &quot;#EC NOTEXT
      SELECT COUNT( * ) FROM reposrc WHERE progname LIKE @lv_progname
                                      INTO @DATA(lv_count).

      &quot;&quot;  --&gt; Incrément du numéro d&apos;Include
      lv_iteration = lv_count + 1.

      &quot;&quot;  --&gt; Modification Nom par défaut nouvel Include
      gs_global_data-s_task_wizard_data-target_framework_incl_data-include_name =
        |{ iv_target_repid }_C{ lv_iteration WIDTH = 2 }|.  &quot;#EC NOTEXT
      IF strlen( gs_global_data-s_task_wizard_data-target_framework_incl_data-include_name ) GT 30.
        &quot; Nom généré supérieur à la limite standard
        &quot;&quot;  --&gt; Tronque la racine du Programme
        gs_global_data-s_task_wizard_data-target_framework_incl_data-include_name =
           |{ iv_target_repid(26) }_C{ lv_iteration WIDTH = 2 }|. &quot;#EC NOTEXT

      ENDIF.

      &quot;&quot;  --&gt; Contrôle Nom du Programme généré
      PERFORM repid_name_check USING gs_global_data-s_task_wizard_data-target_framework_incl_data-include_name
                            CHANGING ev_error.

    ELSE.
      &quot; Utilisation Include existant
      &quot;&quot;  --&gt; Contrôle existence de l&apos;Include
      PERFORM target_repid_check USING gs_global_data-s_task_wizard_data-target_framework_incl_data-include_name
                              CHANGING lv_subc
                                       ev_error.

    ENDIF.

  ENDIF.

ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  TARGET_FRAMEWORK_INCL_CHECK
*&amp;---------------------------------------------------------------------*
*       Contrôle données liées à l&apos;Include Cadriciel
*----------------------------------------------------------------------*
*      &lt;-- EV_ERROR             Erreur ?
*----------------------------------------------------------------------*
FORM target_framework_incl_check CHANGING ev_error TYPE sy-input.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR : ev_error.

  &quot; -----------------------------------------------------------
  &quot; Contrôle Include Cadriciel
  &quot; -----------------------------------------------------------

  IF gs_global_data-s_task_wizard_data-target_framework_incl_use EQ abap_true
  AND gs_global_data-s_task_wizard_data-target_framework_incl_data-include_name
      IS INITIAL.
    &quot; Include à utiliser mais non renseigné
    &quot;&quot;  --&gt; Affiche message d&apos;erreur
    MESSAGE i607(ztask) DISPLAY LIKE gc_display_like.       &quot;#EC NOTEXT

  ENDIF.

  &quot; Contrôle Cohérence Include Cadriciel
  PERFORM target_incl_check USING gs_global_data-s_task_wizard_data-target_framework_incl_data
                         CHANGING ev_error.

ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  TARGET_SELSCREEN_INCL_CHECK
*&amp;---------------------------------------------------------------------*
*       Contrôle données liées à l&apos;Include Cadriciel
*----------------------------------------------------------------------*
*      &lt;-- EV_ERROR             Erreur ?
*----------------------------------------------------------------------*
FORM target_selscreen_incl_check CHANGING ev_error TYPE sy-input.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR : ev_error.

  &quot; -----------------------------------------------------------
  &quot; Contrôle Include Ecran de Sélection
  &quot; -----------------------------------------------------------

  IF gs_global_data-s_task_wizard_data-target_selscreen_incl_use EQ abap_true
  AND gs_global_data-s_task_wizard_data-target_selscreen_incl_data-include_name
      IS INITIAL.
    &quot; Include à utiliser mais non renseigné
    &quot;&quot;  --&gt; Affiche message d&apos;erreur
    MESSAGE i607(ztask) DISPLAY LIKE gc_display_like.       &quot;#EC NOTEXT

    &quot;&quot;  --&gt; Initialisation code retour en erreur
    ev_error = abap_true.

  ENDIF.

  &quot; Contrôle Cohérence Include Ecran de Sélection
  PERFORM target_incl_check USING gs_global_data-s_task_wizard_data-target_selscreen_incl_data
                         CHANGING ev_error.

ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  TARGET_INCL_CHECK
*&amp;---------------------------------------------------------------------*
*       Contrôle cohérence de l&apos;Include
*----------------------------------------------------------------------*
*      &lt;-- EV_ERROR             Erreur ?
*----------------------------------------------------------------------*
FORM target_incl_check USING is_include_data TYPE ztec_s_task_wizard_incl
                    CHANGING ev_error   TYPE sy-input.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR : ev_error.

  &quot; -----------------------------------------------------------
  &quot; Contrôle Include
  &quot; -----------------------------------------------------------

  IF is_include_data-include_name IS INITIAL.
    &quot; Pas de programme
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ELSEIF is_include_data-include_name(1) NE &apos;Z&apos;.            &quot;#EC NOTEXT
    &quot; Include non spécifique
    &quot;&quot;  --&gt; Affiche message d&apos;erreur
    MESSAGE i074(bt) WITH is_include_data-include_name DISPLAY LIKE gc_display_like. &quot;#EC NOTEXT

    &quot;&quot;  --&gt; Initialisation code retour en erreur
    ev_error = abap_true.

    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; Recherche présence de l&apos;Include en DB
  SELECT SINGLE progname FROM reposrc
                        WHERE progname EQ @is_include_data-include_name
                         INTO @DATA(lv_progname).

  IF is_include_data-include_create EQ abap_true.
    &quot; Création de l&apos;Include
    IF NOT lv_progname IS INITIAL.
      &quot; L&apos;Include existe déjà
      &quot;&quot;  --&gt; Affiche message d&apos;erreur
      MESSAGE i608(ztask) WITH lv_progname DISPLAY LIKE gc_display_like. &quot;#EC NOTEXT

      &quot;&quot;  --&gt; Initialisation code retour en erreur
      ev_error = abap_true.

      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

  ELSE.
    &quot; Ajout de l&apos;Include
    IF lv_progname IS INITIAL.
      &quot; L&apos;include n&apos;existe pas
      &quot;&quot;  --&gt; Affiche message d&apos;erreur
      MESSAGE i609(ztask) WITH is_include_data-include_name DISPLAY LIKE gc_display_like. &quot;#EC NOTEXT

      &quot;&quot;  --&gt; Initialisation code retour en erreur
      ev_error = abap_true.

      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

  ENDIF.

ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  REPID_DEPENDENT_VAR_SET
*&amp;---------------------------------------------------------------------*
*       Modification des variables dépendantes du Programme Cadre
*----------------------------------------------------------------------*
*      --&gt; IV_TARGET_REPID      Programme Cadre
*      &lt;-- EV_ERROR             Erreur ?
*----------------------------------------------------------------------*
FORM repid_dependent_var_set USING iv_target_repid TYPE sy-repid
                          CHANGING ev_error        TYPE sy-input.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_progname  TYPE reposrc-progname,
    lv_iteration TYPE numc2.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR :
    gs_global_data-s_task_wizard_data-target_framework_incl_data-include_name,
    gs_global_data-s_task_wizard_data-target_selscreen_incl_data-include_name,
    ev_error.

  &quot; -----------------------------------------------------------
  &quot; Gestion de l&apos;Include Cadriciel
  &quot; -----------------------------------------------------------

  &quot; Initialisation données Include Cadriciel
  PERFORM target_framework_data_set USING iv_target_repid
                                 CHANGING ev_error.

  &quot; -----------------------------------------------------------
  &quot; Gestion de l&apos;Include Ecran de Sélection
  &quot; -----------------------------------------------------------

  &quot; Initialisation données Include Ecran de Sélection
  PERFORM target_selscreen_data_set USING iv_target_repid
                                 CHANGING ev_error.

ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  REPID_NAME_CHECK
*&amp;---------------------------------------------------------------------*
*       Contrôle Programme
*----------------------------------------------------------------------*
*      --&gt; IV_REPID     Programme à contrôler
*      &lt;-- EV_ERROR     Erreur ?
*----------------------------------------------------------------------*
FORM repid_name_check USING iv_repid TYPE sy-repid
                   CHANGING ev_error TYPE sy-input.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle Nom du Programme
  &quot; -----------------------------------------------------------

  &quot; Contrôle Nom Programme spécifié
  CALL FUNCTION &apos;RS_PROGRAM_CHECK_NAME&apos;
    EXPORTING
      check_string_only            = abap_true
      progname                     = iv_repid
    EXCEPTIONS
      database                     = 1
      database_selections          = 2
      function_group               = 3
      function_include             = 4
      no_customer_function_group   = 5
      no_customer_function_include = 6
      reserved_name                = 7
      reserved_name_customer       = 8
      string_error                 = 9
      string_warning               = 10
      string_length_error          = 11
      types_program                = 12
      reserved_name_menu           = 13
      OTHERS                       = 14.
  IF sy-subrc NE 0.
    &quot; Une erreur est survenue
    &quot;&quot;  --&gt; Retourne Code d&apos;erreur
    ev_error = boolc( NOT sy-subrc IS INITIAL ). &quot;Vrai si Erreur surveue

    &quot;&quot;  --&gt; Affiche message d&apos;erreur
    MESSAGE ID sy-msgid TYPE &apos;W&apos; NUMBER sy-msgno            &quot;#EC NOTEXT
                                   WITH sy-msgv1 sy-msgv2
                                        sy-msgv3 sy-msgv4
                                DISPLAY LIKE gc_display_like. &quot;#EC NOTEXT

  ENDIF.

ENDFORM.</include_source>
   </include>
  </includeprograms>
  <functionmodules>
   <functionmodule NAME="WZ_ZTASK_WIZARD_START" STEXT="Start Wizard">
    <importing PARAMETER="IV_REPID_DEFAULT" OPTIONAL="X" TYP="SY-REPID"/>
    <exporting PARAMETER="ES_TASK_WIZARD_DATA" REFERENCE="X" TYP="ZTEC_S_TASK_WIZARD_DATA"/>
    <exceptions EXCEPTION="CANCELLED_BY_USER"/>
    <exceptions EXCEPTION="ERROR"/>
    <documentation PARAMETER="IV_REPID_DEFAULT" KIND="P" INDEX=" 001"/>
    <documentation PARAMETER="ES_TASK_WIZARD_DATA" KIND="P" STEXT="Tâche - Données Assistant" INDEX=" 002"/>
    <documentation PARAMETER="CANCELLED_BY_USER" KIND="X" INDEX=" 003"/>
    <documentation PARAMETER="ERROR" KIND="X" STEXT="Error occurred while performing wizard transactions" INDEX=" 004"/>
    <fm_source>***------------------------------------------------------------------***
**                             INCLUDE                                **
***------------------------------------------------------------------***

*----------------- do not remove this include --------------------------
  INCLUDE &lt;sbpt_wizard&gt;.
*----------------- do not remove this include --------------------------

* begin of local data definition
  DATA:
    l_wizard_steps TYPE STANDARD TABLE OF swf_wizdef,
    l_subrc        TYPE sy-subrc.
* end of local data definition

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR : es_task_wizard_data.
  CLEAR : gs_global_data.

  &quot; -----------------------------------------------------------
  &quot; Initialisation des Etapes
  &quot; -----------------------------------------------------------

  &quot; Initialisation des Etapes de traitement
  PERFORM wz_define_wizard_steps TABLES l_wizard_steps.

  &quot; -----------------------------------------------------------
  &quot; Initialisation des données
  &quot; -----------------------------------------------------------

  &quot; Initialisation des données
  PERFORM usr_initialize_wizard_data USING iv_repid_default
                                  CHANGING gs_global_data.

  &quot; -----------------------------------------------------------
  &quot; Déroulement des Etapes
  &quot; -----------------------------------------------------------

  &quot; Déroulement des Etapes
  PERFORM wz_wizard_process TABLES l_wizard_steps
                          CHANGING l_subrc.

  &quot; Suivant le code retour
  CASE l_subrc.

    WHEN 0.
      &quot; Fin de l&apos;utilisation
      &quot;&quot;  --&gt; Initialisation données de sortie
      PERFORM usr_wizard_return_data_set CHANGING es_task_wizard_data.

    WHEN 1.
      &quot; Interruption
      MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno          &quot;#EC NOTEXT
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
              RAISING cancelled_by_user.
    WHEN 2.
      &quot; Une erreur est survenue
      MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno          &quot;#EC NOTEXT
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
              RAISING error.

  ENDCASE.</fm_source>
    <functionModuleDocumentation/>
   </functionmodule>
  </functionmodules>
 </FUGR>
 <INTF CLSNAME="ZIF_TASK_CONSTANT" VERSION="1" LANGU="F" DESCRIPT="Interface Tâche" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <types CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="TS_FUNCTION_PARAMETERS" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="10 " SRCCOLUMN2="34 " TYPESRC_LENG="237 " TYPESRC="BEGIN OF ts_function_parameters,
      parameter_name               TYPE        string,
      parameter_data               TYPE REF TO data,
      type_for_none_ddic_parameter TYPE        string,
    END OF   ts_function_parameters
"/>
  <types CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="TT_FUNCTION_PARAMETERS" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="12 " SRCCOLUMN1="4 " SRCROW2="13 " SRCCOLUMN2="106 " TYPESRC_LENG="177 " TYPESRC="tt_function_parameters TYPE SORTED TABLE OF ts_function_parameters
                                                  WITH NON-UNIQUE KEY primary_key COMPONENTS parameter_name
"/>
  <types CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="TS_TASK_ATTACHED_DATA" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="15 " SRCCOLUMN1="4 " SRCROW2="18 " SRCCOLUMN2="33 " TYPESRC_LENG="131 " TYPESRC="BEGIN OF ts_task_attached_data,
      name TYPE        string,
      data TYPE REF TO data,
    END OF   ts_task_attached_data
"/>
  <types CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="TT_TASK_ATTACHED_DATA" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="20 " SRCCOLUMN1="4 " SRCROW2="21 " SRCCOLUMN2="81 " TYPESRC_LENG="150 " TYPESRC="tt_task_attached_data TYPE SORTED TABLE OF ts_task_attached_data
                                       WITH UNIQUE KEY primary_key COMPONENTS name
"/>
  <typeUsage CLSNAME="ZIF_TASK_CONSTANT" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_MESSAGE_CLASS_ID" VERSION="1" LANGU="F" DESCRIPT="Domaine fonctionnel" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="2" ATTVALUE="&apos;ZTASK&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ARBGB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_PARAMETER_KIND_CHANGING" VERSION="1" LANGU="F" DESCRIPT="Changing" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="2" ATTVALUE="ABAP_FUNC_CHANGING" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_FUNC_PARMBIND-KIND" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_PARAMETER_KIND_EXCEPTION" VERSION="1" LANGU="F" DESCRIPT="Exception" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="&apos;99&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_FUNC_PARMBIND-KIND" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_PARAMETER_KIND_EXPORTING" VERSION="1" LANGU="F" DESCRIPT="Exporting" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="2" ATTVALUE="ABAP_FUNC_EXPORTING" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_FUNC_PARMBIND-KIND" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_PARAMETER_KIND_IMPORTING" VERSION="1" LANGU="F" DESCRIPT="Importing" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="2" ATTVALUE="ABAP_FUNC_IMPORTING" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_FUNC_PARMBIND-KIND" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_PARAMETER_KIND_TABLES" VERSION="1" LANGU="F" DESCRIPT="Tables" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="2" ATTVALUE="ABAP_FUNC_TABLES" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_FUNC_PARMBIND-KIND" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_PARAMETER_NAME_ERROR" VERSION="1" LANGU="F" DESCRIPT="Erreur" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="2" ATTVALUE="&apos;ERROR&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_PARAMETER_NAME_JOB" VERSION="1" LANGU="F" DESCRIPT="Programme - Job" EXPOSURE="2" STATE="1" EDITORDER="11 " ATTDECLTYP="2" ATTVALUE="&apos;RESULT_JOB&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_PARAMETER_NAME_REPID_PREFIX" VERSION="1" LANGU="F" DESCRIPT="Programme - Préfix" EXPOSURE="2" STATE="1" EDITORDER="8 " ATTDECLTYP="2" ATTVALUE="&apos;ZREPID_&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_PARAMETER_NAME_USER" VERSION="1" LANGU="F" DESCRIPT="Programme - Nom Utilisateur" EXPOSURE="2" STATE="1" EDITORDER="10 " ATTDECLTYP="2" ATTVALUE="&apos;ZREPID_USER&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_TASK_CONSTANT" CMPNAME="MC_PARAMETER_NAME_VARIANT" VERSION="1" LANGU="F" DESCRIPT="Programme - Variante" EXPOSURE="2" STATE="1" EDITORDER="9 " ATTDECLTYP="2" ATTVALUE="&apos;ZREPID_VARIANT&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 </INTF>
 <MSAG ARBGB="ZTASK" MASTERLANG="F" RESPUSER="OVEHIER" STEXT="Tâche - Classe de message">
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="501" TEXT="[&amp;] : Erreur lors de la conversion des paramètres dynamiques"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="502" TEXT="[&amp;] : Erreur lors d&apos;appel du traitement // &amp;"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="005" TEXT="[Tâche &amp;] : Impossible de traiter le paramètre &amp;"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="006" TEXT="[Tâche &amp;] : Une erreur est survenue lors du traitement des paramètres"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="000" TEXT="[ Tâche ]"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="100" TEXT="[ Manager Tâche ]"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="102" TEXT="Le nombre de Tâche doit être un entier positif"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="103" TEXT="Aucune Tâche n&apos;a pu être créé."/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="104" TEXT="Le MF &amp; n&apos;existe pas"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="105" TEXT="Le groupe de serveur &amp; n&apos;existe pas."/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="200" TEXT="[ Handler Tâche ]"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="300" TEXT="[ Container Tâche ]"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="400" TEXT="[ Trace Tâche ]"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="500" TEXT="[ Module Focntion Z_TASK_CALL_PROCESS ]"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="003" TEXT="[Tâche &amp;] : Le traitement d&apos;appel est obligatoire"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="002" TEXT="[Tâche &amp;] : Le traitement &amp; n&apos;existe pas"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="600" TEXT="[ Wizard ]"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="601" TEXT="La méthode &amp; / &amp; n&apos;existe pas ou n&apos;est pas conforme."/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="602" TEXT="Veuillez saisir une classe"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="603" TEXT="Veuillez saisir une méthode"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="604" TEXT="Vous ne pouvez pas utiliser le Prg. Template en tant que Prg. Cadre"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="605" TEXT="Anchor template &amp; / &amp; non trouvée."/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="606" TEXT="Template du Cadriciel non trouvé dans le prg &amp;."/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="607" TEXT="Veuillez saisir le nom de l&apos;Include"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="608" TEXT="L&apos;Include &amp; existe déjà."/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="609" TEXT="L&apos;Include &amp; n&apos;existe pas."/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="106" TEXT="En mode simplifié, le traitement est obligatoire (activation mode dédié)"/>
  <t100 SPRSL="F" ARBGB="ZTASK" MSGNR="107" TEXT="En mode dédié, le traitement est obligatoire"/>
  <t100t SPRSL="F" ARBGB="ZTASK" STEXT="Tâche - Classe de message"/>
 </MSAG>
 <PROG NAME="ZTASK_TEMPLATE" VARCL="X" SUBC="I" RSTAT="T" RMAND="200" RLOAD="F" UCCHECK="X">
  <textPool>
   <language SPRAS="F">
    <textElement ID="R" ENTRY="Tâche - Template" LENGTH="16 "/>
   </language>
  </textPool>
  <source>&quot;#ANCHOR-WIZARD_SIGN-INCLUDE-BEG#
*----------------------------------------------------------------------*
*   Include généré à partir de l&apos;Assistant
*   Le #DATUM#, par #UNAME#
*   Include a été généré avec l&apos;assistant de création
*   de parallélisation.
*----------------------------------------------------------------------*
&quot;#ANCHOR-WIZARD_SIGN-INCLUDE-END#
&quot;#ANCHOR-TASK_TEMPLATE-BEG#
*----------------------------------------------------------------------*
*       CLASS LCL_TASK_TEMPLATE DEFINIION
*----------------------------------------------------------------------*
*   Classe générée à partir de l&apos;Assistant
*   Le #DATUM#, par #UNAME#
*   Cette classe a été générée avec l&apos;assistant de création
*   de parallélisation.
*----------------------------------------------------------------------*
CLASS lcl_task_template DEFINITION FINAL CREATE PRIVATE.

*-- Publique
  PUBLIC SECTION.

***------------------------------------------------------------------***
**                              TYPES                                 **
***------------------------------------------------------------------***

*   Déclaration de type

***------------------------------------------------------------------***
**                           MÉTHODES                                 **
***------------------------------------------------------------------***

*	Déclaration de méthodes

    &quot;#ANCHOR-AT_SELECTION_SCREEN_OUTPUT-DEF-BEG#
    &quot; Modification Ecran de Sélection
    CLASS-METHODS at_selection_screen_output.
    &quot;#ANCHOR-AT_SELECTION_SCREEN_OUTPUT-DEF-END#

    &quot; Création Instance
    CLASS-METHODS factory
      RETURNING VALUE(ro_task) TYPE REF TO lcl_task_template
      RAISING   zcx_task_manager.

    &quot; Tâche - Lancement d&apos;une nouvelle Tâche
    METHODS task_start_new
      IMPORTING
        !is_task_call_process      TYPE ztec_s_task_call_process OPTIONAL
        !is_task_configuration     TYPE zcl_task_manager=&gt;ts_task_process_configuration OPTIONAL
        !io_task_container         TYPE REF TO zcl_task_container OPTIONAL
        !iv_overload_compress_conf TYPE xsdboolean OPTIONAL
      RAISING
        zcx_task_manager .

    &quot; Tâche - Traitement de fin
    METHODS task_finish_running.

    &quot; Container - Création
    METHODS task_container_get
      RETURNING VALUE(ro_task_container) TYPE REF TO zcl_task_container.

    &quot; Handler - Evènement Fin d&apos;une Tâche
    METHODS at_eot                                          &quot;#EC CALLED
      IMPORTING
        !is_task_call_process TYPE ztec_s_task_call_process
        !it_result            TYPE zif_task_constant=&gt;tt_function_parameters OPTIONAL
        !it_attached_data     TYPE zif_task_constant=&gt;tt_task_attached_data OPTIONAL
        !iv_error             TYPE xsdboolean OPTIONAL.

    &quot; Handler - Evènement Traitement avant début de lancement d&apos;une Tâche
    METHODS before_task                                     &quot;#EC CALLED
      IMPORTING
        !is_task_call_process TYPE ztec_s_task_call_process
        !io_task_container    TYPE REF TO zcl_task_container OPTIONAL.

***------------------------------------------------------------------***
**                            ATTRIBUTS                               **
***------------------------------------------------------------------***

*	Déclaration d&apos;attributs


*-- Privée
  PRIVATE SECTION.

***------------------------------------------------------------------***
**                              TYPES                                 **
***------------------------------------------------------------------***

*   Déclaration de type

    TYPES :
      BEGIN OF ts_selection_criteria,
        parallel_activ       TYPE xsdboolean,
        server_default       TYPE xsdboolean,
        server_user          TYPE bdfields-rfcgr,
        task_number          TYPE int4,
        task_trace           TYPE xsdboolean,
        task_manage_shm      TYPE xsdboolean,
        task_compress_activ  TYPE xsdboolean,
        task_compress_line   TYPE xsdboolean,
        task_compress_global TYPE xsdboolean,
      END OF   ts_selection_criteria.

***------------------------------------------------------------------***
**                           MÉTHODES                                 **
***------------------------------------------------------------------***

*	Déclaration de méthodes

    &quot; Constructeur
    METHODS constructor
      RAISING
        zcx_task_manager.

***------------------------------------------------------------------***
**                            ATTRIBUTS                               **
***------------------------------------------------------------------***

*	Déclaration d&apos;attributs

    DATA : mo_task_manager TYPE REF TO zcl_task_manager.
    DATA : ms_selection_criteria TYPE ts_selection_criteria.

ENDCLASS.             &quot;LCL_TASK_TEMPLATE DEFINITION

*----------------------------------------------------------------------*
*       CLASS LCL_TASK_TEMPLATE IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_task_template IMPLEMENTATION.

  &quot;#ANCHOR-AT_SELECTION_SCREEN_OUTPUT-IMPL-BEG#
  METHOD at_selection_screen_output.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Sélection des données
    &quot; -----------------------------------------------------------

    LOOP AT SCREEN.

      &quot; Suivant le Groupe d&apos;élèment
      CASE screen-group1.

        WHEN &apos;ALL&apos;.                                         &quot;#EC NOTEXT
          &quot; Groupe &apos;TOUS&apos;
          &quot;&quot;  --&gt; (Dés)Active les paramètres de configuration de la parallélisation
          screen-input = SWITCH int1( p_tact
            WHEN abap_true THEN 1   &quot;Active la saisie  // Activation Parallélisation
            ELSE 0                  &quot;Désactive la saisie
          ).

          &quot; Suivant le Paramètre
          CASE screen-name.

            WHEN &apos;P_GRFC&apos;.                                  &quot;#EC NOTEXT
              &quot; Groupe de Serveur
              &quot;&quot;  --&gt; (Dés)Active la saisie de la zone Groupe de Serveur
              screen-input = SWITCH int1( boolc( p_tact EQ abap_true AND p_grfc_r EQ abap_true )
                WHEN abap_true THEN 1 &quot;Active la saisie  // Activation Parallélisation &amp; Groupe de Serveur spécifique
                ELSE 0                &quot;Désactive la saisie
              ).

            WHEN &apos;P_TCOMPL&apos;                                 &quot;#EC NOTEXT
              OR &apos;P_TCOMPG&apos;.                                &quot;#EC NOTEXT
              &quot; Méthode de Compression
              &quot;&quot;  --&gt; (Dés)Active la saisie de la Méthode de Compression
              screen-input = SWITCH int1( boolc( p_tact EQ abap_true AND p_tcomp EQ abap_true )
                WHEN abap_true THEN 1 &quot;Active la saisie  // Activation Parallélisation &amp; Compression Active
                ELSE 0                &quot;Désactive la saisie
              ).

            WHEN OTHERS.
              &quot; Autre

          ENDCASE.

        WHEN OTHERS.
          &quot; Autres
          &quot;&quot;  --&gt; Passe à l&apos;Itération Suivante
          CONTINUE.

      ENDCASE.

      MODIFY SCREEN.

    ENDLOOP.

  ENDMETHOD.
  &quot;#ANCHOR-AT_SELECTION_SCREEN_OUTPUT-IMPL-END#

  METHOD factory.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    TRY.
        &quot; -----------------------------------------------------------
        &quot; Création instance Manager de Tâche
        &quot; -----------------------------------------------------------

        &quot; Création instance du Manager de Tâche
        CREATE OBJECT ro_task.

      CATCH zcx_task_manager INTO DATA(lo_cx_exception).
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Lève l&apos;Exception
        RAISE EXCEPTION TYPE zcx_task_manager
          EXPORTING
            previous = lo_cx_exception.

    ENDTRY.

  ENDMETHOD.

  METHOD constructor.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
    DATA :
          ls_task_manager_configuration TYPE zcl_task_manager=&gt;ts_task_manager_configuration.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Initialisation paramètre de configuration
    &quot; -----------------------------------------------------------

    &quot; Initialisation données relatives aux ressources de parallélisation
    ls_task_manager_configuration-grfc               = #grfc#.
    ls_task_manager_configuration-task_max           = #task_max#.
    ls_task_manager_configuration-use_server_default = #use_server_default#.

    &quot; Initialisation données relatives aux traitements - Fin d&apos;une Tâche
    ls_task_manager_configuration-global_configuration-process_by_method-after-instance = me.
    ls_task_manager_configuration-global_configuration-process_by_method-after-method   = &apos;AT_EOT&apos;. &quot;#EC NOTEXT

    &quot; Initialisation données relatives aux traitements - Avant lancement d&apos;une Tâche
    ls_task_manager_configuration-global_configuration-process_by_method-before-instance = me.
    ls_task_manager_configuration-global_configuration-process_by_method-before-method   = &apos;BEFORE_TASK&apos;. &quot;#EC NOTEXT

    &quot; Initialisation données relatives à la configuration
    ls_task_manager_configuration-global_configuration-shm_management = #shm_management#.
    ls_task_manager_configuration-global_configuration-task_compress_activ = #compress_activ#.
    ls_task_manager_configuration-global_configuration-task_compress_param-data_compress_global       = #compress_g#.
    ls_task_manager_configuration-global_configuration-task_compress_param-data_compress_line_by_line = #compress_l#.

    &quot; Initialisation données relatives aux traces
    ls_task_manager_configuration-global_configuration-task_trace_param-trace_active = #task_trace#.
    ls_task_manager_configuration-global_configuration-task_trace_param-trace_memory = #task_trace#.

    TRY.
        &quot; -----------------------------------------------------------
        &quot; Création du Manager de Tâche
        &quot; -----------------------------------------------------------

        &quot; Création de l&apos;instance du Manager de Tâche
        CREATE OBJECT me-&gt;mo_task_manager
          EXPORTING
            is_task_manager_configuration = ls_task_manager_configuration.

      CATCH zcx_task_manager INTO DATA(lo_cx_exception).
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Lève une Exception
        RAISE EXCEPTION TYPE zcx_task_manager
          EXPORTING
            previous = lo_cx_exception.

    ENDTRY.

  ENDMETHOD.

  METHOD task_start_new.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    TRY.
        &quot; -----------------------------------------------------------
        &quot; Lancement d&apos;une Nouvelle Tâche
        &quot; -----------------------------------------------------------

        &quot; Lancement d&apos;une Tâche
        me-&gt;mo_task_manager-&gt;task_start_new(
            is_task_call_process      = is_task_call_process
            is_task_configuration     = is_task_configuration
            io_task_container         = io_task_container
            iv_overload_compress_conf = iv_overload_compress_conf
        ).

      CATCH zcx_task_manager INTO DATA(lo_cx_exception).
        &quot; Une erreur est survenue
        &quot;&quot;  --&gt; Lève une Exception
        RAISE EXCEPTION TYPE zcx_task_manager
          EXPORTING
            previous = lo_cx_exception.

    ENDTRY.

  ENDMETHOD.

  METHOD task_finish_running.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Attente fin de toutes les Tâches
    &quot; -----------------------------------------------------------

    &quot; Traitement de Fin
    me-&gt;mo_task_manager-&gt;task_finish_running( ).

  ENDMETHOD.

  METHOD task_container_get.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Création instance Container de données
    &quot; -----------------------------------------------------------

    &quot; Création Container
    ro_task_container = me-&gt;mo_task_manager-&gt;container_task_create( ).

  ENDMETHOD.

  METHOD at_eot.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
    FIELD-SYMBOLS :
      &lt;lfs_value&gt;           TYPE any,
      &lt;lfs_t_value&gt;         TYPE ANY TABLE,
      &lt;lfs_s_result&gt;        TYPE zif_task_constant=&gt;ts_function_parameters,
      &lt;lfs_s_attached_data&gt; TYPE zif_task_constant=&gt;ts_task_attached_data.

***==================================================================***
**                           TRAITEMENT                               **

***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Traitement Présence d&apos;Erreur
    &quot; -----------------------------------------------------------

    IF iv_error EQ abap_true.
      &quot; Une erreur est survenue
      &quot;&quot;  --&gt; Récupération de l&apos;erreur
      ASSIGN it_result[ parameter_name = zif_task_constant=&gt;mc_parameter_name_error ]
          TO &lt;lfs_s_result&gt;.                                &quot;#EC NOTEXT

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Traitement Fin d&apos;une Tâche
    &quot; -----------------------------------------------------------

    &quot;#ANCHOR-AT_EOT#
  ENDMETHOD.

  METHOD before_task.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Traitement Avant Lancement de la Tâche
    &quot; -----------------------------------------------------------

    &quot;#ANCHOR-BEFORE_TASK#
  ENDMETHOD.

ENDCLASS.   &quot;ENDCLASS LCL_TASK_TEMPLATE
&quot;#ANCHOR-TASK_TEMPLATE-END#

&quot;#ANCHOR-SELECTION-SCREEN-BEG#
&quot; -----------------------------------------------------------
&quot; Paramètres Parallélisation
&quot; -----------------------------------------------------------

SELECTION-SCREEN BEGIN OF BLOCK ta WITH FRAME TITLE text-ta1.

&quot; Activation Parallélisation
PARAMETERS : p_tact AS CHECKBOX USER-COMMAND tu1.

&quot; -----------------------------------------------------------
&quot; Configuration Paraléllisation
&quot; -----------------------------------------------------------

SELECTION-SCREEN BEGIN OF BLOCK tc WITH FRAME TITLE text-tc1.

&quot; Groupe de Serveur
PARAMETERS : p_grfc_r RADIOBUTTON GROUP rfc USER-COMMAND rfc MODIF ID all #p_grfc_r_default#. &quot;#EC NOTEXT
PARAMETERS : p_grfc TYPE bdfields-rfcgr MODIF ID all #p_grfc_default#. &quot;#EC NOTEXT

&quot; Utilisation Groupe par défaut
PARAMETERS : p_dgrfc RADIOBUTTON GROUP rfc MODIF ID all #p_dgrfc_default#. &quot;#EC NOTEXT

SELECTION-SCREEN END OF BLOCK tc.

SELECTION-SCREEN SKIP 1.

&quot; Nombre de Tâche
PARAMETERS : p_ntask TYPE int4 MODIF ID all OBLIGATORY #p_ntask_default#. &quot;#EC NOTEXT

SELECTION-SCREEN SKIP 1.

&quot; -----------------------------------------------------------
&quot; Options supplémentaires
&quot; -----------------------------------------------------------

SELECTION-SCREEN BEGIN OF BLOCK tb WITH FRAME TITLE text-tb1.

&quot; -----------------------------------------------------------
&quot; Méthode de Compression
&quot; -----------------------------------------------------------

SELECTION-SCREEN BEGIN OF BLOCK toc WITH FRAME TITLE text-toc.

&quot; Activation de la Compression
PARAMETERS : p_tcomp AS CHECKBOX USER-COMMAND toc MODIF ID all #p_tcomp_default#. &quot;#EC NOTEXT

&quot; Méthode de Compression
SELECTION-SCREEN BEGIN OF LINE.

&quot; Compression Ligne-à-Ligne
SELECTION-SCREEN COMMENT 1(24) FOR FIELD p_tcompl.
PARAMETERS : p_tcompl RADIOBUTTON GROUP roc USER-COMMAND roc MODIF ID all #p_tcompl_default#. &quot;#EC NOTEXT

&quot; Compression Global
SELECTION-SCREEN COMMENT 35(18) FOR FIELD p_tcompg.
PARAMETERS : p_tcompg RADIOBUTTON GROUP roc MODIF ID all #p_tcompg_default#. &quot;#EC NOTEXT

SELECTION-SCREEN   END OF LINE.

SELECTION-SCREEN END OF BLOCK toc.

&quot; Trace
PARAMETERS : p_ttrace AS CHECKBOX USER-COMMAND tu4 MODIF ID all #p_ttrace_default#. &quot;#EC NOTEXT

&quot; Purge de la SHM
PARAMETERS : p_tshm AS CHECKBOX USER-COMMAND tu2 MODIF ID all #p_tshm_default#. &quot;#EC NOTEXT

SELECTION-SCREEN END OF BLOCK tb.

SELECTION-SCREEN END OF BLOCK ta.
&quot;#ANCHOR-SELECTION-SCREEN-END#</source>
 </PROG>
 <TABL TABNAME="ZTEC_S_TASK_WIZARD_INCL" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Tâche - Données Assistant - Pour Gestion Include" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_INCL" FIELDNAME="INCLUDE_NAME" DDLANGUAGE="F" POSITION="0001" ROLLNAME="PROGNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000080" DOMNAME="PROGNAME" ROUTPUTLEN="000000" HEADLEN="40" SCRLEN1="08" SCRLEN2="12" SCRLEN3="12" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom du programme ABAP" REPTEXT="Progr." SCRTEXT_S="Program." SCRTEXT_M="Nom de progr" SCRTEXT_L="Programme" DOMNAME3L="PROGNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_INCL" FIELDNAME="INCLUDE_CREATE" DDLANGUAGE="F" POSITION="0002" ROLLNAME="XSDBOOLEAN" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="13" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Valeur de vérité XSD : vrai/faux [ext.]" REPTEXT="Val. vérité" SCRTEXT_S="Val.vérité" SCRTEXT_M="Val. de vérité" SCRTEXT_L="Valeur de vérité" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_INCL" FIELDNAME="INCLUDE_CHANGE" DDLANGUAGE="F" POSITION="0003" ROLLNAME="XSDBOOLEAN" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="13" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Valeur de vérité XSD : vrai/faux [ext.]" REPTEXT="Val. vérité" SCRTEXT_S="Val.vérité" SCRTEXT_M="Val. de vérité" SCRTEXT_L="Valeur de vérité" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTEC_S_TASK_WIZARD_DATA" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Tâche - Données Assistant" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="GRFC" DDLANGUAGE="F" POSITION="0001" ROLLNAME="RFCGR" ADMINFIELD="0" INTTYPE="C" INTLEN="000040" DOMNAME="RZLLI_ACN" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000020" OUTPUTLEN="000020" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Groupe de serveurs RFC pour traitement parallèle" REPTEXT="Groupe de serveurs" SCRTEXT_S="Grp.srv." SCRTEXT_M="Groupe serveurs" SCRTEXT_L="Groupe de serveurs" DOMNAME3L="RZLLI_ACN" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="SERVER_USER" DDLANGUAGE="F" POSITION="0002" ROLLNAME="XSDBOOLEAN" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="13" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Valeur de vérité XSD : vrai/faux [ext.]" REPTEXT="Val. vérité" SCRTEXT_S="Val.vérité" SCRTEXT_M="Val. de vérité" SCRTEXT_L="Valeur de vérité" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="SERVER_DEFAULT" DDLANGUAGE="F" POSITION="0003" ROLLNAME="XSDBOOLEAN" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="13" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Valeur de vérité XSD : vrai/faux [ext.]" REPTEXT="Val. vérité" SCRTEXT_S="Val.vérité" SCRTEXT_M="Val. de vérité" SCRTEXT_L="Valeur de vérité" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="TASK_MAX" DDLANGUAGE="F" POSITION="0004" ROLLNAME="INT4" ADMINFIELD="0" INTTYPE="X" INTLEN="000004" DOMNAME="INT4" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="INT4" LENG="000010" OUTPUTLEN="000010" DECIMALS="000000" SIGNFLAG="X" MASK="  INT4E" MASKLEN="0000" DDTEXT="Entier naturel" SCRTEXT_S="Nombre" SCRTEXT_M="Nombre" SCRTEXT_L="Entier naturel" DOMNAME3L="INT4" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="TARGET_REPID" DDLANGUAGE="F" POSITION="0005" ROLLNAME="PROGNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000080" DOMNAME="PROGNAME" ROUTPUTLEN="000000" HEADLEN="40" SCRLEN1="08" SCRLEN2="12" SCRLEN3="12" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom du programme ABAP" REPTEXT="Progr." SCRTEXT_S="Program." SCRTEXT_M="Nom de progr" SCRTEXT_L="Programme" DOMNAME3L="PROGNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="TARGET_FRAMEWORK_INCL_USE" DDLANGUAGE="F" POSITION="0006" ROLLNAME="XSDBOOLEAN" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="13" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Valeur de vérité XSD : vrai/faux [ext.]" REPTEXT="Val. vérité" SCRTEXT_S="Val.vérité" SCRTEXT_M="Val. de vérité" SCRTEXT_L="Valeur de vérité" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="TARGET_FRAMEWORK_INCL_DATA" DDLANGUAGE="F" POSITION="0007" ROLLNAME="ZTEC_S_TASK_WIZARD_INCL" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRU" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRUS" MASKLEN="0000" DDTEXT="Tâche - Données Assistant - Pour Gestion Include" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="INCLUDE_NAME" DDLANGUAGE="F" POSITION="0008" ROLLNAME="PROGNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000080" DOMNAME="PROGNAME" ROUTPUTLEN="000000" HEADLEN="40" SCRLEN1="08" SCRLEN2="12" SCRLEN3="12" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom du programme ABAP" REPTEXT="Progr." SCRTEXT_S="Program." SCRTEXT_M="Nom de progr" SCRTEXT_L="Programme" DOMNAME3L="PROGNAME" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="INCLUDE_CREATE" DDLANGUAGE="F" POSITION="0009" ROLLNAME="XSDBOOLEAN" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="13" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Valeur de vérité XSD : vrai/faux [ext.]" REPTEXT="Val. vérité" SCRTEXT_S="Val.vérité" SCRTEXT_M="Val. de vérité" SCRTEXT_L="Valeur de vérité" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="INCLUDE_CHANGE" DDLANGUAGE="F" POSITION="0010" ROLLNAME="XSDBOOLEAN" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="13" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Valeur de vérité XSD : vrai/faux [ext.]" REPTEXT="Val. vérité" SCRTEXT_S="Val.vérité" SCRTEXT_M="Val. de vérité" SCRTEXT_L="Valeur de vérité" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="TARGET_SELSCREEN_ADD" DDLANGUAGE="F" POSITION="0011" ROLLNAME="XSDBOOLEAN" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="13" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Valeur de vérité XSD : vrai/faux [ext.]" REPTEXT="Val. vérité" SCRTEXT_S="Val.vérité" SCRTEXT_M="Val. de vérité" SCRTEXT_L="Valeur de vérité" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="TARGET_SELSCREEN_INCL_USE" DDLANGUAGE="F" POSITION="0012" ROLLNAME="XSDBOOLEAN" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="13" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Valeur de vérité XSD : vrai/faux [ext.]" REPTEXT="Val. vérité" SCRTEXT_S="Val.vérité" SCRTEXT_M="Val. de vérité" SCRTEXT_L="Valeur de vérité" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="TARGET_SELSCREEN_INCL_DATA" DDLANGUAGE="F" POSITION="0013" ROLLNAME="ZTEC_S_TASK_WIZARD_INCL" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRU" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRUS" MASKLEN="0000" DDTEXT="Tâche - Données Assistant - Pour Gestion Include" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="INCLUDE_NAME" DDLANGUAGE="F" POSITION="0014" ROLLNAME="PROGNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000080" DOMNAME="PROGNAME" ROUTPUTLEN="000000" HEADLEN="40" SCRLEN1="08" SCRLEN2="12" SCRLEN3="12" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom du programme ABAP" REPTEXT="Progr." SCRTEXT_S="Program." SCRTEXT_M="Nom de progr" SCRTEXT_L="Programme" DOMNAME3L="PROGNAME" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="INCLUDE_CREATE" DDLANGUAGE="F" POSITION="0015" ROLLNAME="XSDBOOLEAN" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="13" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Valeur de vérité XSD : vrai/faux [ext.]" REPTEXT="Val. vérité" SCRTEXT_S="Val.vérité" SCRTEXT_M="Val. de vérité" SCRTEXT_L="Valeur de vérité" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="INCLUDE_CHANGE" DDLANGUAGE="F" POSITION="0016" ROLLNAME="XSDBOOLEAN" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="13" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Valeur de vérité XSD : vrai/faux [ext.]" REPTEXT="Val. vérité" SCRTEXT_S="Val.vérité" SCRTEXT_M="Val. de vérité" SCRTEXT_L="Valeur de vérité" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="TASK_TEMPLATE_REPID" DDLANGUAGE="F" POSITION="0017" ROLLNAME="PROGNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000080" DOMNAME="PROGNAME" ROUTPUTLEN="000000" HEADLEN="40" SCRLEN1="08" SCRLEN2="12" SCRLEN3="12" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom du programme ABAP" REPTEXT="Progr." SCRTEXT_S="Program." SCRTEXT_M="Nom de progr" SCRTEXT_L="Programme" DOMNAME3L="PROGNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="TASK_CLASS_REPLACE" DDLANGUAGE="F" POSITION="0018" ADMINFIELD="0" INTTYPE="g" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRG" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRG" MASKLEN="0000" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="T_TASK_CALL_PROCESS" DDLANGUAGE="F" POSITION="0019" ROLLNAME="ZTEC_T_TASK_CALL_PROCESS" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Tâche - Type de Table de Traitement à lancer" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="SHM_MANAGEMENT" DDLANGUAGE="F" POSITION="0020" ROLLNAME="XSDBOOLEAN" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="13" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Valeur de vérité XSD : vrai/faux [ext.]" REPTEXT="Val. vérité" SCRTEXT_S="Val.vérité" SCRTEXT_M="Val. de vérité" SCRTEXT_L="Valeur de vérité" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="TRACE_ACTIV" DDLANGUAGE="F" POSITION="0021" ROLLNAME="XSDBOOLEAN" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="13" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Valeur de vérité XSD : vrai/faux [ext.]" REPTEXT="Val. vérité" SCRTEXT_S="Val.vérité" SCRTEXT_M="Val. de vérité" SCRTEXT_L="Valeur de vérité" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="COMPRESS_ACTIV" DDLANGUAGE="F" POSITION="0022" ROLLNAME="XSDBOOLEAN" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="13" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Valeur de vérité XSD : vrai/faux [ext.]" REPTEXT="Val. vérité" SCRTEXT_S="Val.vérité" SCRTEXT_M="Val. de vérité" SCRTEXT_L="Valeur de vérité" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="COMPRESS_MODE" DDLANGUAGE="F" POSITION="0023" ROLLNAME="ZTEC_S_TASK_COMPRESS_PARAM" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRU" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRUS" MASKLEN="0000" DDTEXT="Tâche - Paramètres de compression" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="DATA_COMPRESS_LINE_BY_LINE" DDLANGUAGE="F" POSITION="0024" ROLLNAME="ZTASK_DATA_COMPRESS_LINE" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="20" SCRLEN3="40" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Tâche - Données - Compression données (ligne)" REPTEXT="Compression données lignes / lignes" SCRTEXT_S="Comp." SCRTEXT_M="Comp. L/L" SCRTEXT_L="Compression données" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_WIZARD_DATA" FIELDNAME="DATA_COMPRESS_GLOBAL" DDLANGUAGE="F" POSITION="0025" ROLLNAME="ZTASK_DATA_COMPRESS_GLOBAL" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="28" SCRLEN1="09" SCRLEN2="15" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Tâche - Données - Compression données globales" REPTEXT="Compression données globales" SCRTEXT_S="Comp. glb" SCRTEXT_M="Comp. globale" SCRTEXT_L="Compression globale" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTEC_S_TASK_TRACE_PARAM" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Tâche - Paramètre de Trace" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_TASK_TRACE_PARAM" FIELDNAME="TRACE_ACTIVE" DDLANGUAGE="F" POSITION="0001" ROLLNAME="ZTRACE_XFELD" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="12" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Trace - Activation de trace" REPTEXT="Trace active" SCRTEXT_S="Trace" SCRTEXT_M="Trace active" SCRTEXT_L="Trace active" DOMNAME3L="XFELD" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_TRACE_PARAM" FIELDNAME="TRACE_MEMORY" DDLANGUAGE="F" POSITION="0002" ROLLNAME="ZTRACE_MEM_XFELD" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="20" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Trace - Activation Trace mémoire" REPTEXT="Trace mémoire active" SCRTEXT_S="Trace mém" SCRTEXT_M="Trace mémoire active" SCRTEXT_L="Trace mémoire active" DOMNAME3L="XFELD" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTEC_S_TASK_PROCESS_BY_METHOD" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Tâche - Traitement par Méthode" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_TASK_PROCESS_BY_METHOD" FIELDNAME="INSTANCE" POSITION="0001" ROLLNAME="OBJECT" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="REF" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  REF RO" MASKLEN="0000" DEPTH="00" COMPTYPE="R" REFTYPE="O" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_PROCESS_BY_METHOD" FIELDNAME="METHOD" DDLANGUAGE="F" POSITION="0002" ADMINFIELD="0" INTTYPE="g" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRG" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRG" MASKLEN="0000" DDTEXT="Méthode à appeler" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTEC_S_TASK_PROCESS_BY_FORM" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Tâche - Traitement par Routine" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_TASK_PROCESS_BY_FORM" FIELDNAME="REPID" DDLANGUAGE="F" POSITION="0001" ROLLNAME="REPID" ADMINFIELD="0" INTTYPE="C" INTLEN="000080" DOMNAME="PROGNAME" ROUTPUTLEN="000000" HEADLEN="10" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom du programme ABAP" REPTEXT="Programme" SCRTEXT_S="Programme" SCRTEXT_M="Nom programme" SCRTEXT_L="Nom du programme" DOMNAME3L="PROGNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_PROCESS_BY_FORM" FIELDNAME="FORM" DDLANGUAGE="F" POSITION="0002" ROLLNAME="FORMID" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="CHAR30" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="20" SCRLEN3="30" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom d&apos;une routine FORM" REPTEXT="Nom de la routine FORM" SCRTEXT_S="Nom FORM" SCRTEXT_M="Nom routine FORM" SCRTEXT_L="Nom de la routine FORM" DOMNAME3L="CHAR30" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTEC_S_TASK_COMPRESS_PARAM" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Tâche - Paramètres de compression" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_TASK_COMPRESS_PARAM" FIELDNAME="DATA_COMPRESS_LINE_BY_LINE" DDLANGUAGE="F" POSITION="0001" ROLLNAME="ZTASK_DATA_COMPRESS_LINE" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="20" SCRLEN3="40" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Tâche - Données - Compression données (ligne)" REPTEXT="Compression données lignes / lignes" SCRTEXT_S="Comp." SCRTEXT_M="Comp. L/L" SCRTEXT_L="Compression données" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_COMPRESS_PARAM" FIELDNAME="DATA_COMPRESS_GLOBAL" DDLANGUAGE="F" POSITION="0002" ROLLNAME="ZTASK_DATA_COMPRESS_GLOBAL" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="28" SCRLEN1="09" SCRLEN2="15" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Tâche - Données - Compression données globales" REPTEXT="Compression données globales" SCRTEXT_S="Comp. glb" SCRTEXT_M="Comp. globale" SCRTEXT_L="Compression globale" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTEC_S_TASK_CALL_METHOD" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Données pour appel Méthode" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_TASK_CALL_METHOD" FIELDNAME="CLASS_NAME" DDLANGUAGE="F" POSITION="0001" ROLLNAME="SEOCLSNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="SEOCLSNAME" ROUTPUTLEN="000000" MEMORYID="CLASS" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom de type d&apos;objet" REPTEXT="Nom de type d&apos;objet" SCRTEXT_S="Type objet" SCRTEXT_M="Nom type objet" SCRTEXT_L="Classe/Interface" DOMNAME3L="SEOCLSNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_CALL_METHOD" FIELDNAME="METHOD_NAME" DDLANGUAGE="F" POSITION="0002" ROLLNAME="SEOCPDNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000122" DOMNAME="CHAR61" ROUTPUTLEN="000000" HEADLEN="61" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000061" OUTPUTLEN="000061" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom de composante complet" REPTEXT="Composante d&apos;interface" SCRTEXT_S="Comp. int." SCRTEXT_M="Comp. interface" SCRTEXT_L="Composante interface" DOMNAME3L="CHAR61" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_CALL_METHOD" FIELDNAME="T_METHOD_PARAMETERS" DDLANGUAGE="F" POSITION="0003" ROLLNAME="ZTEC_T_METHOD_PARAMETERS" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Méthode : Type de table paramétres d&apos;appel Statique" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTEC_S_TASK_CALL_FUNCTION" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Données pour appel Module Fonction" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_TASK_CALL_FUNCTION" FIELDNAME="FUNCTION_NAME" DDLANGUAGE="F" POSITION="0001" ROLLNAME="FUNCNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="FUNCNAME" ROUTPUTLEN="000000" MEMORYID="LIB" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TFDIR" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom de fonction" DOMNAME3L="FUNCNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_CALL_FUNCTION" FIELDNAME="T_FUNCTION_PARAMETERS" DDLANGUAGE="F" POSITION="0002" ROLLNAME="ZTEC_T_FUNCTION_PARAMETERS" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Type de table paramètre d&apos;appel Statique" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTEC_S_METHOD_PARAMETERS" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Méthode : Structure paramétre d&apos;appel Statique" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_METHOD_PARAMETERS" FIELDNAME="PARAMETER_NAME" DDLANGUAGE="F" POSITION="0001" ROLLNAME="SEOSCONAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="CHAR30" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom de sous-composante" REPTEXT="Sous-composante" SCRTEXT_S="Sous-comp." SCRTEXT_M="Sous-composante" SCRTEXT_L="Sous-composante" DOMNAME3L="CHAR30" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_METHOD_PARAMETERS" FIELDNAME="PARAMETER_KIND" DDLANGUAGE="F" POSITION="0002" ROLLNAME="SEOPARDECL" ADMINFIELD="0" INTTYPE="N" INTLEN="000002" DOMNAME="SEOPARDECL" ROUTPUTLEN="000000" HEADLEN="01" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="NUMC" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Type de déclaration paramètre (depuis vue utilisateur)" REPTEXT="D" SCRTEXT_S="Type décl." SCRTEXT_M="T. déclaration" SCRTEXT_L="Ty. décl. paramètr." DOMMASTER="D" DOMNAME3L="SEOPARDECL" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_METHOD_PARAMETERS" FIELDNAME="VALUE_TYPE" DDLANGUAGE="F" POSITION="0003" ROLLNAME="RS38L_TYP" ADMINFIELD="0" INTTYPE="C" INTLEN="000264" DOMNAME="RS38L_TYP" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000132" OUTPUTLEN="000132" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Type de référence d&apos;un paramètre d&apos;interface" REPTEXT="Type réf." SCRTEXT_S="Type réf." SCRTEXT_M="Type réf." SCRTEXT_L="Type réf." DOMNAME3L="RS38L_TYP" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_METHOD_PARAMETERS" FIELDNAME="VALUE_KIND" DDLANGUAGE="F" POSITION="0004" ROLLNAME="TYPEKIND" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="TYPEKIND" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="03" SCRLEN2="16" SCRLEN3="16" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Catégorie du type de dictionnaire" REPTEXT="Cat" SCRTEXT_S="Cat" SCRTEXT_M="Cat. type (codé)" SCRTEXT_L="Cat. type (codé)" DOMNAME3L="TYPEKIND" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_METHOD_PARAMETERS" FIELDNAME="VALUE_DATA" DDLANGUAGE="F" POSITION="0005" ADMINFIELD="0" INTTYPE="g" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRG" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRG" MASKLEN="0000" DDTEXT="Valeur" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_METHOD_PARAMETERS" FIELDNAME="VALUE_DATA_XML" DDLANGUAGE="F" POSITION="0006" ADMINFIELD="0" INTTYPE="y" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="RSTR" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  RSTR" MASKLEN="0000" DDTEXT="XML (pour type complexe)" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTEC_S_FUNCTION_PARAMETERS" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Structure paramétres d&apos;appel statique" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_FUNCTION_PARAMETERS" FIELDNAME="PARAMETER_NAME" DDLANGUAGE="F" POSITION="0001" ROLLNAME="PARAMETER" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="LPARAMETER" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom du paramètre" REPTEXT="Nom de paramètre" SCRTEXT_S="Nom param." SCRTEXT_M="Nom paramètre" SCRTEXT_L="Nom de paramètre" DOMNAME3L="LPARAMETER" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_FUNCTION_PARAMETERS" FIELDNAME="PARAMETER_KIND" DDLANGUAGE="F" POSITION="0002" ROLLNAME="CHAR3" ADMINFIELD="0" INTTYPE="C" INTLEN="000006" DOMNAME="CHAR3" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DTELMASTER="D" DATATYPE="CHAR" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Zone d&apos;une longueur de 3 octets" DOMNAME3L="CHAR3" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_FUNCTION_PARAMETERS" FIELDNAME="VALUE_TYPE" DDLANGUAGE="F" POSITION="0003" ROLLNAME="RS38L_TYP" ADMINFIELD="0" INTTYPE="C" INTLEN="000264" DOMNAME="RS38L_TYP" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000132" OUTPUTLEN="000132" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Type de référence d&apos;un paramètre d&apos;interface" REPTEXT="Type réf." SCRTEXT_S="Type réf." SCRTEXT_M="Type réf." SCRTEXT_L="Type réf." DOMNAME3L="RS38L_TYP" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_FUNCTION_PARAMETERS" FIELDNAME="VALUE_KIND" DDLANGUAGE="F" POSITION="0004" ROLLNAME="TYPEKIND" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="TYPEKIND" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="03" SCRLEN2="16" SCRLEN3="16" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Catégorie du type de dictionnaire" REPTEXT="Cat" SCRTEXT_S="Cat" SCRTEXT_M="Cat. type (codé)" SCRTEXT_L="Cat. type (codé)" DOMNAME3L="TYPEKIND" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_FUNCTION_PARAMETERS" FIELDNAME="VALUE_DATA" DDLANGUAGE="F" POSITION="0005" ADMINFIELD="0" INTTYPE="g" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRG" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRG" MASKLEN="0000" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_FUNCTION_PARAMETERS" FIELDNAME="VALUE_DATA_XML" DDLANGUAGE="F" POSITION="0006" ADMINFIELD="0" INTTYPE="y" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="RSTR" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  RSTR" MASKLEN="0000" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_FUNCTION_PARAMETERS" FIELDNAME="VALUE_IS_COMPRESSED_LOCAL" DDLANGUAGE="F" POSITION="0007" ROLLNAME="ZTASK_DATA_COMPRESS_LINE" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="20" SCRLEN3="40" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Tâche - Données - Compression données (ligne)" REPTEXT="Compression données lignes / lignes" SCRTEXT_S="Comp." SCRTEXT_M="Comp. L/L" SCRTEXT_L="Compression données" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_FUNCTION_PARAMETERS" FIELDNAME="VALUE_IS_COMPRESSED_GLOBAL" DDLANGUAGE="F" POSITION="0008" ROLLNAME="ZTASK_DATA_COMPRESS_GLOBAL" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="28" SCRLEN1="09" SCRLEN2="15" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Tâche - Données - Compression données globales" REPTEXT="Compression données globales" SCRTEXT_S="Comp. glb" SCRTEXT_M="Comp. globale" SCRTEXT_L="Compression globale" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTEC_S_CONTENT_DATA" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Structure contenu des données - statiques" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_CONTENT_DATA" FIELDNAME="SUB_DATA_GUID" POSITION="0001" ROLLNAME="SYSUUID_C32" ADMINFIELD="0" INTTYPE="C" INTLEN="000064" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="04" SCRLEN2="04" SCRLEN3="04" DTELMASTER="D" DATATYPE="CHAR" LENG="000032" OUTPUTLEN="000032" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DOMNAME3L="SYSUUID_C32" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_CONTENT_DATA" FIELDNAME="LINE" DDLANGUAGE="F" POSITION="0002" ROLLNAME="SYST_TABIX" ADMINFIELD="0" INTTYPE="X" INTLEN="000004" DOMNAME="SYST_LONG" ROUTPUTLEN="000000" HEADLEN="10" SCRLEN1="10" SCRLEN2="20" SCRLEN3="20" DTELMASTER="D" DATATYPE="INT4" LENG="000010" OUTPUTLEN="000011" DECIMALS="000000" SIGNFLAG="X" MASK="  INT4E" MASKLEN="0000" DDTEXT="Zone système ABAP : index de ligne de tables internes" REPTEXT="Ligne" SCRTEXT_S="Ligne" SCRTEXT_M="Entrée de table" SCRTEXT_L="Entrée de table" DOMNAME3L="SYST_LONG" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_CONTENT_DATA" FIELDNAME="FIELDNAME" DDLANGUAGE="F" POSITION="0003" ROLLNAME="FIELDNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="FDNAME" ROUTPUTLEN="000000" MEMORYID="DFD" HEADLEN="10" SCRLEN1="10" SCRLEN2="15" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD03L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom de zone" REPTEXT="Nom zone" SCRTEXT_S="Zone" SCRTEXT_M="Nom de zone" SCRTEXT_L="Nom de zone" DOMNAME3L="FDNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_CONTENT_DATA" FIELDNAME="FIELDTYPE" DDLANGUAGE="F" POSITION="0004" ADMINFIELD="0" INTTYPE="g" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRG" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRG" MASKLEN="0000" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_CONTENT_DATA" FIELDNAME="FIELDKIND" DDLANGUAGE="F" POSITION="0005" ROLLNAME="TYPEKIND" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="TYPEKIND" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="03" SCRLEN2="16" SCRLEN3="16" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Catégorie du type de dictionnaire" REPTEXT="Cat" SCRTEXT_S="Cat" SCRTEXT_M="Cat. type (codé)" SCRTEXT_L="Cat. type (codé)" DOMNAME3L="TYPEKIND" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_CONTENT_DATA" FIELDNAME="VALUE" DDLANGUAGE="F" POSITION="0006" ADMINFIELD="0" INTTYPE="g" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRG" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRG" MASKLEN="0000" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZCLUST_TYPE_DEF" DDLANGUAGE="F" TABCLASS="TRANSP" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" CLIDEP="X" DDTEXT="Définition de Type - Table Cluster" AUTHCLASS="00" CONTFLAG="L" PROZPUFF="000" EXCLASS="1">
  <dd09l TABNAME="ZCLUST_TYPE_DEF" AS4LOCAL="A" AS4VERS="0000" TABKAT="1" TABART="APPL1" SCHFELDANZ="000" BUFALLOW="N" ROWORCOLST="C"/>
  <dd03p TABNAME="ZCLUST_TYPE_DEF" FIELDNAME="MANDT" DDLANGUAGE="F" POSITION="0001" KEYFLAG="X" ROLLNAME="MANDT" ADMINFIELD="0" INTTYPE="C" INTLEN="000006" NOTNULL="X" DOMNAME="MANDT" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" RESERVEDTE="D" DATATYPE="CLNT" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" ENTITYTAB="T000" MASK="  CLNTE" MASKLEN="0000" DDTEXT="Mandant" REPTEXT="Mdt" SCRTEXT_S="Mandant" SCRTEXT_M="Mandant" SCRTEXT_L="Mandant" DOMNAME3L="MANDT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZCLUST_TYPE_DEF" FIELDNAME="RELID" DDLANGUAGE="F" POSITION="0002" KEYFLAG="X" ROLLNAME="INDX_RELID" ADMINFIELD="0" INTTYPE="C" INTLEN="000004" NOTNULL="X" DOMNAME="SYCHAR02" ROUTPUTLEN="000000" HEADLEN="10" SCRLEN1="10" SCRLEN2="10" SCRLEN3="10" DATATYPE="CHAR" LENG="000002" OUTPUTLEN="000002" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Zone dans la table de données IMPORT/EXPORT" REPTEXT="Zone" SCRTEXT_S="Zone" SCRTEXT_M="Zone" SCRTEXT_L="Zone" DOMNAME3L="SYCHAR02" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZCLUST_TYPE_DEF" FIELDNAME="SRTFD" DDLANGUAGE="F" POSITION="0003" KEYFLAG="X" ROLLNAME="ZTYPE_DEFINITION_GUID" ADMINFIELD="0" INTTYPE="C" INTLEN="000064" NOTNULL="X" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="32" SCRLEN1="10" SCRLEN2="20" SCRLEN3="40" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" OUTPUTLEN="000032" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Définition de Type - ID Cluster" REPTEXT="Définition de Type - ID Cluster" SCRTEXT_S="ID Cluster" SCRTEXT_M="ID Cluster" SCRTEXT_L="Déf. Type - ID Cluster" DOMNAME3L="SYSUUID_C32" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZCLUST_TYPE_DEF" FIELDNAME="SRTF2" DDLANGUAGE="F" POSITION="0004" KEYFLAG="X" ROLLNAME="INDX_SRTF2" ADMINFIELD="0" INTTYPE="X" INTLEN="000004" NOTNULL="X" DOMNAME="SYBIN4" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="INT4" LENG="000010" OUTPUTLEN="000010" DECIMALS="000000" SIGNFLAG="X" MASK="  INT4E" MASKLEN="0000" DDTEXT="Compteur enregistrements suivants dans tables EXPORT/IMPORT" REPTEXT="Compteur enregistrements successifs" SCRTEXT_S="Compteur" SCRTEXT_M="Compteur enreg." SCRTEXT_L="Compteur enregistr." DOMNAME3L="SYBIN4" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZCLUST_TYPE_DEF" FIELDNAME="TYPE_DEF" DDLANGUAGE="F" POSITION="0005" ROLLNAME="FDT_DDIC_ABSOLUTE_NAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000400" ROUTPUTLEN="000000" HEADLEN="13" SCRLEN1="07" SCRLEN2="13" SCRLEN3="13" DTELMASTER="E" DATATYPE="CHAR" LENG="000200" OUTPUTLEN="000200" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="BRFplus : nom absolu du Dictionnaire ABAP" REPTEXT="Nom absolu" SCRTEXT_S="NomAbs." SCRTEXT_M="Nom absolu" SCRTEXT_L="Nom absolu" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZCLUST_TYPE_DEF" FIELDNAME="UNAME" DDLANGUAGE="F" POSITION="0006" ROLLNAME="UNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000024" DOMNAME="UNAME" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000012" OUTPUTLEN="000012" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom d&apos;utilisateur" REPTEXT="Nom d&apos;utilisateur" SCRTEXT_S="Utilisat." SCRTEXT_M="Nom utilisateur" SCRTEXT_L="Nom d&apos;utilisateur" DOMNAME3L="UNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZCLUST_TYPE_DEF" FIELDNAME="TIMESTAMP" DDLANGUAGE="F" POSITION="0007" ROLLNAME="TIMESTAMP" ADMINFIELD="0" INTTYPE="P" INTLEN="000008" DOMNAME="TZNTSTMPS" ROUTPUTLEN="000000" HEADLEN="19" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="DEC" LENG="000015" OUTPUTLEN="000019" DECIMALS="000000" MASK="  DEC E" MASKLEN="0000" DDTEXT="Horodatage UTC en abrégé (AAAAMMJJhhmmss)" REPTEXT="Horodatage" SCRTEXT_S="Horodatage" SCRTEXT_M="Horodatage" SCRTEXT_L="Horodatage" DOMMASTER="D" DOMNAME3L="TZNTSTMPS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZCLUST_TYPE_DEF" FIELDNAME="DATA_SIZE" DDLANGUAGE="F" POSITION="0008" ROLLNAME="ABAP_MSIZE" ADMINFIELD="0" INTTYPE="P" INTLEN="000011" DOMNAME="ABAP_MSIZE" ROUTPUTLEN="000000" HEADLEN="29" SCRLEN1="10" SCRLEN2="14" SCRLEN3="29" DTELMASTER="D" DATATYPE="DEC" LENG="000020" OUTPUTLEN="000026" DECIMALS="000000" MASK="  DEC E" MASKLEN="0000" DDTEXT="Type DEC correct pour nombre entier 64 octets" REPTEXT="Nbre entier 64 oct. avec +/-" SCRTEXT_S="Ent.64oct." SCRTEXT_M="Entier 64 oct." SCRTEXT_L="Nbre entier 64 oct. avec +/-" DOMNAME3L="ABAP_MSIZE" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZCLUST_TYPE_DEF" FIELDNAME="IS_COMPRESSED" DDLANGUAGE="F" POSITION="0009" ROLLNAME="G_COMPRESS" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="01" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Comprimer données" REPTEXT="C" SCRTEXT_S="Comprimer" SCRTEXT_M="Comprimer" SCRTEXT_L="Comprimer" DOMNAME3L="XFELD" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZCLUST_TYPE_DEF" FIELDNAME="CLUSTR" DDLANGUAGE="F" POSITION="0010" ROLLNAME="INDX_CLSTR" ADMINFIELD="0" INTTYPE="X" INTLEN="000002" DOMNAME="SYBIN2" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DATATYPE="INT2" LENG="000005" OUTPUTLEN="000005" DECIMALS="000000" SIGNFLAG="X" MASK="  INT2E" MASKLEN="0000" DDTEXT="Zone longueur pour données util. ds tables export/import" REPTEXT="Longueur données" SCRTEXT_S="Longueur" SCRTEXT_M="Long. données" SCRTEXT_L="Longueur données" DOMNAME3L="SYBIN2" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZCLUST_TYPE_DEF" FIELDNAME="CLUSTD" DDLANGUAGE="F" POSITION="0011" ROLLNAME="INDX_CLUST" ADMINFIELD="0" INTTYPE="X" INTLEN="002886" DOMNAME="INDX_CLUST" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="LRAW" LENG="002886" OUTPUTLEN="002886" DECIMALS="000000" MASK="  LRAWE" MASKLEN="0000" DDTEXT="Zone données pour tables de base de données IMPORT/EXPORT" REPTEXT="Données" SCRTEXT_S="Données" SCRTEXT_M="Données" SCRTEXT_L="Données" DOMMASTER="D" DOMNAME3L="INDX_CLUST" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd12v SQLTAB="ZCLUST_TYPE_DEF" INDEXNAME="ZID" AS4LOCAL="A" AS4VERS="0000" DDLANGUAGE="F" AUTHCLASS="00" DDTEXT="Index sur Type" PHRASE_INDX_RATIO="000"/>
  <dd17v SQLTAB="ZCLUST_TYPE_DEF" INDEXNAME="ZID" POSITION="0001" AS4LOCAL="A" AS4VERS="0000" FIELDNAME="MANDT"/>
  <dd17v SQLTAB="ZCLUST_TYPE_DEF" INDEXNAME="ZID" POSITION="0002" AS4LOCAL="A" AS4VERS="0000" FIELDNAME="TYPE_DEF"/>
 </TABL>
 <TABL TABNAME="ZTASK_FUNC_PARAM" DDLANGUAGE="F" TABCLASS="TRANSP" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" CLIDEP="X" LANGDEP="X" DDTEXT="Tâche - Paramétrage sur Traitement d&apos;Appel" AUTHCLASS="00" MAINFLAG="X" CONTFLAG="C" PROZPUFF="000" EXCLASS="1">
  <dd09l TABNAME="ZTASK_FUNC_PARAM" AS4LOCAL="A" AS4VERS="0000" TABKAT="0" TABART="APPL1" PUFFERUNG="X" SCHFELDANZ="000" BUFALLOW="X" ROWORCOLST="C"/>
  <dd03p TABNAME="ZTASK_FUNC_PARAM" FIELDNAME="MANDT" DDLANGUAGE="F" POSITION="0001" KEYFLAG="X" ROLLNAME="MANDT" ADMINFIELD="0" INTTYPE="C" INTLEN="000006" NOTNULL="X" DOMNAME="MANDT" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" RESERVEDTE="D" DATATYPE="CLNT" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" ENTITYTAB="T000" MASK="  CLNTE" MASKLEN="0000" DDTEXT="Mandant" REPTEXT="Mdt" SCRTEXT_S="Mandant" SCRTEXT_M="Mandant" SCRTEXT_L="Mandant" DOMNAME3L="MANDT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_FUNC_PARAM" FIELDNAME="PARAM_GUID" POSITION="0002" KEYFLAG="X" ROLLNAME="SYSUUID_X16" ADMINFIELD="0" INTTYPE="X" INTLEN="000016" NOTNULL="X" DOMNAME="SYSUUID_X16" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="04" SCRLEN2="04" SCRLEN3="04" DTELMASTER="D" DATATYPE="RAW" LENG="000016" OUTPUTLEN="000032" DECIMALS="000000" MASK="  RAW E" MASKLEN="0000" DOMNAME3L="SYSUUID_X16" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_FUNC_PARAM" FIELDNAME="FUNCNAME" DDLANGUAGE="F" POSITION="0003" ROLLNAME="RS38L_FNAM" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="FUNCNAME" ROUTPUTLEN="000000" MEMORYID="LIB" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TFDIR" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom du module fonction" REPTEXT="Nom du module fonction" SCRTEXT_S="Mod. fct." SCRTEXT_M="Module fonction" SCRTEXT_L="Module fonction" DOMNAME3L="FUNCNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_FUNC_PARAM" FIELDNAME="CLASS_NAME" DDLANGUAGE="F" POSITION="0004" ROLLNAME="SEOCLSNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="SEOCLSNAME" ROUTPUTLEN="000000" MEMORYID="CLASS" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom de type d&apos;objet" REPTEXT="Nom de type d&apos;objet" SCRTEXT_S="Type objet" SCRTEXT_M="Nom type objet" SCRTEXT_L="Classe/Interface" DOMNAME3L="SEOCLSNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_FUNC_PARAM" FIELDNAME="METHOD_NAME" DDLANGUAGE="F" POSITION="0005" ROLLNAME="SEOMTDNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000122" DOMNAME="CHAR61" ROUTPUTLEN="000000" MEMORYID="MTDNAME" HEADLEN="61" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000061" OUTPUTLEN="000061" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom d&apos;une méthode" REPTEXT="Méthode" SCRTEXT_S="Méthode" SCRTEXT_M="Méthode" SCRTEXT_L="Méthode" DOMNAME3L="CHAR61" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_FUNC_PARAM" FIELDNAME=".INCLUDE" DDLANGUAGE="F" POSITION="0006" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZTEC_S_TASK_TRACE_PARAM" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tâche - Paramètre de Trace" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_FUNC_PARAM" FIELDNAME="TRACE_ACTIVE" DDLANGUAGE="F" POSITION="0007" ROLLNAME="ZTRACE_XFELD" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="12" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Trace - Activation de trace" REPTEXT="Trace active" SCRTEXT_S="Trace" SCRTEXT_M="Trace active" SCRTEXT_L="Trace active" DOMNAME3L="XFELD" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_FUNC_PARAM" FIELDNAME="TRACE_MEMORY" DDLANGUAGE="F" POSITION="0008" ROLLNAME="ZTRACE_MEM_XFELD" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="20" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Trace - Activation Trace mémoire" REPTEXT="Trace mémoire active" SCRTEXT_S="Trace mém" SCRTEXT_M="Trace mémoire active" SCRTEXT_L="Trace mémoire active" DOMNAME3L="XFELD" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_FUNC_PARAM" FIELDNAME="SHM_MANAGEMENT" DDLANGUAGE="F" POSITION="0009" ROLLNAME="ZSHM_MANAGEMENT" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="17" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="SHM - Gestion de la SHM" REPTEXT="Gestion de la SHM" SCRTEXT_S="Gest. SHM" SCRTEXT_M="Gest. SHM" SCRTEXT_L="Gestion de la SHM" DOMNAME3L="XFELD" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_FUNC_PARAM" FIELDNAME=".INCLUDE" DDLANGUAGE="F" POSITION="0010" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZTEC_S_TASK_COMPRESS_PARAM" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tâche - Paramètres de compression" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_FUNC_PARAM" FIELDNAME="DATA_COMPRESS_LINE_BY_LINE" DDLANGUAGE="F" POSITION="0011" ROLLNAME="ZTASK_DATA_COMPRESS_LINE" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="20" SCRLEN3="40" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Tâche - Données - Compression données (ligne)" REPTEXT="Compression données lignes / lignes" SCRTEXT_S="Comp." SCRTEXT_M="Comp. L/L" SCRTEXT_L="Compression données" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_FUNC_PARAM" FIELDNAME="DATA_COMPRESS_GLOBAL" DDLANGUAGE="F" POSITION="0012" ROLLNAME="ZTASK_DATA_COMPRESS_GLOBAL" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="XSDBOOLEAN" ROUTPUTLEN="000000" HEADLEN="28" SCRLEN1="09" SCRLEN2="15" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Tâche - Données - Compression données globales" REPTEXT="Compression données globales" SCRTEXT_S="Comp. glb" SCRTEXT_M="Comp. globale" SCRTEXT_L="Compression globale" DOMNAME3L="XSDBOOLEAN" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd12v SQLTAB="ZTASK_FUNC_PARAM" INDEXNAME="ZFU" AS4LOCAL="A" AS4VERS="0000" DDLANGUAGE="F" AUTHCLASS="00" DDTEXT="Index sur Module Fonction" PHRASE_INDX_RATIO="000"/>
  <dd12v SQLTAB="ZTASK_FUNC_PARAM" INDEXNAME="ZME" AS4LOCAL="A" AS4VERS="0000" DDLANGUAGE="F" AUTHCLASS="00" DDTEXT="Index sur Classe / Méthode" PHRASE_INDX_RATIO="000"/>
  <dd17v SQLTAB="ZTASK_FUNC_PARAM" INDEXNAME="ZFU" POSITION="0001" AS4LOCAL="A" AS4VERS="0000" FIELDNAME="MANDT"/>
  <dd17v SQLTAB="ZTASK_FUNC_PARAM" INDEXNAME="ZFU" POSITION="0002" AS4LOCAL="A" AS4VERS="0000" FIELDNAME="FUNCNAME"/>
  <dd17v SQLTAB="ZTASK_FUNC_PARAM" INDEXNAME="ZME" POSITION="0001" AS4LOCAL="A" AS4VERS="0000" FIELDNAME="MANDT"/>
  <dd17v SQLTAB="ZTASK_FUNC_PARAM" INDEXNAME="ZME" POSITION="0002" AS4LOCAL="A" AS4VERS="0000" FIELDNAME="CLASS_NAME"/>
  <dd17v SQLTAB="ZTASK_FUNC_PARAM" INDEXNAME="ZME" POSITION="0003" AS4LOCAL="A" AS4VERS="0000" FIELDNAME="METHOD_NAME"/>
 </TABL>
 <TABL TABNAME="ZTASK_TRACE_H" DDLANGUAGE="F" TABCLASS="TRANSP" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" CLIDEP="X" LANGDEP="X" DDTEXT="Tâche - Historique" AUTHCLASS="00" CONTFLAG="A" PROZPUFF="000" EXCLASS="4">
  <dd09l TABNAME="ZTASK_TRACE_H" AS4LOCAL="A" AS4VERS="0000" TABKAT="0" TABART="APPL1" SCHFELDANZ="000" BUFALLOW="N" ROWORCOLST="C"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="MANDT" DDLANGUAGE="F" POSITION="0001" KEYFLAG="X" ROLLNAME="MANDT" ADMINFIELD="0" INTTYPE="C" INTLEN="000006" NOTNULL="X" DOMNAME="MANDT" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" RESERVEDTE="D" DATATYPE="CLNT" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" ENTITYTAB="T000" MASK="  CLNTE" MASKLEN="0000" DDTEXT="Mandant" REPTEXT="Mdt" SCRTEXT_S="Mandant" SCRTEXT_M="Mandant" SCRTEXT_L="Mandant" DOMNAME3L="MANDT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="TASK_TRACE_ID" DDLANGUAGE="F" POSITION="0002" KEYFLAG="X" ROLLNAME="ZTASK_TRACE_ID" ADMINFIELD="0" INTTYPE="C" INTLEN="000064" NOTNULL="X" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="08" SCRLEN1="08" SCRLEN2="08" SCRLEN3="08" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" OUTPUTLEN="000032" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Tâche - ID Trace" REPTEXT="ID Trace" SCRTEXT_S="ID Trace" SCRTEXT_M="ID Trace" SCRTEXT_L="ID Trace" DOMNAME3L="SYSUUID_C32" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="TASK_MANAGER_ID" DDLANGUAGE="F" POSITION="0003" ROLLNAME="ZTASK_MANAGER_ID" ADMINFIELD="0" INTTYPE="C" INTLEN="000064" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="32" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" OUTPUTLEN="000032" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Tâche - ID Manager Tâche" REPTEXT="ID Manager Tâche" SCRTEXT_S="ID Manager" SCRTEXT_M="ID Manager" SCRTEXT_L="ID Manager Tâche" DOMNAME3L="SYSUUID_C32" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="TASK_ID" DDLANGUAGE="F" POSITION="0004" ROLLNAME="ZTASK_ID" ADMINFIELD="0" INTTYPE="C" INTLEN="000064" DOMNAME="SYSUUID_C32" ROUTPUTLEN="000000" HEADLEN="32" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="F" DATATYPE="CHAR" LENG="000032" OUTPUTLEN="000032" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Tâche - ID Tâche" REPTEXT="ID Tâche" SCRTEXT_S="ID Tâche" SCRTEXT_M="ID Tâche" SCRTEXT_L="ID Tâche" DOMNAME3L="SYSUUID_C32" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="FUNCNAME" DDLANGUAGE="F" POSITION="0005" ROLLNAME="RS38L_FNAM" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="FUNCNAME" ROUTPUTLEN="000000" MEMORYID="LIB" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TFDIR" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom du module fonction" REPTEXT="Nom du module fonction" SCRTEXT_S="Mod. fct." SCRTEXT_M="Module fonction" SCRTEXT_L="Module fonction" DOMNAME3L="FUNCNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="REPIDNAME" DDLANGUAGE="F" POSITION="0006" ROLLNAME="REPID" ADMINFIELD="0" INTTYPE="C" INTLEN="000080" DOMNAME="PROGNAME" ROUTPUTLEN="000000" HEADLEN="10" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom du programme ABAP" REPTEXT="Programme" SCRTEXT_S="Programme" SCRTEXT_M="Nom programme" SCRTEXT_L="Nom du programme" DOMNAME3L="PROGNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="CLASSNAME" DDLANGUAGE="F" POSITION="0007" ROLLNAME="SEOCLSNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="SEOCLSNAME" ROUTPUTLEN="000000" MEMORYID="CLASS" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom de type d&apos;objet" REPTEXT="Nom de type d&apos;objet" SCRTEXT_S="Type objet" SCRTEXT_M="Nom type objet" SCRTEXT_L="Classe/Interface" DOMNAME3L="SEOCLSNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="METHODNAME" DDLANGUAGE="F" POSITION="0008" ROLLNAME="SEOMTDNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000122" DOMNAME="CHAR61" ROUTPUTLEN="000000" MEMORYID="MTDNAME" HEADLEN="61" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000061" OUTPUTLEN="000061" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom d&apos;une méthode" REPTEXT="Méthode" SCRTEXT_S="Méthode" SCRTEXT_M="Méthode" SCRTEXT_L="Méthode" DOMNAME3L="CHAR61" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="TIMESTAMP_BEG" DDLANGUAGE="F" POSITION="0009" ROLLNAME="TIMESTAMP" ADMINFIELD="0" INTTYPE="P" INTLEN="000008" DOMNAME="TZNTSTMPS" ROUTPUTLEN="000000" HEADLEN="19" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="DEC" LENG="000015" OUTPUTLEN="000019" DECIMALS="000000" MASK="  DEC E" MASKLEN="0000" DDTEXT="Horodatage UTC en abrégé (AAAAMMJJhhmmss)" REPTEXT="Horodatage" SCRTEXT_S="Horodatage" SCRTEXT_M="Horodatage" SCRTEXT_L="Horodatage" DOMMASTER="D" DOMNAME3L="TZNTSTMPS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="TIMESTAMP_END" DDLANGUAGE="F" POSITION="0010" ROLLNAME="TIMESTAMP" ADMINFIELD="0" INTTYPE="P" INTLEN="000008" DOMNAME="TZNTSTMPS" ROUTPUTLEN="000000" HEADLEN="19" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="DEC" LENG="000015" OUTPUTLEN="000019" DECIMALS="000000" MASK="  DEC E" MASKLEN="0000" DDTEXT="Horodatage UTC en abrégé (AAAAMMJJhhmmss)" REPTEXT="Horodatage" SCRTEXT_S="Horodatage" SCRTEXT_M="Horodatage" SCRTEXT_L="Horodatage" DOMMASTER="D" DOMNAME3L="TZNTSTMPS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="RUNTIME_BEG" DDLANGUAGE="F" POSITION="0011" ADMINFIELD="0" INTTYPE="X" INTLEN="000004" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="INT4" LENG="000010" OUTPUTLEN="000000" DECIMALS="000000" MASK="  INT4" MASKLEN="0000" DDTEXT="Début d&apos;exécution" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="RUNTIME_END" DDLANGUAGE="F" POSITION="0012" ADMINFIELD="0" INTTYPE="X" INTLEN="000004" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="INT4" LENG="000010" OUTPUTLEN="000000" DECIMALS="000000" MASK="  INT4" MASKLEN="0000" DDTEXT="Fin d&apos;exécution" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="RUNTIME_EXEC" DDLANGUAGE="F" POSITION="0013" ADMINFIELD="0" INTTYPE="X" INTLEN="000004" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="INT4" LENG="000010" OUTPUTLEN="000000" DECIMALS="000000" MASK="  INT4" MASKLEN="0000" DDTEXT="Durée d&apos;exécution" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="MEM_BEFORE" DDLANGUAGE="F" POSITION="0014" ADMINFIELD="0" INTTYPE="P" INTLEN="000011" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="DEC" LENG="000020" OUTPUTLEN="000000" DECIMALS="000000" MASK="  DEC" MASKLEN="0000" DDTEXT="Type DEC correct pour nombre entier 64 octets" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="MEM_AFTER" DDLANGUAGE="F" POSITION="0015" ADMINFIELD="0" INTTYPE="P" INTLEN="000011" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="DEC" LENG="000020" OUTPUTLEN="000000" DECIMALS="000000" MASK="  DEC" MASKLEN="0000" DDTEXT="Type DEC correct pour nombre entier 64 octets" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="MEM_ALLOCATED" DDLANGUAGE="F" POSITION="0016" ADMINFIELD="0" INTTYPE="P" INTLEN="000011" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="DEC" LENG="000020" OUTPUTLEN="000000" DECIMALS="000000" MASK="  DEC" MASKLEN="0000" DDTEXT="Type DEC correct pour nombre entier 64 octets" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="UNAME" DDLANGUAGE="F" POSITION="0017" ROLLNAME="UNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000024" DOMNAME="UNAME" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000012" OUTPUTLEN="000012" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom d&apos;utilisateur" REPTEXT="Nom d&apos;utilisateur" SCRTEXT_S="Utilisat." SCRTEXT_M="Nom utilisateur" SCRTEXT_L="Nom d&apos;utilisateur" DOMNAME3L="UNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME=".INCLUDE" DDLANGUAGE="F" POSITION="0018" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ABAP_CALLSTACK_LINE" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Ligne d&apos;une pile d&apos;appel ABAP (avec positions programme)" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="MAINPROGRAM" DDLANGUAGE="F" POSITION="0019" ROLLNAME="SYREPID" ADMINFIELD="1" INTTYPE="C" INTLEN="000080" DOMNAME="PROGRAMM" ROUTPUTLEN="000000" HEADLEN="08" SCRLEN1="10" SCRLEN2="20" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" ENTITYTAB="TRDIR" MASK="  CHARE" MASKLEN="0000" DDTEXT="Programme ABAP, programme cadre actuel" REPTEXT="Progr." SCRTEXT_S="Programme" SCRTEXT_M="Nom du programme" SCRTEXT_L="Nom du programme" DOMNAME3L="PROGRAMM" DEPTH="00" COMPTYPE="E" DEFFDNAME="PROGRAM_NAME" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="INCLUDE" DDLANGUAGE="F" POSITION="0020" ROLLNAME="INCLUDE" ADMINFIELD="1" INTTYPE="C" INTLEN="000080" DOMNAME="PROGNAME" ROUTPUTLEN="000000" HEADLEN="08" SCRLEN1="10" SCRLEN2="00" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Include utilisé" REPTEXT="Include" SCRTEXT_S="Include" SCRTEXT_L="Include utilisé" DOMNAME3L="PROGNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="LINE" DDLANGUAGE="F" POSITION="0021" ADMINFIELD="1" INTTYPE="X" INTLEN="000004" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="INT4" LENG="000010" OUTPUTLEN="000000" DECIMALS="000000" MASK="  INT4" MASKLEN="0000" DDTEXT="Numéro de ligne (dans l&apos;include)" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="BLOCKTYPE" DDLANGUAGE="F" POSITION="0022" ADMINFIELD="1" INTTYPE="C" INTLEN="000024" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="CHAR" LENG="000012" OUTPUTLEN="000000" DECIMALS="000000" MASK="  CHAR" MASKLEN="0000" DDTEXT="Type du bloc de traitement (procédure, module, bloc événemt)" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="BLOCKNAME" DDLANGUAGE="F" POSITION="0023" ADMINFIELD="1" INTTYPE="g" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRG" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRG" MASKLEN="0000" DDTEXT="Nom du bloc de traitement" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTASK_TRACE_H" FIELDNAME="FLAG_SYSTEM" DDLANGUAGE="F" POSITION="0024" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000000" DECIMALS="000000" MASK="  CHAR" MASKLEN="0000" DDTEXT="Code : bloc de traitement système ou dans programme système" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTEC_S_TASK_CALL_PROCESS" DDLANGUAGE="F" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Tâche - Traitement à lancer" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTEC_S_TASK_CALL_PROCESS" FIELDNAME="FUNCTION_NAME" DDLANGUAGE="F" POSITION="0001" ROLLNAME="RS38L_FNAM" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="FUNCNAME" ROUTPUTLEN="000000" MEMORYID="LIB" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TFDIR" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom du module fonction" REPTEXT="Nom du module fonction" SCRTEXT_S="Mod. fct." SCRTEXT_M="Module fonction" SCRTEXT_L="Module fonction" DOMNAME3L="FUNCNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_CALL_PROCESS" FIELDNAME="CLASS_NAME" DDLANGUAGE="F" POSITION="0002" ROLLNAME="SEOCLSNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="SEOCLSNAME" ROUTPUTLEN="000000" MEMORYID="CLASS" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom de type d&apos;objet" REPTEXT="Nom de type d&apos;objet" SCRTEXT_S="Type objet" SCRTEXT_M="Nom type objet" SCRTEXT_L="Classe/Interface" DOMNAME3L="SEOCLSNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_CALL_PROCESS" FIELDNAME="METHOD_NAME" DDLANGUAGE="F" POSITION="0003" ROLLNAME="SEOMTDNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000122" DOMNAME="CHAR61" ROUTPUTLEN="000000" MEMORYID="MTDNAME" HEADLEN="61" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000061" OUTPUTLEN="000061" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom d&apos;une méthode" REPTEXT="Méthode" SCRTEXT_S="Méthode" SCRTEXT_M="Méthode" SCRTEXT_L="Méthode" DOMNAME3L="CHAR61" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTEC_S_TASK_CALL_PROCESS" FIELDNAME="REPID_NAME" DDLANGUAGE="F" POSITION="0004" ROLLNAME="REPID" ADMINFIELD="0" INTTYPE="C" INTLEN="000080" DOMNAME="PROGNAME" ROUTPUTLEN="000000" HEADLEN="10" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nom du programme ABAP" REPTEXT="Programme" SCRTEXT_S="Programme" SCRTEXT_M="Nom programme" SCRTEXT_L="Nom du programme" DOMNAME3L="PROGNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TTYP TYPENAME="ZTEC_T_FUNCTION_PARAMETERS" DDLANGUAGE="F" ROWTYPE="ZTEC_S_FUNCTION_PARAMETERS" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Type de table paramètre d&apos;appel Statique" TYPELEN="000352" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZTEC_T_METHOD_PARAMETERS" DDLANGUAGE="F" ROWTYPE="ZTEC_S_METHOD_PARAMETERS" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Méthode : Type de table paramétres d&apos;appel Statique" TYPELEN="000344" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZTEC_T_TASK_CALL_PROCESS" DDLANGUAGE="F" ROWTYPE="ZTEC_S_TASK_CALL_PROCESS" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Tâche - Type de Table de Traitement à lancer" TYPELEN="000322" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZTEC_T_CONTENT_DATA" DDLANGUAGE="F" ROWTYPE="ZTEC_S_CONTENT_DATA" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="S" KEYDEF="K" KEYKIND="U" KEYFDCOUNT="0003" DDTEXT="Table contenu de données - statiques" TYPELEN="000148" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000">
  <dd42v TYPENAME="ZTEC_T_CONTENT_DATA" KEYFDPOS="0001" ROWTYPEPOS="0001" KEYFIELD="SUB_DATA_GUID"/>
  <dd42v TYPENAME="ZTEC_T_CONTENT_DATA" KEYFDPOS="0002" ROWTYPEPOS="0002" KEYFIELD="LINE"/>
  <dd42v TYPENAME="ZTEC_T_CONTENT_DATA" KEYFDPOS="0003" ROWTYPEPOS="0003" KEYFIELD="FIELDNAME"/>
 </TTYP>
 <TTYP TYPENAME="ZTASK_TRACE_H_T" DDLANGUAGE="F" ROWTYPE="ZTASK_TRACE_H" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Trace Tâche - Type de table" TYPELEN="000808" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
</nugget>
